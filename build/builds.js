!function(n){var g={};function e(t){if(g[t])return g[t].exports;var I=g[t]={i:t,l:!1,exports:{}};return n[t].call(I.exports,I,I.exports,e),I.l=!0,I.exports}e.m=n,e.c=g,e.d=function(n,g,t){e.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:t})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,g){if(1&g&&(n=e(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var I in n)e.d(t,I,function(g){return n[g]}.bind(null,I));return t},e.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(g,"a",g),g},e.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},e.p="",e(e.s=16)}([function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 66);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractEvent = __webpack_require__(64);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _AbstractEvent2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractPlugin = __webpack_require__(60);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _AbstractPlugin2.default;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _closest = __webpack_require__(51);\n\nObject.defineProperty(exports, 'closest', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_closest).default;\n  }\n});\n\nvar _requestNextAnimationFrame = __webpack_require__(49);\n\nObject.defineProperty(exports, 'requestNextAnimationFrame', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_requestNextAnimationFrame).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SensorEvent = __webpack_require__(44);\n\nObject.keys(_SensorEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SensorEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Sensor = __webpack_require__(47);\n\nvar _Sensor2 = _interopRequireDefault(_Sensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Sensor2.default;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DragEvent = __webpack_require__(14);\n\nObject.keys(_DragEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DragEvent[key];\n    }\n  });\n});\n\nvar _DraggableEvent = __webpack_require__(13);\n\nObject.keys(_DraggableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DraggableEvent[key];\n    }\n  });\n});\n\nvar _Plugins = __webpack_require__(12);\n\nObject.keys(_Plugins).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _Plugins[key];\n    }\n  });\n});\n\nvar _Sensors = __webpack_require__(6);\n\nObject.keys(_Sensors).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _Sensors[key];\n    }\n  });\n});\n\nvar _Draggable = __webpack_require__(37);\n\nvar _Draggable2 = _interopRequireDefault(_Draggable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Draggable2.default;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Sensor = __webpack_require__(4);\n\nObject.defineProperty(exports, 'Sensor', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Sensor).default;\n  }\n});\n\nvar _MouseSensor = __webpack_require__(46);\n\nObject.defineProperty(exports, 'MouseSensor', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_MouseSensor).default;\n  }\n});\n\nvar _TouchSensor = __webpack_require__(43);\n\nObject.defineProperty(exports, 'TouchSensor', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_TouchSensor).default;\n  }\n});\n\nvar _DragSensor = __webpack_require__(41);\n\nObject.defineProperty(exports, 'DragSensor', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_DragSensor).default;\n  }\n});\n\nvar _ForceTouchSensor = __webpack_require__(39);\n\nObject.defineProperty(exports, 'ForceTouchSensor', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_ForceTouchSensor).default;\n  }\n});\n\nvar _SensorEvent = __webpack_require__(3);\n\nObject.keys(_SensorEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SensorEvent[key];\n    }\n  });\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SnappableEvent = __webpack_require__(18);\n\nObject.keys(_SnappableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SnappableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _CollidableEvent = __webpack_require__(23);\n\nObject.keys(_CollidableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _CollidableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SortableEvent = __webpack_require__(27);\n\nObject.keys(_SortableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SortableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SwappableEvent = __webpack_require__(30);\n\nObject.keys(_SwappableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SwappableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DroppableEvent = __webpack_require__(33);\n\nObject.keys(_DroppableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DroppableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Announcement = __webpack_require__(62);\n\nObject.defineProperty(exports, 'Announcement', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Announcement).default;\n  }\n});\nObject.defineProperty(exports, 'defaultAnnouncementOptions', {\n  enumerable: true,\n  get: function () {\n    return _Announcement.defaultOptions;\n  }\n});\n\nvar _Focusable = __webpack_require__(59);\n\nObject.defineProperty(exports, 'Focusable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Focusable).default;\n  }\n});\n\nvar _Mirror = __webpack_require__(57);\n\nObject.defineProperty(exports, 'Mirror', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Mirror).default;\n  }\n});\nObject.defineProperty(exports, 'defaultMirrorOptions', {\n  enumerable: true,\n  get: function () {\n    return _Mirror.defaultOptions;\n  }\n});\n\nvar _Scrollable = __webpack_require__(53);\n\nObject.defineProperty(exports, 'Scrollable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Scrollable).default;\n  }\n});\nObject.defineProperty(exports, 'defaultScrollableOptions', {\n  enumerable: true,\n  get: function () {\n    return _Scrollable.defaultOptions;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DraggableEvent = __webpack_require__(63);\n\nObject.keys(_DraggableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DraggableEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DragEvent = __webpack_require__(65);\n\nObject.keys(_DragEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DragEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onSortableSorted = Symbol('onSortableSorted');\n\n/**\n * SwapAnimation default options\n * @property {Object} defaultOptions\n * @property {Number} defaultOptions.duration\n * @property {String} defaultOptions.easingFunction\n * @property {Boolean} defaultOptions.horizontal\n * @type {Object}\n */\nconst defaultOptions = exports.defaultOptions = {\n  duration: 150,\n  easingFunction: 'ease-in-out',\n  horizontal: false\n};\n\n/**\n * SwapAnimation plugin adds swap animations for sortable\n * @class SwapAnimation\n * @module SwapAnimation\n * @extends AbstractPlugin\n */\nclass SwapAnimation extends _AbstractPlugin2.default {\n  /**\n   * SwapAnimation constructor.\n   * @constructs SwapAnimation\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * SwapAnimation options\n     * @property {Object} options\n     * @property {Number} defaultOptions.duration\n     * @property {String} defaultOptions.easingFunction\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    /**\n     * Last animation frame\n     * @property {Number} lastAnimationFrame\n     * @type {Number}\n     */\n    this.lastAnimationFrame = null;\n\n    this[onSortableSorted] = this[onSortableSorted].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('sortable:sorted', this[onSortableSorted]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('sortable:sorted', this[onSortableSorted]);\n  }\n\n  /**\n   * Returns options passed through draggable\n   * @return {Object}\n   */\n  getOptions() {\n    return this.draggable.options.swapAnimation || {};\n  }\n\n  /**\n   * Sortable sorted handler\n   * @param {SortableSortedEvent} sortableEvent\n   * @private\n   */\n  [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {\n    const { source, over } = dragEvent;\n\n    cancelAnimationFrame(this.lastAnimationFrame);\n\n    // Can be done in a separate frame\n    this.lastAnimationFrame = requestAnimationFrame(() => {\n      if (oldIndex >= newIndex) {\n        animate(source, over, this.options);\n      } else {\n        animate(over, source, this.options);\n      }\n    });\n  }\n}\n\nexports.default = SwapAnimation; /**\n                                  * Animates two elements\n                                  * @param {HTMLElement} from\n                                  * @param {HTMLElement} to\n                                  * @param {Object} options\n                                  * @param {Number} options.duration\n                                  * @param {String} options.easingFunction\n                                  * @param {String} options.horizontal\n                                  * @private\n                                  */\n\nfunction animate(from, to, { duration, easingFunction, horizontal }) {\n  for (const element of [from, to]) {\n    element.style.pointerEvents = 'none';\n  }\n\n  if (horizontal) {\n    const width = from.offsetWidth;\n    from.style.transform = `translate3d(${width}px, 0, 0)`;\n    to.style.transform = `translate3d(-${width}px, 0, 0)`;\n  } else {\n    const height = from.offsetHeight;\n    from.style.transform = `translate3d(0, ${height}px, 0)`;\n    to.style.transform = `translate3d(0, -${height}px, 0)`;\n  }\n\n  requestAnimationFrame(() => {\n    for (const element of [from, to]) {\n      element.addEventListener('transitionend', resetElementOnTransitionEnd);\n      element.style.transition = `transform ${duration}ms ${easingFunction}`;\n      element.style.transform = '';\n    }\n  });\n}\n\n/**\n * Resets animation style properties after animation has completed\n * @param {Event} event\n * @private\n */\nfunction resetElementOnTransitionEnd(event) {\n  event.target.style.transition = '';\n  event.target.style.pointerEvents = '';\n  event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);\n}\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _SwapAnimation = __webpack_require__(15);\n\nvar _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _SwapAnimation2.default;\nexports.defaultOptions = _SwapAnimation.defaultOptions;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _SnappableEvent = __webpack_require__(7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = Symbol('onDragStart');\nconst onDragStop = Symbol('onDragStop');\nconst onDragOver = Symbol('onDragOver');\nconst onDragOut = Symbol('onDragOut');\nconst onMirrorCreated = Symbol('onMirrorCreated');\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\n\n/**\n * Snappable plugin which snaps draggable elements into place\n * @class Snappable\n * @module Snappable\n * @extends AbstractPlugin\n */\nclass Snappable extends _AbstractPlugin2.default {\n  /**\n   * Snappable constructor.\n   * @constructs Snappable\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Keeps track of the first source element\n     * @property {HTMLElement|null} firstSource\n     */\n    this.firstSource = null;\n\n    /**\n     * Keeps track of the mirror element\n     * @property {HTMLElement} mirror\n     */\n    this.mirror = null;\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n    this[onDragOver] = this[onDragOver].bind(this);\n    this[onDragOut] = this[onDragOut].bind(this);\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {DragStartEvent} event - Drag start event\n   */\n  [onDragStart](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    this.firstSource = event.source;\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {DragStopEvent} event - Drag stop event\n   */\n  [onDragStop]() {\n    this.firstSource = null;\n  }\n\n  /**\n   * Drag over handler\n   * @private\n   * @param {DragOverEvent|DroppableOverEvent} event - Drag over event\n   */\n  [onDragOver](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    const source = event.source || event.dragEvent.source;\n\n    if (source === this.firstSource) {\n      this.firstSource = null;\n      return;\n    }\n\n    const snapInEvent = new _SnappableEvent.SnapInEvent({\n      dragEvent: event,\n      snappable: event.over || event.droppable\n    });\n\n    this.draggable.trigger(snapInEvent);\n\n    if (snapInEvent.canceled()) {\n      return;\n    }\n\n    if (this.mirror) {\n      this.mirror.style.display = 'none';\n    }\n\n    source.classList.remove(this.draggable.getClassNameFor('source:dragging'));\n    source.classList.add(this.draggable.getClassNameFor('source:placed'));\n\n    // Need to cancel this in drag out\n    setTimeout(() => {\n      source.classList.remove(this.draggable.getClassNameFor('source:placed'));\n    }, this.draggable.options.placedTimeout);\n  }\n\n  /**\n   * Drag out handler\n   * @private\n   * @param {DragOutEvent|DroppableOutEvent} event - Drag out event\n   */\n  [onDragOut](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    const source = event.source || event.dragEvent.source;\n\n    const snapOutEvent = new _SnappableEvent.SnapOutEvent({\n      dragEvent: event,\n      snappable: event.over || event.droppable\n    });\n\n    this.draggable.trigger(snapOutEvent);\n\n    if (snapOutEvent.canceled()) {\n      return;\n    }\n\n    if (this.mirror) {\n      this.mirror.style.display = '';\n    }\n\n    source.classList.add(this.draggable.getClassNameFor('source:dragging'));\n  }\n\n  /**\n   * Mirror created handler\n   * @param {MirrorCreatedEvent} mirrorEvent\n   * @private\n   */\n  [onMirrorCreated]({ mirror }) {\n    this.mirror = mirror;\n  }\n\n  /**\n   * Mirror destroy handler\n   * @param {MirrorDestroyEvent} mirrorEvent\n   * @private\n   */\n  [onMirrorDestroy]() {\n    this.mirror = null;\n  }\n}\nexports.default = Snappable;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base snap event\n * @class SnapEvent\n * @module SnapEvent\n * @extends AbstractEvent\n */\nclass SnapEvent extends _AbstractEvent2.default {\n\n  /**\n   * Drag event that triggered this snap event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n\n  /**\n   * Snappable element\n   * @property snappable\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get snappable() {\n    return this.data.snappable;\n  }\n}\n\nexports.SnapEvent = SnapEvent; /**\n                                * Snap in event\n                                * @class SnapInEvent\n                                * @module SnapInEvent\n                                * @extends SnapEvent\n                                */\n\nSnapEvent.type = 'snap';\nclass SnapInEvent extends SnapEvent {}\n\nexports.SnapInEvent = SnapInEvent; /**\n                                    * Snap out event\n                                    * @class SnapOutEvent\n                                    * @module SnapOutEvent\n                                    * @extends SnapEvent\n                                    */\n\nSnapInEvent.type = 'snap:in';\nSnapInEvent.cancelable = true;\nclass SnapOutEvent extends SnapEvent {}\nexports.SnapOutEvent = SnapOutEvent;\nSnapOutEvent.type = 'snap:out';\nSnapOutEvent.cancelable = true;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SnappableEvent = __webpack_require__(7);\n\nObject.keys(_SnappableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SnappableEvent[key];\n    }\n  });\n});\n\nvar _Snappable = __webpack_require__(17);\n\nvar _Snappable2 = _interopRequireDefault(_Snappable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Snappable2.default;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onMirrorCreated = Symbol('onMirrorCreated');\nconst onMirrorDestroy = Symbol('onMirrorDestroy');\nconst onDragOver = Symbol('onDragOver');\nconst resize = Symbol('resize');\n\n/**\n * ResizeMirror default options\n * @property {Object} defaultOptions\n * @type {Object}\n */\nconst defaultOptions = exports.defaultOptions = {};\n\n/**\n * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over\n * @class ResizeMirror\n * @module ResizeMirror\n * @extends AbstractPlugin\n */\nclass ResizeMirror extends _AbstractPlugin2.default {\n  /**\n   * ResizeMirror constructor.\n   * @constructs ResizeMirror\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * ResizeMirror options\n     * @property {Object} options\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    /**\n     * ResizeMirror remembers the last width when resizing the mirror\n     * to avoid additional writes to the DOM\n     * @property {number} lastWidth\n     */\n    this.lastWidth = 0;\n\n    /**\n     * ResizeMirror remembers the last height when resizing the mirror\n     * to avoid additional writes to the DOM\n     * @property {number} lastHeight\n     */\n    this.lastHeight = 0;\n\n    /**\n     * Keeps track of the mirror element\n     * @property {HTMLElement} mirror\n     */\n    this.mirror = null;\n\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\n    this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);\n    this[onDragOver] = this[onDragOver].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);\n  }\n\n  /**\n   * Returns options passed through draggable\n   * @return {Object}\n   */\n  getOptions() {\n    return this.draggable.options.resizeMirror || {};\n  }\n\n  /**\n   * Mirror created handler\n   * @param {MirrorCreatedEvent} mirrorEvent\n   * @private\n   */\n  [onMirrorCreated]({ mirror }) {\n    this.mirror = mirror;\n  }\n\n  /**\n   * Mirror destroy handler\n   * @param {MirrorDestroyEvent} mirrorEvent\n   * @private\n   */\n  [onMirrorDestroy]() {\n    this.mirror = null;\n  }\n\n  /**\n   * Drag over handler\n   * @param {DragOverEvent | DragOverContainer} dragEvent\n   * @private\n   */\n  [onDragOver](dragEvent) {\n    this[resize](dragEvent);\n  }\n\n  /**\n   * Resize function for\n   * @param {DragOverEvent | DragOverContainer} dragEvent\n   * @private\n   */\n  [resize]({ overContainer, over }) {\n    requestAnimationFrame(() => {\n      if (this.mirror.parentNode !== overContainer) {\n        overContainer.appendChild(this.mirror);\n      }\n\n      const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];\n\n      if (!overElement) {\n        return;\n      }\n\n      (0, _utils.requestNextAnimationFrame)(() => {\n        const overRect = overElement.getBoundingClientRect();\n\n        if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {\n          return;\n        }\n\n        this.mirror.style.width = `${overRect.width}px`;\n        this.mirror.style.height = `${overRect.height}px`;\n\n        this.lastWidth = overRect.width;\n        this.lastHeight = overRect.height;\n      });\n    });\n  }\n}\nexports.default = ResizeMirror;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _ResizeMirror = __webpack_require__(20);\n\nvar _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _ResizeMirror2.default;\nexports.defaultOptions = _ResizeMirror.defaultOptions;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _utils = __webpack_require__(2);\n\nvar _CollidableEvent = __webpack_require__(8);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragMove = Symbol('onDragMove');\nconst onDragStop = Symbol('onDragStop');\nconst onRequestAnimationFrame = Symbol('onRequestAnimationFrame');\n\n/**\n * Collidable plugin which detects colliding elements while dragging\n * @class Collidable\n * @module Collidable\n * @extends AbstractPlugin\n */\nclass Collidable extends _AbstractPlugin2.default {\n  /**\n   * Collidable constructor.\n   * @constructs Collidable\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Keeps track of currently colliding elements\n     * @property {HTMLElement|null} currentlyCollidingElement\n     * @type {HTMLElement|null}\n     */\n    this.currentlyCollidingElement = null;\n\n    /**\n     * Keeps track of currently colliding elements\n     * @property {HTMLElement|null} lastCollidingElement\n     * @type {HTMLElement|null}\n     */\n    this.lastCollidingElement = null;\n\n    /**\n     * Animation frame for finding colliding elements\n     * @property {Number|null} currentAnimationFrame\n     * @type {Number|null}\n     */\n    this.currentAnimationFrame = null;\n\n    this[onDragMove] = this[onDragMove].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n    this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Returns current collidables based on `collidables` option\n   * @return {HTMLElement[]}\n   */\n  getCollidables() {\n    const collidables = this.draggable.options.collidables;\n\n    if (typeof collidables === 'string') {\n      return Array.prototype.slice.call(document.querySelectorAll(collidables));\n    } else if (collidables instanceof NodeList || collidables instanceof Array) {\n      return Array.prototype.slice.call(collidables);\n    } else if (collidables instanceof HTMLElement) {\n      return [collidables];\n    } else if (typeof collidables === 'function') {\n      return collidables();\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Drag move handler\n   * @private\n   * @param {DragMoveEvent} event - Drag move event\n   */\n  [onDragMove](event) {\n    const target = event.sensorEvent.target;\n\n    this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));\n\n    if (this.currentlyCollidingElement) {\n      event.cancel();\n    }\n\n    const collidableInEvent = new _CollidableEvent.CollidableInEvent({\n      dragEvent: event,\n      collidingElement: this.currentlyCollidingElement\n    });\n\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\n      dragEvent: event,\n      collidingElement: this.lastCollidingElement\n    });\n\n    const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);\n    const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);\n\n    if (enteringCollidable) {\n      if (this.lastCollidingElement) {\n        this.draggable.trigger(collidableOutEvent);\n      }\n\n      this.draggable.trigger(collidableInEvent);\n    } else if (leavingCollidable) {\n      this.draggable.trigger(collidableOutEvent);\n    }\n\n    this.lastCollidingElement = this.currentlyCollidingElement;\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {DragStopEvent} event - Drag stop event\n   */\n  [onDragStop](event) {\n    const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;\n    const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({\n      dragEvent: event,\n      collidingElement: lastCollidingElement\n    });\n\n    if (lastCollidingElement) {\n      this.draggable.trigger(collidableOutEvent);\n    }\n\n    this.lastCollidingElement = null;\n    this.currentlyCollidingElement = null;\n  }\n\n  /**\n   * Animation frame function\n   * @private\n   * @param {HTMLElement} target - Current move target\n   * @return {Function}\n   */\n  [onRequestAnimationFrame](target) {\n    return () => {\n      const collidables = this.getCollidables();\n      this.currentlyCollidingElement = (0, _utils.closest)(target, element => collidables.includes(element));\n    };\n  }\n}\nexports.default = Collidable;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base collidable event\n * @class CollidableEvent\n * @module CollidableEvent\n * @extends AbstractEvent\n */\nclass CollidableEvent extends _AbstractEvent2.default {\n\n  /**\n   * Drag event that triggered this colliable event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n}\n\nexports.CollidableEvent = CollidableEvent; /**\n                                            * Collidable in event\n                                            * @class CollidableInEvent\n                                            * @module CollidableInEvent\n                                            * @extends CollidableEvent\n                                            */\n\nCollidableEvent.type = 'collidable';\nclass CollidableInEvent extends CollidableEvent {\n\n  /**\n   * Element you are currently colliding with\n   * @property collidingElement\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get collidingElement() {\n    return this.data.collidingElement;\n  }\n}\n\nexports.CollidableInEvent = CollidableInEvent; /**\n                                                * Collidable out event\n                                                * @class CollidableOutEvent\n                                                * @module CollidableOutEvent\n                                                * @extends CollidableEvent\n                                                */\n\nCollidableInEvent.type = 'collidable:in';\nclass CollidableOutEvent extends CollidableEvent {\n\n  /**\n   * Element you were previously colliding with\n   * @property collidingElement\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get collidingElement() {\n    return this.data.collidingElement;\n  }\n}\nexports.CollidableOutEvent = CollidableOutEvent;\nCollidableOutEvent.type = 'collidable:out';\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _CollidableEvent = __webpack_require__(8);\n\nObject.keys(_CollidableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _CollidableEvent[key];\n    }\n  });\n});\n\nvar _Collidable = __webpack_require__(22);\n\nvar _Collidable2 = _interopRequireDefault(_Collidable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Collidable2.default;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Collidable = __webpack_require__(24);\n\nObject.defineProperty(exports, 'Collidable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Collidable).default;\n  }\n});\n\nvar _ResizeMirror = __webpack_require__(21);\n\nObject.defineProperty(exports, 'ResizeMirror', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_ResizeMirror).default;\n  }\n});\nObject.defineProperty(exports, 'defaultResizeMirrorOptions', {\n  enumerable: true,\n  get: function () {\n    return _ResizeMirror.defaultOptions;\n  }\n});\n\nvar _Snappable = __webpack_require__(19);\n\nObject.defineProperty(exports, 'Snappable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Snappable).default;\n  }\n});\n\nvar _SwapAnimation = __webpack_require__(16);\n\nObject.defineProperty(exports, 'SwapAnimation', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_SwapAnimation).default;\n  }\n});\nObject.defineProperty(exports, 'defaultSwapAnimationOptions', {\n  enumerable: true,\n  get: function () {\n    return _SwapAnimation.defaultOptions;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _Draggable = __webpack_require__(5);\n\nvar _Draggable2 = _interopRequireDefault(_Draggable);\n\nvar _SortableEvent = __webpack_require__(9);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = Symbol('onDragStart');\nconst onDragOverContainer = Symbol('onDragOverContainer');\nconst onDragOver = Symbol('onDragOver');\nconst onDragStop = Symbol('onDragStop');\n\n/**\n * Returns announcement message when a Draggable element has been sorted with another Draggable element\n * or moved into a new container\n * @param {SortableSortedEvent} sortableEvent\n * @return {String}\n */\nfunction onSortableSortedDefaultAnnouncement({ dragEvent }) {\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';\n\n  if (dragEvent.over) {\n    const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';\n    const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n    if (isFollowing) {\n      return `Placed ${sourceText} after ${overText}`;\n    } else {\n      return `Placed ${sourceText} before ${overText}`;\n    }\n  } else {\n    // need to figure out how to compute container name\n    return `Placed ${sourceText} into a different container`;\n  }\n}\n\n/**\n * @const {Object} defaultAnnouncements\n * @const {Function} defaultAnnouncements['sortable:sorted']\n */\nconst defaultAnnouncements = {\n  'sortable:sorted': onSortableSortedDefaultAnnouncement\n};\n\n/**\n * Sortable is built on top of Draggable and allows sorting of draggable elements. Sortable will keep\n * track of the original index and emits the new index as you drag over draggable elements.\n * @class Sortable\n * @module Sortable\n * @extends Draggable\n */\nclass Sortable extends _Draggable2.default {\n  /**\n   * Sortable constructor.\n   * @constructs Sortable\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers\n   * @param {Object} options - Options for Sortable\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, _extends({}, options, {\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\n    }));\n\n    /**\n     * start index of source on drag start\n     * @property startIndex\n     * @type {Number}\n     */\n    this.startIndex = null;\n\n    /**\n     * start container on drag start\n     * @property startContainer\n     * @type {HTMLElement}\n     * @default null\n     */\n    this.startContainer = null;\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragOverContainer] = this[onDragOverContainer].bind(this);\n    this[onDragOver] = this[onDragOver].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n\n    this.on('drag:start', this[onDragStart]).on('drag:over:container', this[onDragOverContainer]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Destroys Sortable instance.\n   */\n  destroy() {\n    super.destroy();\n\n    this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source\n   * @param {HTMLElement} element - An element\n   * @return {Number}\n   */\n  index(element) {\n    return this.getDraggableElementsForContainer(element.parentNode).indexOf(element);\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {DragStartEvent} event - Drag start event\n   */\n  [onDragStart](event) {\n    this.startContainer = event.source.parentNode;\n    this.startIndex = this.index(event.source);\n\n    const sortableStartEvent = new _SortableEvent.SortableStartEvent({\n      dragEvent: event,\n      startIndex: this.startIndex,\n      startContainer: this.startContainer\n    });\n\n    this.trigger(sortableStartEvent);\n\n    if (sortableStartEvent.canceled()) {\n      event.cancel();\n    }\n  }\n\n  /**\n   * Drag over container handler\n   * @private\n   * @param {DragOverContainerEvent} event - Drag over container event\n   */\n  [onDragOverContainer](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    const { source, over, overContainer } = event;\n    const oldIndex = this.index(source);\n\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\n      dragEvent: event,\n      currentIndex: oldIndex,\n      source,\n      over\n    });\n\n    this.trigger(sortableSortEvent);\n\n    if (sortableSortEvent.canceled()) {\n      return;\n    }\n\n    const children = this.getDraggableElementsForContainer(overContainer);\n    const moves = move({ source, over, overContainer, children });\n\n    if (!moves) {\n      return;\n    }\n\n    const { oldContainer, newContainer } = moves;\n    const newIndex = this.index(event.source);\n\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\n      dragEvent: event,\n      oldIndex,\n      newIndex,\n      oldContainer,\n      newContainer\n    });\n\n    this.trigger(sortableSortedEvent);\n  }\n\n  /**\n   * Drag over handler\n   * @private\n   * @param {DragOverEvent} event - Drag over event\n   */\n  [onDragOver](event) {\n    if (event.over === event.originalSource || event.over === event.source) {\n      return;\n    }\n\n    const { source, over, overContainer } = event;\n    const oldIndex = this.index(source);\n\n    const sortableSortEvent = new _SortableEvent.SortableSortEvent({\n      dragEvent: event,\n      currentIndex: oldIndex,\n      source,\n      over\n    });\n\n    this.trigger(sortableSortEvent);\n\n    if (sortableSortEvent.canceled()) {\n      return;\n    }\n\n    const children = this.getDraggableElementsForContainer(overContainer);\n    const moves = move({ source, over, overContainer, children });\n\n    if (!moves) {\n      return;\n    }\n\n    const { oldContainer, newContainer } = moves;\n    const newIndex = this.index(source);\n\n    const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({\n      dragEvent: event,\n      oldIndex,\n      newIndex,\n      oldContainer,\n      newContainer\n    });\n\n    this.trigger(sortableSortedEvent);\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {DragStopEvent} event - Drag stop event\n   */\n  [onDragStop](event) {\n    const sortableStopEvent = new _SortableEvent.SortableStopEvent({\n      dragEvent: event,\n      oldIndex: this.startIndex,\n      newIndex: this.index(event.source),\n      oldContainer: this.startContainer,\n      newContainer: event.source.parentNode\n    });\n\n    this.trigger(sortableStopEvent);\n\n    this.startIndex = null;\n    this.startContainer = null;\n  }\n}\n\nexports.default = Sortable;\nfunction index(element) {\n  return Array.prototype.indexOf.call(element.parentNode.children, element);\n}\n\nfunction move({ source, over, overContainer, children }) {\n  const emptyOverContainer = !children.length;\n  const differentContainer = source.parentNode !== overContainer;\n  const sameContainer = over && !differentContainer;\n\n  if (emptyOverContainer) {\n    return moveInsideEmptyContainer(source, overContainer);\n  } else if (sameContainer) {\n    return moveWithinContainer(source, over);\n  } else if (differentContainer) {\n    return moveOutsideContainer(source, over, overContainer);\n  } else {\n    return null;\n  }\n}\n\nfunction moveInsideEmptyContainer(source, overContainer) {\n  const oldContainer = source.parentNode;\n\n  overContainer.appendChild(source);\n\n  return { oldContainer, newContainer: overContainer };\n}\n\nfunction moveWithinContainer(source, over) {\n  const oldIndex = index(source);\n  const newIndex = index(over);\n\n  if (oldIndex < newIndex) {\n    source.parentNode.insertBefore(source, over.nextElementSibling);\n  } else {\n    source.parentNode.insertBefore(source, over);\n  }\n\n  return { oldContainer: source.parentNode, newContainer: source.parentNode };\n}\n\nfunction moveOutsideContainer(source, over, overContainer) {\n  const oldContainer = source.parentNode;\n\n  if (over) {\n    over.parentNode.insertBefore(source, over);\n  } else {\n    // need to figure out proper position\n    overContainer.appendChild(source);\n  }\n\n  return { oldContainer, newContainer: source.parentNode };\n}\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SortableStopEvent = exports.SortableSortedEvent = exports.SortableSortEvent = exports.SortableStartEvent = exports.SortableEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base sortable event\n * @class SortableEvent\n * @module SortableEvent\n * @extends AbstractEvent\n */\nclass SortableEvent extends _AbstractEvent2.default {\n\n  /**\n   * Original drag event that triggered this sortable event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n}\n\nexports.SortableEvent = SortableEvent; /**\n                                        * Sortable start event\n                                        * @class SortableStartEvent\n                                        * @module SortableStartEvent\n                                        * @extends SortableEvent\n                                        */\n\nSortableEvent.type = 'sortable';\nclass SortableStartEvent extends SortableEvent {\n\n  /**\n   * Start index of source on sortable start\n   * @property startIndex\n   * @type {Number}\n   * @readonly\n   */\n  get startIndex() {\n    return this.data.startIndex;\n  }\n\n  /**\n   * Start container on sortable start\n   * @property startContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get startContainer() {\n    return this.data.startContainer;\n  }\n}\n\nexports.SortableStartEvent = SortableStartEvent; /**\n                                                  * Sortable sort event\n                                                  * @class SortableSortEvent\n                                                  * @module SortableSortEvent\n                                                  * @extends SortableEvent\n                                                  */\n\nSortableStartEvent.type = 'sortable:start';\nSortableStartEvent.cancelable = true;\nclass SortableSortEvent extends SortableEvent {\n\n  /**\n   * Index of current draggable element\n   * @property currentIndex\n   * @type {Number}\n   * @readonly\n   */\n  get currentIndex() {\n    return this.data.currentIndex;\n  }\n\n  /**\n   * Draggable element you are hovering over\n   * @property over\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get over() {\n    return this.data.oldIndex;\n  }\n\n  /**\n   * Draggable container element you are hovering over\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.newIndex;\n  }\n}\n\nexports.SortableSortEvent = SortableSortEvent; /**\n                                                * Sortable sorted event\n                                                * @class SortableSortedEvent\n                                                * @module SortableSortedEvent\n                                                * @extends SortableEvent\n                                                */\n\nSortableSortEvent.type = 'sortable:sort';\nSortableSortEvent.cancelable = true;\nclass SortableSortedEvent extends SortableEvent {\n\n  /**\n   * Index of last sorted event\n   * @property oldIndex\n   * @type {Number}\n   * @readonly\n   */\n  get oldIndex() {\n    return this.data.oldIndex;\n  }\n\n  /**\n   * New index of this sorted event\n   * @property newIndex\n   * @type {Number}\n   * @readonly\n   */\n  get newIndex() {\n    return this.data.newIndex;\n  }\n\n  /**\n   * Old container of draggable element\n   * @property oldContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get oldContainer() {\n    return this.data.oldContainer;\n  }\n\n  /**\n   * New container of draggable element\n   * @property newContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get newContainer() {\n    return this.data.newContainer;\n  }\n}\n\nexports.SortableSortedEvent = SortableSortedEvent; /**\n                                                    * Sortable stop event\n                                                    * @class SortableStopEvent\n                                                    * @module SortableStopEvent\n                                                    * @extends SortableEvent\n                                                    */\n\nSortableSortedEvent.type = 'sortable:sorted';\nclass SortableStopEvent extends SortableEvent {\n\n  /**\n   * Original index on sortable start\n   * @property oldIndex\n   * @type {Number}\n   * @readonly\n   */\n  get oldIndex() {\n    return this.data.oldIndex;\n  }\n\n  /**\n   * New index of draggable element\n   * @property newIndex\n   * @type {Number}\n   * @readonly\n   */\n  get newIndex() {\n    return this.data.newIndex;\n  }\n\n  /**\n   * Original container of draggable element\n   * @property oldContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get oldContainer() {\n    return this.data.oldContainer;\n  }\n\n  /**\n   * New container of draggable element\n   * @property newContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get newContainer() {\n    return this.data.newContainer;\n  }\n}\nexports.SortableStopEvent = SortableStopEvent;\nSortableStopEvent.type = 'sortable:stop';\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SortableEvent = __webpack_require__(9);\n\nObject.keys(_SortableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SortableEvent[key];\n    }\n  });\n});\n\nvar _Sortable = __webpack_require__(26);\n\nvar _Sortable2 = _interopRequireDefault(_Sortable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Sortable2.default;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _Draggable = __webpack_require__(5);\n\nvar _Draggable2 = _interopRequireDefault(_Draggable);\n\nvar _SwappableEvent = __webpack_require__(10);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = Symbol('onDragStart');\nconst onDragOver = Symbol('onDragOver');\nconst onDragStop = Symbol('onDragStop');\n\n/**\n * Returns an announcement message when the Draggable element is swapped with another draggable element\n * @param {SwappableSwappedEvent} swappableEvent\n * @return {String}\n */\nfunction onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';\n  const overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';\n\n  return `Swapped ${sourceText} with ${overText}`;\n}\n\n/**\n * @const {Object} defaultAnnouncements\n * @const {Function} defaultAnnouncements['swappabled:swapped']\n */\nconst defaultAnnouncements = {\n  'swappabled:swapped': onSwappableSwappedDefaultAnnouncement\n};\n\n/**\n * Swappable is built on top of Draggable and allows swapping of draggable elements.\n * Order is irrelevant to Swappable.\n * @class Swappable\n * @module Swappable\n * @extends Draggable\n */\nclass Swappable extends _Draggable2.default {\n  /**\n   * Swappable constructor.\n   * @constructs Swappable\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers\n   * @param {Object} options - Options for Swappable\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, _extends({}, options, {\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\n    }));\n\n    /**\n     * Last draggable element that was dragged over\n     * @property lastOver\n     * @type {HTMLElement}\n     */\n    this.lastOver = null;\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragOver] = this[onDragOver].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n\n    this.on('drag:start', this[onDragStart]).on('drag:over', this[onDragOver]).on('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Destroys Swappable instance.\n   */\n  destroy() {\n    super.destroy();\n\n    this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {DragStartEvent} event - Drag start event\n   */\n  [onDragStart](event) {\n    const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({\n      dragEvent: event\n    });\n\n    this.trigger(swappableStartEvent);\n\n    if (swappableStartEvent.canceled()) {\n      event.cancel();\n    }\n  }\n\n  /**\n   * Drag over handler\n   * @private\n   * @param {DragOverEvent} event - Drag over event\n   */\n  [onDragOver](event) {\n    if (event.over === event.originalSource || event.over === event.source || event.canceled()) {\n      return;\n    }\n\n    const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({\n      dragEvent: event,\n      over: event.over,\n      overContainer: event.overContainer\n    });\n\n    this.trigger(swappableSwapEvent);\n\n    if (swappableSwapEvent.canceled()) {\n      return;\n    }\n\n    // swap originally swapped element back\n    if (this.lastOver && this.lastOver !== event.over) {\n      swap(this.lastOver, event.source);\n    }\n\n    if (this.lastOver === event.over) {\n      this.lastOver = null;\n    } else {\n      this.lastOver = event.over;\n    }\n\n    swap(event.source, event.over);\n\n    const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({\n      dragEvent: event,\n      swappedElement: event.over\n    });\n\n    this.trigger(swappableSwappedEvent);\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {DragStopEvent} event - Drag stop event\n   */\n  [onDragStop](event) {\n    const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({\n      dragEvent: event\n    });\n\n    this.trigger(swappableStopEvent);\n    this.lastOver = null;\n  }\n}\n\nexports.default = Swappable;\nfunction withTempElement(callback) {\n  const tmpElement = document.createElement('div');\n  callback(tmpElement);\n  tmpElement.parentNode.removeChild(tmpElement);\n}\n\nfunction swap(source, over) {\n  const overParent = over.parentNode;\n  const sourceParent = source.parentNode;\n\n  withTempElement(tmpElement => {\n    sourceParent.insertBefore(tmpElement, source);\n    overParent.insertBefore(source, over);\n    sourceParent.insertBefore(over, tmpElement);\n  });\n}\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SwappableStopEvent = exports.SwappableSwappedEvent = exports.SwappableSwapEvent = exports.SwappableStartEvent = exports.SwappableEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base swappable event\n * @class SwappableEvent\n * @module SwappableEvent\n * @extends AbstractEvent\n */\nclass SwappableEvent extends _AbstractEvent2.default {\n\n  /**\n   * Original drag event that triggered this swappable event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n}\n\nexports.SwappableEvent = SwappableEvent; /**\n                                          * Swappable start event\n                                          * @class SwappableStartEvent\n                                          * @module SwappableStartEvent\n                                          * @extends SwappableEvent\n                                          */\n\nSwappableEvent.type = 'swappable';\nclass SwappableStartEvent extends SwappableEvent {}\n\nexports.SwappableStartEvent = SwappableStartEvent; /**\n                                                    * Swappable swap event\n                                                    * @class SwappableSwapEvent\n                                                    * @module SwappableSwapEvent\n                                                    * @extends SwappableEvent\n                                                    */\n\nSwappableStartEvent.type = 'swappable:start';\nSwappableStartEvent.cancelable = true;\nclass SwappableSwapEvent extends SwappableEvent {\n\n  /**\n   * Draggable element you are over\n   * @property over\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get over() {\n    return this.data.over;\n  }\n\n  /**\n   * Draggable container you are over\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.overContainer;\n  }\n}\n\nexports.SwappableSwapEvent = SwappableSwapEvent; /**\n                                                  * Swappable swapped event\n                                                  * @class SwappableSwappedEvent\n                                                  * @module SwappableSwappedEvent\n                                                  * @extends SwappableEvent\n                                                  */\n\nSwappableSwapEvent.type = 'swappable:swap';\nSwappableSwapEvent.cancelable = true;\nclass SwappableSwappedEvent extends SwappableEvent {\n\n  /**\n   * The draggable element that you swapped with\n   * @property swappedElement\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get swappedElement() {\n    return this.data.swappedElement;\n  }\n}\n\nexports.SwappableSwappedEvent = SwappableSwappedEvent; /**\n                                                        * Swappable stop event\n                                                        * @class SwappableStopEvent\n                                                        * @module SwappableStopEvent\n                                                        * @extends SwappableEvent\n                                                        */\n\nSwappableSwappedEvent.type = 'swappable:swapped';\nclass SwappableStopEvent extends SwappableEvent {}\nexports.SwappableStopEvent = SwappableStopEvent;\nSwappableStopEvent.type = 'swappable:stop';\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SwappableEvent = __webpack_require__(10);\n\nObject.keys(_SwappableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _SwappableEvent[key];\n    }\n  });\n});\n\nvar _Swappable = __webpack_require__(29);\n\nvar _Swappable2 = _interopRequireDefault(_Swappable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Swappable2.default;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = __webpack_require__(2);\n\nvar _Draggable = __webpack_require__(5);\n\nvar _Draggable2 = _interopRequireDefault(_Draggable);\n\nvar _DroppableEvent = __webpack_require__(11);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = Symbol('onDragStart');\nconst onDragMove = Symbol('onDragMove');\nconst onDragStop = Symbol('onDragStop');\nconst dropInDropzone = Symbol('dropInDropZone');\nconst returnToOriginalDropzone = Symbol('returnToOriginalDropzone');\nconst closestDropzone = Symbol('closestDropzone');\nconst getDropzones = Symbol('getDropzones');\n\n/**\n * Returns an announcement message when the Draggable element is dropped into a dropzone element\n * @param {DroppableDroppedEvent} droppableEvent\n * @return {String}\n */\nfunction onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\n\n  return `Dropped ${sourceText} into ${dropzoneText}`;\n}\n\n/**\n * Returns an announcement message when the Draggable element has returned to its original dropzone element\n * @param {DroppableReturnedEvent} droppableEvent\n * @return {String}\n */\nfunction onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {\n  const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';\n  const dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';\n\n  return `Returned ${sourceText} from ${dropzoneText}`;\n}\n\n/**\n * @const {Object} defaultAnnouncements\n * @const {Function} defaultAnnouncements['droppable:dropped']\n * @const {Function} defaultAnnouncements['droppable:returned']\n */\nconst defaultAnnouncements = {\n  'droppable:dropped': onDroppableDroppedDefaultAnnouncement,\n  'droppable:returned': onDroppableReturnedDefaultAnnouncement\n};\n\nconst defaultClasses = {\n  'droppable:active': 'draggable-dropzone--active',\n  'droppable:occupied': 'draggable-dropzone--occupied'\n};\n\nconst defaultOptions = {\n  dropzone: '.draggable-droppable'\n};\n\n/**\n * Droppable is built on top of Draggable and allows dropping draggable elements\n * into dropzone element\n * @class Droppable\n * @module Droppable\n * @extends Draggable\n */\nclass Droppable extends _Draggable2.default {\n  /**\n   * Droppable constructor.\n   * @constructs Droppable\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers\n   * @param {Object} options - Options for Droppable\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, _extends({}, defaultOptions, options, {\n      classes: _extends({}, defaultClasses, options.classes || {}),\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\n    }));\n\n    /**\n     * All dropzone elements on drag start\n     * @property dropzones\n     * @type {HTMLElement[]}\n     */\n    this.dropzones = null;\n\n    /**\n     * Last dropzone element that the source was dropped into\n     * @property lastDropzone\n     * @type {HTMLElement}\n     */\n    this.lastDropzone = null;\n\n    /**\n     * Initial dropzone element that the source was drag from\n     * @property initialDropzone\n     * @type {HTMLElement}\n     */\n    this.initialDropzone = null;\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragMove] = this[onDragMove].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n\n    this.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Destroys Droppable instance.\n   */\n  destroy() {\n    super.destroy();\n\n    this.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {DragStartEvent} event - Drag start event\n   */\n  [onDragStart](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    this.dropzones = [...this[getDropzones]()];\n    const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);\n\n    if (!dropzone) {\n      event.cancel();\n      return;\n    }\n\n    const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({\n      dragEvent: event,\n      dropzone\n    });\n\n    this.trigger(droppableStartEvent);\n\n    if (droppableStartEvent.canceled()) {\n      event.cancel();\n      return;\n    }\n\n    this.initialDropzone = dropzone;\n\n    for (const dropzoneElement of this.dropzones) {\n      if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {\n        continue;\n      }\n\n      dropzoneElement.classList.add(this.getClassNameFor('droppable:active'));\n    }\n  }\n\n  /**\n   * Drag move handler\n   * @private\n   * @param {DragMoveEvent} event - Drag move event\n   */\n  [onDragMove](event) {\n    if (event.canceled()) {\n      return;\n    }\n\n    const dropzone = this[closestDropzone](event.sensorEvent.target);\n    const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));\n\n    if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {\n      this.lastDropzone = dropzone;\n    } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {\n      this[returnToOriginalDropzone](event);\n      this.lastDropzone = null;\n    }\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {DragStopEvent} event - Drag stop event\n   */\n  [onDragStop](event) {\n    const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({\n      dragEvent: event,\n      dropzone: this.lastDropzone || this.initialDropzone\n    });\n\n    this.trigger(droppableStopEvent);\n\n    const occupiedClass = this.getClassNameFor('droppable:occupied');\n\n    for (const dropzone of this.dropzones) {\n      dropzone.classList.remove(this.getClassNameFor('droppable:active'));\n    }\n\n    if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {\n      this.initialDropzone.classList.remove(occupiedClass);\n    }\n\n    this.dropzones = null;\n    this.lastDropzone = null;\n    this.initialDropzone = null;\n  }\n\n  /**\n   * Drops a draggable element into a dropzone element\n   * @private\n   * @param {DragMoveEvent} event - Drag move event\n   * @param {HTMLElement} dropzone - Dropzone element to drop draggable into\n   */\n  [dropInDropzone](event, dropzone) {\n    const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({\n      dragEvent: event,\n      dropzone\n    });\n\n    this.trigger(droppableDroppedEvent);\n\n    if (droppableDroppedEvent.canceled()) {\n      return false;\n    }\n\n    const occupiedClass = this.getClassNameFor('droppable:occupied');\n\n    if (this.lastDropzone) {\n      this.lastDropzone.classList.remove(occupiedClass);\n    }\n\n    dropzone.appendChild(event.source);\n    dropzone.classList.add(occupiedClass);\n\n    return true;\n  }\n\n  /**\n   * Moves the previously dropped element back into its original dropzone\n   * @private\n   * @param {DragMoveEvent} event - Drag move event\n   */\n  [returnToOriginalDropzone](event) {\n    const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({\n      dragEvent: event,\n      dropzone: this.lastDropzone\n    });\n\n    this.trigger(droppableReturnedEvent);\n\n    if (droppableReturnedEvent.canceled()) {\n      return;\n    }\n\n    this.initialDropzone.appendChild(event.source);\n    this.lastDropzone.classList.remove(this.getClassNameFor('droppable:occupied'));\n  }\n\n  /**\n   * Returns closest dropzone element for even target\n   * @private\n   * @param {HTMLElement} target - Event target\n   * @return {HTMLElement|null}\n   */\n  [closestDropzone](target) {\n    if (!this.dropzones) {\n      return null;\n    }\n\n    return (0, _utils.closest)(target, this.dropzones);\n  }\n\n  /**\n   * Returns all current dropzone elements for this draggable instance\n   * @private\n   * @return {NodeList|HTMLElement[]|Array}\n   */\n  [getDropzones]() {\n    const dropzone = this.options.dropzone;\n\n    if (typeof dropzone === 'string') {\n      return document.querySelectorAll(dropzone);\n    } else if (dropzone instanceof NodeList || dropzone instanceof Array) {\n      return dropzone;\n    } else if (typeof dropzone === 'function') {\n      return dropzone();\n    } else {\n      return [];\n    }\n  }\n}\nexports.default = Droppable;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DroppableStopEvent = exports.DroppableReturnedEvent = exports.DroppableDroppedEvent = exports.DroppableStartEvent = exports.DroppableEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base droppable event\n * @class DroppableEvent\n * @module DroppableEvent\n * @extends AbstractEvent\n */\nclass DroppableEvent extends _AbstractEvent2.default {\n\n  /**\n   * Original drag event that triggered this droppable event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n}\n\nexports.DroppableEvent = DroppableEvent; /**\n                                          * Droppable start event\n                                          * @class DroppableStartEvent\n                                          * @module DroppableStartEvent\n                                          * @extends DroppableEvent\n                                          */\n\nDroppableEvent.type = 'droppable';\nclass DroppableStartEvent extends DroppableEvent {\n\n  /**\n   * The initial dropzone element of the currently dragging draggable element\n   * @property dropzone\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get dropzone() {\n    return this.data.dropzone;\n  }\n}\n\nexports.DroppableStartEvent = DroppableStartEvent; /**\n                                                    * Droppable dropped event\n                                                    * @class DroppableDroppedEvent\n                                                    * @module DroppableDroppedEvent\n                                                    * @extends DroppableEvent\n                                                    */\n\nDroppableStartEvent.type = 'droppable:start';\nDroppableStartEvent.cancelable = true;\nclass DroppableDroppedEvent extends DroppableEvent {\n\n  /**\n   * The dropzone element you dropped the draggable element into\n   * @property dropzone\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get dropzone() {\n    return this.data.dropzone;\n  }\n}\n\nexports.DroppableDroppedEvent = DroppableDroppedEvent; /**\n                                                        * Droppable returned event\n                                                        * @class DroppableReturnedEvent\n                                                        * @module DroppableReturnedEvent\n                                                        * @extends DroppableEvent\n                                                        */\n\nDroppableDroppedEvent.type = 'droppable:dropped';\nDroppableDroppedEvent.cancelable = true;\nclass DroppableReturnedEvent extends DroppableEvent {\n\n  /**\n   * The dropzone element you dragged away from\n   * @property dropzone\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get dropzone() {\n    return this.data.dropzone;\n  }\n}\n\nexports.DroppableReturnedEvent = DroppableReturnedEvent; /**\n                                                          * Droppable stop event\n                                                          * @class DroppableStopEvent\n                                                          * @module DroppableStopEvent\n                                                          * @extends DroppableEvent\n                                                          */\n\nDroppableReturnedEvent.type = 'droppable:returned';\nDroppableReturnedEvent.cancelable = true;\nclass DroppableStopEvent extends DroppableEvent {\n\n  /**\n   * The final dropzone element of the draggable element\n   * @property dropzone\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get dropzone() {\n    return this.data.dropzone;\n  }\n}\nexports.DroppableStopEvent = DroppableStopEvent;\nDroppableStopEvent.type = 'droppable:stop';\nDroppableStopEvent.cancelable = true;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DroppableEvent = __webpack_require__(11);\n\nObject.keys(_DroppableEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _DroppableEvent[key];\n    }\n  });\n});\n\nvar _Droppable = __webpack_require__(32);\n\nvar _Droppable2 = _interopRequireDefault(_Droppable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Droppable2.default;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods\n * @class Emitter\n * @module Emitter\n */\nclass Emitter {\n  constructor() {\n    this.callbacks = {};\n  }\n\n  /**\n   * Registers callbacks by event name\n   * @param {String} type\n   * @param {...Function} callbacks\n   */\n  on(type, ...callbacks) {\n    if (!this.callbacks[type]) {\n      this.callbacks[type] = [];\n    }\n\n    this.callbacks[type].push(...callbacks);\n\n    return this;\n  }\n\n  /**\n   * Unregisters callbacks by event name\n   * @param {String} type\n   * @param {Function} callback\n   */\n  off(type, callback) {\n    if (!this.callbacks[type]) {\n      return null;\n    }\n\n    const copy = this.callbacks[type].slice(0);\n\n    for (let i = 0; i < copy.length; i++) {\n      if (callback === copy[i]) {\n        this.callbacks[type].splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Triggers event callbacks by event object\n   * @param {AbstractEvent} event\n   */\n  trigger(event) {\n    if (!this.callbacks[event.type]) {\n      return null;\n    }\n\n    const callbacks = [...this.callbacks[event.type]];\n    const caughtErrors = [];\n\n    for (let i = callbacks.length - 1; i >= 0; i--) {\n      const callback = callbacks[i];\n\n      try {\n        callback(event);\n      } catch (error) {\n        caughtErrors.push(error);\n      }\n    }\n\n    if (caughtErrors.length) {\n      /* eslint-disable no-console */\n      console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);\n      /* eslint-disable no-console */\n    }\n\n    return this;\n  }\n}\nexports.default = Emitter;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Emitter = __webpack_require__(35);\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Emitter2.default;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _utils = __webpack_require__(2);\n\nvar _Plugins = __webpack_require__(12);\n\nvar _Emitter = __webpack_require__(36);\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nvar _Sensors = __webpack_require__(6);\n\nvar _DraggableEvent = __webpack_require__(13);\n\nvar _DragEvent = __webpack_require__(14);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = Symbol('onDragStart');\nconst onDragMove = Symbol('onDragMove');\nconst onDragStop = Symbol('onDragStop');\nconst onDragPressure = Symbol('onDragPressure');\n\n/**\n * @const {Object} defaultAnnouncements\n * @const {Function} defaultAnnouncements['drag:start']\n * @const {Function} defaultAnnouncements['drag:stop']\n */\nconst defaultAnnouncements = {\n  'drag:start': event => `Picked up ${event.source.textContent.trim() || event.source.id || 'draggable element'}`,\n  'drag:stop': event => `Released ${event.source.textContent.trim() || event.source.id || 'draggable element'}`\n};\n\nconst defaultClasses = {\n  'container:dragging': 'draggable-container--is-dragging',\n  'source:dragging': 'draggable-source--is-dragging',\n  'source:placed': 'draggable-source--placed',\n  'container:placed': 'draggable-container--placed',\n  'body:dragging': 'draggable--is-dragging',\n  'draggable:over': 'draggable--over',\n  'container:over': 'draggable-container--over',\n  'source:original': 'draggable--original',\n  mirror: 'draggable-mirror'\n};\n\nconst defaultOptions = exports.defaultOptions = {\n  draggable: '.draggable-source',\n  handle: null,\n  delay: 100,\n  placedTimeout: 800,\n  plugins: [],\n  sensors: []\n};\n\n/**\n * This is the core draggable library that does the heavy lifting\n * @class Draggable\n * @module Draggable\n */\nclass Draggable {\n\n  /**\n   * Draggable constructor.\n   * @constructs Draggable\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers\n   * @param {Object} options - Options for draggable\n   */\n  constructor(containers = [document.body], options = {}) {\n    /**\n     * Draggable containers\n     * @property containers\n     * @type {HTMLElement[]}\n     */\n    if (containers instanceof NodeList || containers instanceof Array) {\n      this.containers = [...containers];\n    } else if (containers instanceof HTMLElement) {\n      this.containers = [containers];\n    } else {\n      throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');\n    }\n\n    this.options = _extends({}, defaultOptions, options, {\n      classes: _extends({}, defaultClasses, options.classes || {}),\n      announcements: _extends({}, defaultAnnouncements, options.announcements || {})\n    });\n\n    /**\n     * Draggables event emitter\n     * @property emitter\n     * @type {Emitter}\n     */\n    this.emitter = new _Emitter2.default();\n\n    /**\n     * Current drag state\n     * @property dragging\n     * @type {Boolean}\n     */\n    this.dragging = false;\n\n    /**\n     * Active plugins\n     * @property plugins\n     * @type {Plugin[]}\n     */\n    this.plugins = [];\n\n    /**\n     * Active sensors\n     * @property sensors\n     * @type {Sensor[]}\n     */\n    this.sensors = [];\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragMove] = this[onDragMove].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n    this[onDragPressure] = this[onDragPressure].bind(this);\n\n    document.addEventListener('drag:start', this[onDragStart], true);\n    document.addEventListener('drag:move', this[onDragMove], true);\n    document.addEventListener('drag:stop', this[onDragStop], true);\n    document.addEventListener('drag:pressure', this[onDragPressure], true);\n\n    const defaultPlugins = Object.values(Draggable.Plugins).map(Plugin => Plugin);\n    const defaultSensors = [_Sensors.MouseSensor, _Sensors.TouchSensor];\n\n    this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);\n    this.addSensor(...[...defaultSensors, ...this.options.sensors]);\n\n    const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({\n      draggable: this\n    });\n\n    this.on('mirror:created', ({ mirror }) => this.mirror = mirror);\n    this.on('mirror:destroy', () => this.mirror = null);\n\n    this.trigger(draggableInitializedEvent);\n  }\n\n  /**\n   * Destroys Draggable instance. This removes all internal event listeners and\n   * deactivates sensors and plugins\n   */\n\n  /**\n   * Default plugins draggable uses\n   * @static\n   * @property {Object} Plugins\n   * @property {Announcement} Plugins.Announcement\n   * @property {Focusable} Plugins.Focusable\n   * @property {Mirror} Plugins.Mirror\n   * @property {Scrollable} Plugins.Scrollable\n   * @type {Object}\n   */\n  destroy() {\n    document.removeEventListener('drag:start', this[onDragStart], true);\n    document.removeEventListener('drag:move', this[onDragMove], true);\n    document.removeEventListener('drag:stop', this[onDragStop], true);\n    document.removeEventListener('drag:pressure', this[onDragPressure], true);\n\n    const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({\n      draggable: this\n    });\n\n    this.trigger(draggableDestroyEvent);\n\n    this.removePlugin(...this.plugins.map(plugin => plugin.constructor));\n    this.removeSensor(...this.sensors.map(sensor => sensor.constructor));\n  }\n\n  /**\n   * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin\n   * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable\n   * @return {Draggable}\n   * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)\n   */\n  addPlugin(...plugins) {\n    const activePlugins = plugins.map(Plugin => new Plugin(this));\n\n    activePlugins.forEach(plugin => plugin.attach());\n    this.plugins = [...this.plugins, ...activePlugins];\n\n    return this;\n  }\n\n  /**\n   * Removes plugins that are already attached to this draggable instance. This will end up calling\n   * the detach method of the plugin\n   * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable\n   * @return {Draggable}\n   * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)\n   */\n  removePlugin(...plugins) {\n    const removedPlugins = this.plugins.filter(plugin => plugins.includes(plugin.constructor));\n\n    removedPlugins.forEach(plugin => plugin.detach());\n    this.plugins = this.plugins.filter(plugin => !plugins.includes(plugin.constructor));\n\n    return this;\n  }\n\n  /**\n   * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\n   * @return {Draggable}\n   * @example draggable.addSensor(ForceTouchSensor, CustomSensor)\n   */\n  addSensor(...sensors) {\n    const activeSensors = sensors.map(Sensor => new Sensor(this.containers, this.options));\n\n    activeSensors.forEach(sensor => sensor.attach());\n    this.sensors = [...this.sensors, ...activeSensors];\n\n    return this;\n  }\n\n  /**\n   * Removes sensors that are already attached to this draggable instance. This will end up calling\n   * the detach method of the sensor\n   * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable\n   * @return {Draggable}\n   * @example draggable.removeSensor(TouchSensor, DragSensor)\n   */\n  removeSensor(...sensors) {\n    const removedSensors = this.sensors.filter(sensor => sensors.includes(sensor.constructor));\n\n    removedSensors.forEach(sensor => sensor.detach());\n    this.sensors = this.sensors.filter(sensor => !sensors.includes(sensor.constructor));\n\n    return this;\n  }\n\n  /**\n   * Adds container to this draggable instance\n   * @param {...HTMLElement} containers - Containers you want to add to draggable\n   * @return {Draggable}\n   * @example draggable.addContainer(document.body)\n   */\n  addContainer(...containers) {\n    this.containers = [...this.containers, ...containers];\n    this.sensors.forEach(sensor => sensor.addContainer(...containers));\n    return this;\n  }\n\n  /**\n   * Removes container from this draggable instance\n   * @param {...HTMLElement} containers - Containers you want to remove from draggable\n   * @return {Draggable}\n   * @example draggable.removeContainer(document.body)\n   */\n  removeContainer(...containers) {\n    this.containers = this.containers.filter(container => !containers.includes(container));\n    this.sensors.forEach(sensor => sensor.removeContainer(...containers));\n    return this;\n  }\n\n  /**\n   * Adds listener for draggable events\n   * @param {String} type - Event name\n   * @param {...Function} callbacks - Event callbacks\n   * @return {Draggable}\n   * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());\n   */\n  on(type, ...callbacks) {\n    this.emitter.on(type, ...callbacks);\n    return this;\n  }\n\n  /**\n   * Removes listener from draggable\n   * @param {String} type - Event name\n   * @param {Function} callback - Event callback\n   * @return {Draggable}\n   * @example draggable.off('drag:start', handlerFunction);\n   */\n  off(type, callback) {\n    this.emitter.off(type, callback);\n    return this;\n  }\n\n  /**\n   * Triggers draggable event\n   * @param {AbstractEvent} event - Event instance\n   * @return {Draggable}\n   * @example draggable.trigger(event);\n   */\n  trigger(event) {\n    this.emitter.trigger(event);\n    return this;\n  }\n\n  /**\n   * Returns class name for class identifier\n   * @param {String} name - Name of class identifier\n   * @return {String|null}\n   */\n  getClassNameFor(name) {\n    return this.options.classes[name];\n  }\n\n  /**\n   * Returns true if this draggable instance is currently dragging\n   * @return {Boolean}\n   */\n  isDragging() {\n    return Boolean(this.dragging);\n  }\n\n  /**\n   * Returns all draggable elements\n   * @return {HTMLElement[]}\n   */\n  getDraggableElements() {\n    return this.containers.reduce((current, container) => {\n      return [...current, ...this.getDraggableElementsForContainer(container)];\n    }, []);\n  }\n\n  /**\n   * Returns draggable elements for a given container, excluding the mirror and\n   * original source element if present\n   * @param {HTMLElement} container\n   * @return {HTMLElement[]}\n   */\n  getDraggableElementsForContainer(container) {\n    const allDraggableElements = container.querySelectorAll(this.options.draggable);\n\n    return [...allDraggableElements].filter(childElement => {\n      return childElement !== this.originalSource && childElement !== this.mirror;\n    });\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {Event} event - DOM Drag event\n   */\n  [onDragStart](event) {\n    const sensorEvent = getSensorEvent(event);\n    const { target, container } = sensorEvent;\n\n    if (!this.containers.includes(container)) {\n      return;\n    }\n\n    if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {\n      sensorEvent.cancel();\n      return;\n    }\n\n    // Find draggable source element\n    this.originalSource = (0, _utils.closest)(target, this.options.draggable);\n    this.sourceContainer = container;\n\n    if (!this.originalSource) {\n      sensorEvent.cancel();\n      return;\n    }\n\n    if (this.lastPlacedSource && this.lastPlacedContainer) {\n      clearTimeout(this.placedTimeoutID);\n      this.lastPlacedSource.classList.remove(this.getClassNameFor('source:placed'));\n      this.lastPlacedContainer.classList.remove(this.getClassNameFor('container:placed'));\n    }\n\n    this.source = this.originalSource.cloneNode(true);\n    this.originalSource.parentNode.insertBefore(this.source, this.originalSource);\n    this.originalSource.style.display = 'none';\n\n    const dragEvent = new _DragEvent.DragStartEvent({\n      source: this.source,\n      originalSource: this.originalSource,\n      sourceContainer: container,\n      sensorEvent\n    });\n\n    this.trigger(dragEvent);\n\n    this.dragging = !dragEvent.canceled();\n\n    if (dragEvent.canceled()) {\n      this.source.parentNode.removeChild(this.source);\n      this.originalSource.style.display = null;\n      return;\n    }\n\n    this.originalSource.classList.add(this.getClassNameFor('source:original'));\n    this.source.classList.add(this.getClassNameFor('source:dragging'));\n    this.sourceContainer.classList.add(this.getClassNameFor('container:dragging'));\n    document.body.classList.add(this.getClassNameFor('body:dragging'));\n    applyUserSelect(document.body, 'none');\n\n    requestAnimationFrame(() => {\n      const oldSensorEvent = getSensorEvent(event);\n      const newSensorEvent = oldSensorEvent.clone({ target: this.source });\n\n      this[onDragMove](_extends({}, event, {\n        detail: newSensorEvent\n      }));\n    });\n  }\n\n  /**\n   * Drag move handler\n   * @private\n   * @param {Event} event - DOM Drag event\n   */\n  [onDragMove](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const sensorEvent = getSensorEvent(event);\n    const { container } = sensorEvent;\n    let target = sensorEvent.target;\n\n    const dragMoveEvent = new _DragEvent.DragMoveEvent({\n      source: this.source,\n      originalSource: this.originalSource,\n      sourceContainer: container,\n      sensorEvent\n    });\n\n    this.trigger(dragMoveEvent);\n\n    if (dragMoveEvent.canceled()) {\n      sensorEvent.cancel();\n    }\n\n    target = (0, _utils.closest)(target, this.options.draggable);\n    const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);\n    const overContainer = sensorEvent.overContainer || withinCorrectContainer;\n    const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;\n    const isLeavingDraggable = this.currentOver && target !== this.currentOver;\n    const isOverContainer = overContainer && this.currentOverContainer !== overContainer;\n    const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;\n\n    if (isLeavingDraggable) {\n      const dragOutEvent = new _DragEvent.DragOutEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent,\n        over: this.currentOver\n      });\n\n      this.currentOver.classList.remove(this.getClassNameFor('draggable:over'));\n      this.currentOver = null;\n\n      this.trigger(dragOutEvent);\n    }\n\n    if (isLeavingContainer) {\n      const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent,\n        overContainer: this.currentOverContainer\n      });\n\n      this.currentOverContainer.classList.remove(this.getClassNameFor('container:over'));\n      this.currentOverContainer = null;\n\n      this.trigger(dragOutContainerEvent);\n    }\n\n    if (isOverContainer) {\n      overContainer.classList.add(this.getClassNameFor('container:over'));\n\n      const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent,\n        overContainer\n      });\n\n      this.currentOverContainer = overContainer;\n\n      this.trigger(dragOverContainerEvent);\n    }\n\n    if (isOverDraggable) {\n      target.classList.add(this.getClassNameFor('draggable:over'));\n\n      const dragOverEvent = new _DragEvent.DragOverEvent({\n        source: this.source,\n        originalSource: this.originalSource,\n        sourceContainer: container,\n        sensorEvent,\n        overContainer,\n        over: target\n      });\n\n      this.currentOver = target;\n\n      this.trigger(dragOverEvent);\n    }\n  }\n\n  /**\n   * Drag stop handler\n   * @private\n   * @param {Event} event - DOM Drag event\n   */\n  [onDragStop](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    this.dragging = false;\n\n    const dragStopEvent = new _DragEvent.DragStopEvent({\n      source: this.source,\n      originalSource: this.originalSource,\n      sensorEvent: event.sensorEvent,\n      sourceContainer: this.sourceContainer\n    });\n\n    this.trigger(dragStopEvent);\n\n    this.source.parentNode.insertBefore(this.originalSource, this.source);\n    this.source.parentNode.removeChild(this.source);\n    this.originalSource.style.display = '';\n\n    this.source.classList.remove(this.getClassNameFor('source:dragging'));\n    this.originalSource.classList.remove(this.getClassNameFor('source:original'));\n    this.originalSource.classList.add(this.getClassNameFor('source:placed'));\n    this.sourceContainer.classList.add(this.getClassNameFor('container:placed'));\n    this.sourceContainer.classList.remove(this.getClassNameFor('container:dragging'));\n    document.body.classList.remove(this.getClassNameFor('body:dragging'));\n    applyUserSelect(document.body, '');\n\n    if (this.currentOver) {\n      this.currentOver.classList.remove(this.getClassNameFor('draggable:over'));\n    }\n\n    if (this.currentOverContainer) {\n      this.currentOverContainer.classList.remove(this.getClassNameFor('container:over'));\n    }\n\n    this.lastPlacedSource = this.originalSource;\n    this.lastPlacedContainer = this.sourceContainer;\n\n    this.placedTimeoutID = setTimeout(() => {\n      if (this.lastPlacedSource) {\n        this.lastPlacedSource.classList.remove(this.getClassNameFor('source:placed'));\n      }\n\n      if (this.lastPlacedContainer) {\n        this.lastPlacedContainer.classList.remove(this.getClassNameFor('container:placed'));\n      }\n\n      this.lastPlacedSource = null;\n      this.lastPlacedContainer = null;\n    }, this.options.placedTimeout);\n\n    this.source = null;\n    this.originalSource = null;\n    this.currentOverContainer = null;\n    this.currentOver = null;\n    this.sourceContainer = null;\n  }\n\n  /**\n   * Drag pressure handler\n   * @private\n   * @param {Event} event - DOM Drag event\n   */\n  [onDragPressure](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const sensorEvent = getSensorEvent(event);\n    const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);\n\n    const dragPressureEvent = new _DragEvent.DragPressureEvent({\n      sensorEvent,\n      source,\n      pressure: sensorEvent.pressure\n    });\n\n    this.trigger(dragPressureEvent);\n  }\n}\n\nexports.default = Draggable;\nDraggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };\nfunction getSensorEvent(event) {\n  return event.detail;\n}\n\nfunction applyUserSelect(element, value) {\n  element.style.webkitUserSelect = value;\n  element.style.mozUserSelect = value;\n  element.style.msUserSelect = value;\n  element.style.oUserSelect = value;\n  element.style.userSelect = value;\n}\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Sensor = __webpack_require__(4);\n\nvar _Sensor2 = _interopRequireDefault(_Sensor);\n\nvar _SensorEvent = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onMouseForceWillBegin = Symbol('onMouseForceWillBegin');\nconst onMouseForceDown = Symbol('onMouseForceDown');\nconst onMouseDown = Symbol('onMouseDown');\nconst onMouseForceChange = Symbol('onMouseForceChange');\nconst onMouseMove = Symbol('onMouseMove');\nconst onMouseUp = Symbol('onMouseUp');\nconst onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');\n\n/**\n * This sensor picks up native force touch events and dictates drag operations\n * @class ForceTouchSensor\n * @module ForceTouchSensor\n * @extends Sensor\n */\nclass ForceTouchSensor extends _Sensor2.default {\n  /**\n   * ForceTouchSensor constructor.\n   * @constructs ForceTouchSensor\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\n   * @param {Object} options - Options\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, options);\n\n    /**\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\n     * @property mightDrag\n     * @type {Boolean}\n     */\n    this.mightDrag = false;\n\n    this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);\n    this[onMouseForceDown] = this[onMouseForceDown].bind(this);\n    this[onMouseDown] = this[onMouseDown].bind(this);\n    this[onMouseForceChange] = this[onMouseForceChange].bind(this);\n    this[onMouseMove] = this[onMouseMove].bind(this);\n    this[onMouseUp] = this[onMouseUp].bind(this);\n  }\n\n  /**\n   * Attaches sensors event listeners to the DOM\n   */\n  attach() {\n    for (const container of this.containers) {\n      container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\n      container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\n      container.addEventListener('mousedown', this[onMouseDown], true);\n      container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\n    }\n\n    document.addEventListener('mousemove', this[onMouseMove]);\n    document.addEventListener('mouseup', this[onMouseUp]);\n  }\n\n  /**\n   * Detaches sensors event listeners to the DOM\n   */\n  detach() {\n    for (const container of this.containers) {\n      container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);\n      container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);\n      container.removeEventListener('mousedown', this[onMouseDown], true);\n      container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);\n    }\n\n    document.removeEventListener('mousemove', this[onMouseMove]);\n    document.removeEventListener('mouseup', this[onMouseUp]);\n  }\n\n  /**\n   * Mouse force will begin handler\n   * @private\n   * @param {Event} event - Mouse force will begin event\n   */\n  [onMouseForceWillBegin](event) {\n    event.preventDefault();\n    this.mightDrag = true;\n  }\n\n  /**\n   * Mouse force down handler\n   * @private\n   * @param {Event} event - Mouse force down event\n   */\n  [onMouseForceDown](event) {\n    if (this.dragging) {\n      return;\n    }\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n    const container = event.currentTarget;\n\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container,\n      originalEvent: event\n    });\n\n    this.trigger(container, dragStartEvent);\n\n    this.currentContainer = container;\n    this.dragging = !dragStartEvent.canceled();\n    this.mightDrag = false;\n  }\n\n  /**\n   * Mouse up handler\n   * @private\n   * @param {Event} event - Mouse up event\n   */\n  [onMouseUp](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target: null,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragStopEvent);\n\n    this.currentContainer = null;\n    this.dragging = false;\n    this.mightDrag = false;\n  }\n\n  /**\n   * Mouse down handler\n   * @private\n   * @param {Event} event - Mouse down event\n   */\n  [onMouseDown](event) {\n    if (!this.mightDrag) {\n      return;\n    }\n\n    // Need workaround for real click\n    // Cancel potential drag events\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n\n  /**\n   * Mouse move handler\n   * @private\n   * @param {Event} event - Mouse force will begin event\n   */\n  [onMouseMove](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragMoveEvent);\n  }\n\n  /**\n   * Mouse force change handler\n   * @private\n   * @param {Event} event - Mouse force change event\n   */\n  [onMouseForceChange](event) {\n    if (this.dragging) {\n      return;\n    }\n\n    const target = event.target;\n    const container = event.currentTarget;\n\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\n      pressure: event.webkitForce,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container,\n      originalEvent: event\n    });\n\n    this.trigger(container, dragPressureEvent);\n  }\n\n  /**\n   * Mouse force global change handler\n   * @private\n   * @param {Event} event - Mouse force global change event\n   */\n  [onMouseForceGlobalChange](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const target = event.target;\n\n    const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({\n      pressure: event.webkitForce,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragPressureEvent);\n  }\n}\nexports.default = ForceTouchSensor;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ForceTouchSensor = __webpack_require__(38);\n\nvar _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _ForceTouchSensor2.default;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = __webpack_require__(2);\n\nvar _Sensor = __webpack_require__(4);\n\nvar _Sensor2 = _interopRequireDefault(_Sensor);\n\nvar _SensorEvent = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onMouseDown = Symbol('onMouseDown');\nconst onMouseUp = Symbol('onMouseUp');\nconst onDragStart = Symbol('onDragStart');\nconst onDragOver = Symbol('onDragOver');\nconst onDragEnd = Symbol('onDragEnd');\nconst onDrop = Symbol('onDrop');\nconst reset = Symbol('reset');\n\n/**\n * This sensor picks up native browser drag events and dictates drag operations\n * @class DragSensor\n * @module DragSensor\n * @extends Sensor\n */\nclass DragSensor extends _Sensor2.default {\n  /**\n   * DragSensor constructor.\n   * @constructs DragSensor\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\n   * @param {Object} options - Options\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, options);\n\n    /**\n     * Mouse down timer which will end up setting the draggable attribute, unless canceled\n     * @property mouseDownTimeout\n     * @type {Number}\n     */\n    this.mouseDownTimeout = null;\n\n    /**\n     * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed\n     * @property draggableElement\n     * @type {HTMLElement}\n     */\n    this.draggableElement = null;\n\n    /**\n     * Native draggable element could be links or images, their draggable state will be disabled during drag operation\n     * @property nativeDraggableElement\n     * @type {HTMLElement}\n     */\n    this.nativeDraggableElement = null;\n\n    this[onMouseDown] = this[onMouseDown].bind(this);\n    this[onMouseUp] = this[onMouseUp].bind(this);\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragOver] = this[onDragOver].bind(this);\n    this[onDragEnd] = this[onDragEnd].bind(this);\n    this[onDrop] = this[onDrop].bind(this);\n  }\n\n  /**\n   * Attaches sensors event listeners to the DOM\n   */\n  attach() {\n    document.addEventListener('mousedown', this[onMouseDown], true);\n  }\n\n  /**\n   * Detaches sensors event listeners to the DOM\n   */\n  detach() {\n    document.removeEventListener('mousedown', this[onMouseDown], true);\n  }\n\n  /**\n   * Drag start handler\n   * @private\n   * @param {Event} event - Drag start event\n   */\n  [onDragStart](event) {\n    // Need for firefox. \"text\" key is needed for IE\n    event.dataTransfer.setData('text', '');\n    event.dataTransfer.effectAllowed = this.options.type;\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n    this.currentContainer = (0, _utils.closest)(event.target, this.containers);\n\n    if (!this.currentContainer) {\n      return;\n    }\n\n    const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    // Workaround\n    setTimeout(() => {\n      this.trigger(this.currentContainer, dragStartEvent);\n\n      if (dragStartEvent.canceled()) {\n        this.dragging = false;\n      } else {\n        this.dragging = true;\n      }\n    }, 0);\n  }\n\n  /**\n   * Drag over handler\n   * @private\n   * @param {Event} event - Drag over event\n   */\n  [onDragOver](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n    const container = this.currentContainer;\n\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container,\n      originalEvent: event\n    });\n\n    this.trigger(container, dragMoveEvent);\n\n    if (!dragMoveEvent.canceled()) {\n      event.preventDefault();\n      event.dataTransfer.dropEffect = this.options.type;\n    }\n  }\n\n  /**\n   * Drag end handler\n   * @private\n   * @param {Event} event - Drag end event\n   */\n  [onDragEnd](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    document.removeEventListener('mouseup', this[onMouseUp], true);\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n    const container = this.currentContainer;\n\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container,\n      originalEvent: event\n    });\n\n    this.trigger(container, dragStopEvent);\n\n    this.dragging = false;\n\n    this[reset]();\n  }\n\n  /**\n   * Drop handler\n   * @private\n   * @param {Event} event - Drop event\n   */\n  [onDrop](event) {\n    // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n  }\n\n  /**\n   * Mouse down handler\n   * @private\n   * @param {Event} event - Mouse down event\n   */\n  [onMouseDown](event) {\n    // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071\n    if (event.target && (event.target.form || event.target.contenteditable)) {\n      return;\n    }\n\n    const nativeDraggableElement = (0, _utils.closest)(event.target, element => element.draggable);\n\n    if (nativeDraggableElement) {\n      nativeDraggableElement.draggable = false;\n      this.nativeDraggableElement = nativeDraggableElement;\n    }\n\n    document.addEventListener('mouseup', this[onMouseUp], true);\n    document.addEventListener('dragstart', this[onDragStart], false);\n    document.addEventListener('dragover', this[onDragOver], false);\n    document.addEventListener('dragend', this[onDragEnd], false);\n    document.addEventListener('drop', this[onDrop], false);\n\n    const target = (0, _utils.closest)(event.target, this.options.draggable);\n\n    if (!target) {\n      return;\n    }\n\n    this.mouseDownTimeout = setTimeout(() => {\n      target.draggable = true;\n      this.draggableElement = target;\n    }, this.options.delay);\n  }\n\n  /**\n   * Mouse up handler\n   * @private\n   * @param {Event} event - Mouse up event\n   */\n  [onMouseUp]() {\n    this[reset]();\n  }\n\n  /**\n   * Mouse up handler\n   * @private\n   * @param {Event} event - Mouse up event\n   */\n  [reset]() {\n    clearTimeout(this.mouseDownTimeout);\n\n    document.removeEventListener('mouseup', this[onMouseUp], true);\n    document.removeEventListener('dragstart', this[onDragStart], false);\n    document.removeEventListener('dragover', this[onDragOver], false);\n    document.removeEventListener('dragend', this[onDragEnd], false);\n    document.removeEventListener('drop', this[onDrop], false);\n\n    if (this.nativeDraggableElement) {\n      this.nativeDraggableElement.draggable = true;\n      this.nativeDraggableElement = null;\n    }\n\n    if (this.draggableElement) {\n      this.draggableElement.draggable = false;\n      this.draggableElement = null;\n    }\n  }\n}\nexports.default = DragSensor;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _DragSensor = __webpack_require__(40);\n\nvar _DragSensor2 = _interopRequireDefault(_DragSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _DragSensor2.default;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = __webpack_require__(2);\n\nvar _Sensor = __webpack_require__(4);\n\nvar _Sensor2 = _interopRequireDefault(_Sensor);\n\nvar _SensorEvent = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onTouchStart = Symbol('onTouchStart');\nconst onTouchHold = Symbol('onTouchHold');\nconst onTouchEnd = Symbol('onTouchEnd');\nconst onTouchMove = Symbol('onTouchMove');\n\n/**\n * Prevents scrolling when set to true\n * @var {Boolean} preventScrolling\n */\nlet preventScrolling = false;\n\n// WebKit requires cancelable `touchmove` events to be added as early as possible\nwindow.addEventListener('touchmove', event => {\n  if (!preventScrolling) {\n    return;\n  }\n\n  // Prevent scrolling\n  event.preventDefault();\n}, { passive: false });\n\n/**\n * This sensor picks up native browser touch events and dictates drag operations\n * @class TouchSensor\n * @module TouchSensor\n * @extends Sensor\n */\nclass TouchSensor extends _Sensor2.default {\n  /**\n   * TouchSensor constructor.\n   * @constructs TouchSensor\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\n   * @param {Object} options - Options\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, options);\n\n    /**\n     * Closest scrollable container so accidental scroll can cancel long touch\n     * @property currentScrollableParent\n     * @type {HTMLElement}\n     */\n    this.currentScrollableParent = null;\n\n    /**\n     * TimeoutID for long touch\n     * @property tapTimeout\n     * @type {Number}\n     */\n    this.tapTimeout = null;\n\n    /**\n     * touchMoved indicates if touch has moved during tapTimeout\n     * @property touchMoved\n     * @type {Boolean}\n     */\n    this.touchMoved = false;\n\n    this[onTouchStart] = this[onTouchStart].bind(this);\n    this[onTouchHold] = this[onTouchHold].bind(this);\n    this[onTouchEnd] = this[onTouchEnd].bind(this);\n    this[onTouchMove] = this[onTouchMove].bind(this);\n  }\n\n  /**\n   * Attaches sensors event listeners to the DOM\n   */\n  attach() {\n    document.addEventListener('touchstart', this[onTouchStart]);\n  }\n\n  /**\n   * Detaches sensors event listeners to the DOM\n   */\n  detach() {\n    document.removeEventListener('touchstart', this[onTouchStart]);\n  }\n\n  /**\n   * Touch start handler\n   * @private\n   * @param {Event} event - Touch start event\n   */\n  [onTouchStart](event) {\n    const container = (0, _utils.closest)(event.target, this.containers);\n\n    if (!container) {\n      return;\n    }\n\n    document.addEventListener('touchmove', this[onTouchMove]);\n    document.addEventListener('touchend', this[onTouchEnd]);\n    document.addEventListener('touchcancel', this[onTouchEnd]);\n    container.addEventListener('contextmenu', onContextMenu);\n\n    this.currentContainer = container;\n    this.tapTimeout = setTimeout(this[onTouchHold](event, container), this.options.delay);\n  }\n\n  /**\n   * Touch hold handler\n   * @private\n   * @param {Event} event - Touch start event\n   * @param {HTMLElement} container - Container element\n   */\n  [onTouchHold](event, container) {\n    return () => {\n      if (this.touchMoved) {\n        return;\n      }\n\n      const touch = event.touches[0] || event.changedTouches[0];\n      const target = event.target;\n\n      const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\n        clientX: touch.pageX,\n        clientY: touch.pageY,\n        target,\n        container,\n        originalEvent: event\n      });\n\n      this.trigger(container, dragStartEvent);\n\n      this.dragging = !dragStartEvent.canceled();\n      preventScrolling = this.dragging;\n    };\n  }\n\n  /**\n   * Touch move handler\n   * @private\n   * @param {Event} event - Touch move event\n   */\n  [onTouchMove](event) {\n    this.touchMoved = true;\n\n    if (!this.dragging) {\n      return;\n    }\n\n    const touch = event.touches[0] || event.changedTouches[0];\n    const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);\n\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\n      clientX: touch.pageX,\n      clientY: touch.pageY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragMoveEvent);\n  }\n\n  /**\n   * Touch end handler\n   * @private\n   * @param {Event} event - Touch end event\n   */\n  [onTouchEnd](event) {\n    this.touchMoved = false;\n    preventScrolling = false;\n\n    document.removeEventListener('touchend', this[onTouchEnd]);\n    document.removeEventListener('touchcancel', this[onTouchEnd]);\n    document.removeEventListener('touchmove', this[onTouchMove]);\n\n    if (this.currentContainer) {\n      this.currentContainer.removeEventListener('contextmenu', onContextMenu);\n    }\n\n    clearTimeout(this.tapTimeout);\n\n    if (!this.dragging) {\n      return;\n    }\n\n    const touch = event.touches[0] || event.changedTouches[0];\n    const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);\n\n    event.preventDefault();\n\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\n      clientX: touch.pageX,\n      clientY: touch.pageY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragStopEvent);\n\n    this.currentContainer = null;\n    this.dragging = false;\n  }\n}\n\nexports.default = TouchSensor;\nfunction onContextMenu(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _TouchSensor = __webpack_require__(42);\n\nvar _TouchSensor2 = _interopRequireDefault(_TouchSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _TouchSensor2.default;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base sensor event\n * @class SensorEvent\n * @module SensorEvent\n * @extends AbstractEvent\n */\nclass SensorEvent extends _AbstractEvent2.default {\n  /**\n   * Original browser event that triggered a sensor\n   * @property originalEvent\n   * @type {Event}\n   * @readonly\n   */\n  get originalEvent() {\n    return this.data.originalEvent;\n  }\n\n  /**\n   * Normalized clientX for both touch and mouse events\n   * @property clientX\n   * @type {Number}\n   * @readonly\n   */\n  get clientX() {\n    return this.data.clientX;\n  }\n\n  /**\n   * Normalized clientY for both touch and mouse events\n   * @property clientY\n   * @type {Number}\n   * @readonly\n   */\n  get clientY() {\n    return this.data.clientY;\n  }\n\n  /**\n   * Normalized target for both touch and mouse events\n   * Returns the element that is behind cursor or touch pointer\n   * @property target\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get target() {\n    return this.data.target;\n  }\n\n  /**\n   * Container that initiated the sensor\n   * @property container\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get container() {\n    return this.data.container;\n  }\n\n  /**\n   * Trackpad pressure\n   * @property pressure\n   * @type {Number}\n   * @readonly\n   */\n  get pressure() {\n    return this.data.pressure;\n  }\n}\n\nexports.SensorEvent = SensorEvent; /**\n                                    * Drag start sensor event\n                                    * @class DragStartSensorEvent\n                                    * @module DragStartSensorEvent\n                                    * @extends SensorEvent\n                                    */\n\nclass DragStartSensorEvent extends SensorEvent {}\n\nexports.DragStartSensorEvent = DragStartSensorEvent; /**\n                                                      * Drag move sensor event\n                                                      * @class DragMoveSensorEvent\n                                                      * @module DragMoveSensorEvent\n                                                      * @extends SensorEvent\n                                                      */\n\nDragStartSensorEvent.type = 'drag:start';\nclass DragMoveSensorEvent extends SensorEvent {}\n\nexports.DragMoveSensorEvent = DragMoveSensorEvent; /**\n                                                    * Drag stop sensor event\n                                                    * @class DragStopSensorEvent\n                                                    * @module DragStopSensorEvent\n                                                    * @extends SensorEvent\n                                                    */\n\nDragMoveSensorEvent.type = 'drag:move';\nclass DragStopSensorEvent extends SensorEvent {}\n\nexports.DragStopSensorEvent = DragStopSensorEvent; /**\n                                                    * Drag pressure sensor event\n                                                    * @class DragPressureSensorEvent\n                                                    * @module DragPressureSensorEvent\n                                                    * @extends SensorEvent\n                                                    */\n\nDragStopSensorEvent.type = 'drag:stop';\nclass DragPressureSensorEvent extends SensorEvent {}\nexports.DragPressureSensorEvent = DragPressureSensorEvent;\nDragPressureSensorEvent.type = 'drag:pressure';\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = __webpack_require__(2);\n\nvar _Sensor = __webpack_require__(4);\n\nvar _Sensor2 = _interopRequireDefault(_Sensor);\n\nvar _SensorEvent = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');\nconst onMouseDown = Symbol('onMouseDown');\nconst onMouseMove = Symbol('onMouseMove');\nconst onMouseUp = Symbol('onMouseUp');\n\n/**\n * This sensor picks up native browser mouse events and dictates drag operations\n * @class MouseSensor\n * @module MouseSensor\n * @extends Sensor\n */\nclass MouseSensor extends _Sensor2.default {\n  /**\n   * MouseSensor constructor.\n   * @constructs MouseSensor\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\n   * @param {Object} options - Options\n   */\n  constructor(containers = [], options = {}) {\n    super(containers, options);\n\n    /**\n     * Indicates if mouse button is still down\n     * @property mouseDown\n     * @type {Boolean}\n     */\n    this.mouseDown = false;\n\n    /**\n     * Mouse down timer which will end up triggering the drag start operation\n     * @property mouseDownTimeout\n     * @type {Number}\n     */\n    this.mouseDownTimeout = null;\n\n    /**\n     * Indicates if context menu has been opened during drag operation\n     * @property openedContextMenu\n     * @type {Boolean}\n     */\n    this.openedContextMenu = false;\n\n    this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);\n    this[onMouseDown] = this[onMouseDown].bind(this);\n    this[onMouseMove] = this[onMouseMove].bind(this);\n    this[onMouseUp] = this[onMouseUp].bind(this);\n  }\n\n  /**\n   * Attaches sensors event listeners to the DOM\n   */\n  attach() {\n    document.addEventListener('mousedown', this[onMouseDown], true);\n  }\n\n  /**\n   * Detaches sensors event listeners to the DOM\n   */\n  detach() {\n    document.removeEventListener('mousedown', this[onMouseDown], true);\n  }\n\n  /**\n   * Mouse down handler\n   * @private\n   * @param {Event} event - Mouse down event\n   */\n  [onMouseDown](event) {\n    if (event.button !== 0 || event.ctrlKey || event.metaKey) {\n      return;\n    }\n\n    document.addEventListener('mouseup', this[onMouseUp]);\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n    const container = (0, _utils.closest)(target, this.containers);\n\n    if (!container) {\n      return;\n    }\n\n    document.addEventListener('dragstart', preventNativeDragStart);\n\n    this.mouseDown = true;\n\n    clearTimeout(this.mouseDownTimeout);\n    this.mouseDownTimeout = setTimeout(() => {\n      if (!this.mouseDown) {\n        return;\n      }\n\n      const dragStartEvent = new _SensorEvent.DragStartSensorEvent({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target,\n        container,\n        originalEvent: event\n      });\n\n      this.trigger(container, dragStartEvent);\n\n      this.currentContainer = container;\n      this.dragging = !dragStartEvent.canceled();\n\n      if (this.dragging) {\n        document.addEventListener('contextmenu', this[onContextMenuWhileDragging]);\n        document.addEventListener('mousemove', this[onMouseMove]);\n      }\n    }, this.options.delay);\n  }\n\n  /**\n   * Mouse move handler\n   * @private\n   * @param {Event} event - Mouse move event\n   */\n  [onMouseMove](event) {\n    if (!this.dragging) {\n      return;\n    }\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n\n    const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragMoveEvent);\n  }\n\n  /**\n   * Mouse up handler\n   * @private\n   * @param {Event} event - Mouse up event\n   */\n  [onMouseUp](event) {\n    this.mouseDown = Boolean(this.openedContextMenu);\n\n    if (this.openedContextMenu) {\n      this.openedContextMenu = false;\n      return;\n    }\n\n    document.removeEventListener('mouseup', this[onMouseUp]);\n    document.removeEventListener('dragstart', preventNativeDragStart);\n\n    if (!this.dragging) {\n      return;\n    }\n\n    const target = document.elementFromPoint(event.clientX, event.clientY);\n\n    const dragStopEvent = new _SensorEvent.DragStopSensorEvent({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      target,\n      container: this.currentContainer,\n      originalEvent: event\n    });\n\n    this.trigger(this.currentContainer, dragStopEvent);\n\n    document.removeEventListener('contextmenu', this[onContextMenuWhileDragging]);\n    document.removeEventListener('mousemove', this[onMouseMove]);\n\n    this.currentContainer = null;\n    this.dragging = false;\n  }\n\n  /**\n   * Context menu handler\n   * @private\n   * @param {Event} event - Context menu event\n   */\n  [onContextMenuWhileDragging](event) {\n    event.preventDefault();\n    this.openedContextMenu = true;\n  }\n}\n\nexports.default = MouseSensor;\nfunction preventNativeDragStart(event) {\n  event.preventDefault();\n}\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MouseSensor = __webpack_require__(45);\n\nvar _MouseSensor2 = _interopRequireDefault(_MouseSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _MouseSensor2.default;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n/**\n * Base sensor class. Extend from this class to create a new or custom sensor\n * @class Sensor\n * @module Sensor\n */\nclass Sensor {\n  /**\n   * Sensor constructor.\n   * @constructs Sensor\n   * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers\n   * @param {Object} options - Options\n   */\n  constructor(containers = [], options = {}) {\n    /**\n     * Current containers\n     * @property containers\n     * @type {HTMLElement[]}\n     */\n    this.containers = [...containers];\n\n    /**\n     * Current options\n     * @property options\n     * @type {Object}\n     */\n    this.options = _extends({}, options);\n\n    /**\n     * Current drag state\n     * @property dragging\n     * @type {Boolean}\n     */\n    this.dragging = false;\n\n    /**\n     * Current container\n     * @property currentContainer\n     * @type {HTMLElement}\n     */\n    this.currentContainer = null;\n  }\n\n  /**\n   * Attaches sensors event listeners to the DOM\n   * @return {Sensor}\n   */\n  attach() {\n    return this;\n  }\n\n  /**\n   * Detaches sensors event listeners to the DOM\n   * @return {Sensor}\n   */\n  detach() {\n    return this;\n  }\n\n  /**\n   * Adds container to this sensor instance\n   * @param {...HTMLElement} containers - Containers you want to add to this sensor\n   * @example draggable.addContainer(document.body)\n   */\n  addContainer(...containers) {\n    this.containers = [...this.containers, ...containers];\n  }\n\n  /**\n   * Removes container from this sensor instance\n   * @param {...HTMLElement} containers - Containers you want to remove from this sensor\n   * @example draggable.removeContainer(document.body)\n   */\n  removeContainer(...containers) {\n    this.containers = this.containers.filter(container => !containers.includes(container));\n  }\n\n  /**\n   * Triggers event on target element\n   * @param {HTMLElement} element - Element to trigger event on\n   * @param {SensorEvent} sensorEvent - Sensor event to trigger\n   */\n  trigger(element, sensorEvent) {\n    const event = document.createEvent('Event');\n    event.detail = sensorEvent;\n    event.initEvent(sensorEvent.type, true, true);\n    element.dispatchEvent(event);\n    this.lastEvent = sensorEvent;\n\n    return sensorEvent;\n  }\n}\nexports.default = Sensor;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = requestNextAnimationFrame;\nfunction requestNextAnimationFrame(callback) {\n  return requestAnimationFrame(() => {\n    requestAnimationFrame(callback);\n  });\n}\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _requestNextAnimationFrame = __webpack_require__(48);\n\nvar _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _requestNextAnimationFrame2.default;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = closest;\nconst matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;\n\n/**\n * Get the closest parent element of a given element that matches the given\n * selector string or matching function\n *\n * @param {Element} element The child element to find a parent of\n * @param {String|Function} selector The string or function to use to match\n *     the parent element\n * @return {Element|null}\n */\nfunction closest(element, value) {\n  if (!element) {\n    return null;\n  }\n\n  const selector = value;\n  const callback = value;\n  const nodeList = value;\n  const singleElement = value;\n\n  const isSelector = Boolean(typeof value === 'string');\n  const isFunction = Boolean(typeof value === 'function');\n  const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);\n  const isElement = Boolean(value instanceof HTMLElement);\n\n  function conditionFn(currentElement) {\n    if (!currentElement) {\n      return currentElement;\n    } else if (isSelector) {\n      return matchFunction.call(currentElement, selector);\n    } else if (isNodeList) {\n      return [...nodeList].includes(currentElement);\n    } else if (isElement) {\n      return singleElement === currentElement;\n    } else if (isFunction) {\n      return callback(currentElement);\n    } else {\n      return null;\n    }\n  }\n\n  let current = element;\n\n  do {\n    current = current.correspondingUseElement || current.correspondingElement || current;\n\n    if (conditionFn(current)) {\n      return current;\n    }\n\n    current = current.parentNode;\n  } while (current && current !== document.body && current !== document);\n\n  return null;\n}\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _closest = __webpack_require__(50);\n\nvar _closest2 = _interopRequireDefault(_closest);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _closest2.default;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _utils = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\nconst scroll = exports.scroll = Symbol('scroll');\n\n/**\n * Scrollable default options\n * @property {Object} defaultOptions\n * @property {Number} defaultOptions.speed\n * @property {Number} defaultOptions.sensitivity\n * @property {HTMLElement[]} defaultOptions.scrollableElements\n * @type {Object}\n */\nconst defaultOptions = exports.defaultOptions = {\n  speed: 6,\n  sensitivity: 50,\n  scrollableElements: []\n};\n\n/**\n * Scrollable plugin which scrolls the closest scrollable parent\n * @class Scrollable\n * @module Scrollable\n * @extends AbstractPlugin\n */\nclass Scrollable extends _AbstractPlugin2.default {\n  /**\n   * Scrollable constructor.\n   * @constructs Scrollable\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Scrollable options\n     * @property {Object} options\n     * @property {Number} options.speed\n     * @property {Number} options.sensitivity\n     * @property {HTMLElement[]} options.scrollableElements\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    /**\n     * Keeps current mouse position\n     * @property {Object} currentMousePosition\n     * @property {Number} currentMousePosition.clientX\n     * @property {Number} currentMousePosition.clientY\n     * @type {Object|null}\n     */\n    this.currentMousePosition = null;\n\n    /**\n     * Scroll animation frame\n     * @property scrollAnimationFrame\n     * @type {Number|null}\n     */\n    this.scrollAnimationFrame = null;\n\n    /**\n     * Closest scrollable element\n     * @property scrollableElement\n     * @type {HTMLElement|null}\n     */\n    this.scrollableElement = null;\n\n    /**\n     * Animation frame looking for the closest scrollable element\n     * @property findScrollableElementFrame\n     * @type {Number|null}\n     */\n    this.findScrollableElementFrame = null;\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragMove] = this[onDragMove].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n    this[scroll] = this[scroll].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);\n  }\n\n  /**\n   * Returns options passed through draggable\n   * @return {Object}\n   */\n  getOptions() {\n    return this.draggable.options.scrollable || {};\n  }\n\n  /**\n   * Returns closest scrollable elements by element\n   * @param {HTMLElement} target\n   * @return {HTMLElement}\n   */\n  getScrollableElement(target) {\n    if (this.hasDefinedScrollableElements()) {\n      return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;\n    } else {\n      return closestScrollableElement(target);\n    }\n  }\n\n  /**\n   * Returns true if at least one scrollable element have been defined via options\n   * @param {HTMLElement} target\n   * @return {Boolean}\n   */\n  hasDefinedScrollableElements() {\n    return Boolean(this.options.scrollableElements.length !== 0);\n  }\n\n  /**\n   * Drag start handler. Finds closest scrollable parent in separate frame\n   * @param {DragStartEvent} dragEvent\n   * @private\n   */\n  [onDragStart](dragEvent) {\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\n      this.scrollableElement = this.getScrollableElement(dragEvent.source);\n    });\n  }\n\n  /**\n   * Drag move handler. Remembers mouse position and initiates scrolling\n   * @param {DragMoveEvent} dragEvent\n   * @private\n   */\n  [onDragMove](dragEvent) {\n    this.findScrollableElementFrame = requestAnimationFrame(() => {\n      this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);\n    });\n\n    if (!this.scrollableElement) {\n      return;\n    }\n\n    const sensorEvent = dragEvent.sensorEvent;\n    const scrollOffset = { x: 0, y: 0 };\n\n    if ('ontouchstart' in window) {\n      scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n      scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n    }\n\n    this.currentMousePosition = {\n      clientX: sensorEvent.clientX - scrollOffset.x,\n      clientY: sensorEvent.clientY - scrollOffset.y\n    };\n\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\n  }\n\n  /**\n   * Drag stop handler. Cancels scroll animations and resets state\n   * @private\n   */\n  [onDragStop]() {\n    cancelAnimationFrame(this.scrollAnimationFrame);\n    cancelAnimationFrame(this.findScrollableElementFrame);\n\n    this.scrollableElement = null;\n    this.scrollAnimationFrame = null;\n    this.findScrollableElementFrame = null;\n    this.currentMousePosition = null;\n  }\n\n  /**\n   * Scroll function that does the heavylifting\n   * @private\n   */\n  [scroll]() {\n    if (!this.scrollableElement || !this.currentMousePosition) {\n      return;\n    }\n\n    cancelAnimationFrame(this.scrollAnimationFrame);\n\n    const { speed, sensitivity } = this.options;\n\n    const rect = this.scrollableElement.getBoundingClientRect();\n    const bottomCutOff = rect.bottom > window.innerHeight;\n    const topCutOff = rect.top < 0;\n    const cutOff = topCutOff || bottomCutOff;\n\n    const documentScrollingElement = getDocumentScrollingElement();\n    const scrollableElement = this.scrollableElement;\n    const clientX = this.currentMousePosition.clientX;\n    const clientY = this.currentMousePosition.clientY;\n\n    if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {\n      const { offsetHeight, offsetWidth } = scrollableElement;\n\n      if (rect.top + offsetHeight - clientY < sensitivity) {\n        scrollableElement.scrollTop += speed;\n      } else if (clientY - rect.top < sensitivity) {\n        scrollableElement.scrollTop -= speed;\n      }\n\n      if (rect.left + offsetWidth - clientX < sensitivity) {\n        scrollableElement.scrollLeft += speed;\n      } else if (clientX - rect.left < sensitivity) {\n        scrollableElement.scrollLeft -= speed;\n      }\n    } else {\n      const { innerHeight, innerWidth } = window;\n\n      if (clientY < sensitivity) {\n        documentScrollingElement.scrollTop -= speed;\n      } else if (innerHeight - clientY < sensitivity) {\n        documentScrollingElement.scrollTop += speed;\n      }\n\n      if (clientX < sensitivity) {\n        documentScrollingElement.scrollLeft -= speed;\n      } else if (innerWidth - clientX < sensitivity) {\n        documentScrollingElement.scrollLeft += speed;\n      }\n    }\n\n    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);\n  }\n}\n\nexports.default = Scrollable; /**\n                               * Returns true if the passed element has overflow\n                               * @param {HTMLElement} element\n                               * @return {Boolean}\n                               * @private\n                               */\n\nfunction hasOverflow(element) {\n  const overflowRegex = /(auto|scroll)/;\n  const computedStyles = getComputedStyle(element, null);\n\n  const overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');\n\n  return overflowRegex.test(overflow);\n}\n\n/**\n * Returns true if the passed element is statically positioned\n * @param {HTMLElement} element\n * @return {Boolean}\n * @private\n */\nfunction isStaticallyPositioned(element) {\n  const position = getComputedStyle(element).getPropertyValue('position');\n  return position === 'static';\n}\n\n/**\n * Finds closest scrollable element\n * @param {HTMLElement} element\n * @return {HTMLElement}\n * @private\n */\nfunction closestScrollableElement(element) {\n  if (!element) {\n    return getDocumentScrollingElement();\n  }\n\n  const position = getComputedStyle(element).getPropertyValue('position');\n  const excludeStaticParents = position === 'absolute';\n\n  const scrollableElement = (0, _utils.closest)(element, parent => {\n    if (excludeStaticParents && isStaticallyPositioned(parent)) {\n      return false;\n    }\n    return hasOverflow(parent);\n  });\n\n  if (position === 'fixed' || !scrollableElement) {\n    return getDocumentScrollingElement();\n  } else {\n    return scrollableElement;\n  }\n}\n\n/**\n * Returns element that scrolls document\n * @return {HTMLElement}\n * @private\n */\nfunction getDocumentScrollingElement() {\n  return document.scrollingElement || document.documentElement;\n}\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _Scrollable = __webpack_require__(52);\n\nvar _Scrollable2 = _interopRequireDefault(_Scrollable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Scrollable2.default;\nexports.defaultOptions = _Scrollable.defaultOptions;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base mirror event\n * @class MirrorEvent\n * @module MirrorEvent\n * @extends AbstractEvent\n */\nclass MirrorEvent extends _AbstractEvent2.default {\n  /**\n   * Draggables source element\n   * @property source\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get source() {\n    return this.data.source;\n  }\n\n  /**\n   * Draggables original source element\n   * @property originalSource\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get originalSource() {\n    return this.data.originalSource;\n  }\n\n  /**\n   * Draggables source container element\n   * @property sourceContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get sourceContainer() {\n    return this.data.sourceContainer;\n  }\n\n  /**\n   * Sensor event\n   * @property sensorEvent\n   * @type {SensorEvent}\n   * @readonly\n   */\n  get sensorEvent() {\n    return this.data.sensorEvent;\n  }\n\n  /**\n   * Drag event\n   * @property dragEvent\n   * @type {DragEvent}\n   * @readonly\n   */\n  get dragEvent() {\n    return this.data.dragEvent;\n  }\n\n  /**\n   * Original event that triggered sensor event\n   * @property originalEvent\n   * @type {Event}\n   * @readonly\n   */\n  get originalEvent() {\n    if (this.sensorEvent) {\n      return this.sensorEvent.originalEvent;\n    }\n\n    return null;\n  }\n}\n\nexports.MirrorEvent = MirrorEvent; /**\n                                    * Mirror create event\n                                    * @class MirrorCreateEvent\n                                    * @module MirrorCreateEvent\n                                    * @extends MirrorEvent\n                                    */\n\nclass MirrorCreateEvent extends MirrorEvent {}\n\nexports.MirrorCreateEvent = MirrorCreateEvent; /**\n                                                * Mirror created event\n                                                * @class MirrorCreatedEvent\n                                                * @module MirrorCreatedEvent\n                                                * @extends MirrorEvent\n                                                */\n\nMirrorCreateEvent.type = 'mirror:create';\nclass MirrorCreatedEvent extends MirrorEvent {\n\n  /**\n   * Draggables mirror element\n   * @property mirror\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get mirror() {\n    return this.data.mirror;\n  }\n}\n\nexports.MirrorCreatedEvent = MirrorCreatedEvent; /**\n                                                  * Mirror attached event\n                                                  * @class MirrorAttachedEvent\n                                                  * @module MirrorAttachedEvent\n                                                  * @extends MirrorEvent\n                                                  */\n\nMirrorCreatedEvent.type = 'mirror:created';\nclass MirrorAttachedEvent extends MirrorEvent {\n\n  /**\n   * Draggables mirror element\n   * @property mirror\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get mirror() {\n    return this.data.mirror;\n  }\n}\n\nexports.MirrorAttachedEvent = MirrorAttachedEvent; /**\n                                                    * Mirror move event\n                                                    * @class MirrorMoveEvent\n                                                    * @module MirrorMoveEvent\n                                                    * @extends MirrorEvent\n                                                    */\n\nMirrorAttachedEvent.type = 'mirror:attached';\nclass MirrorMoveEvent extends MirrorEvent {\n\n  /**\n   * Draggables mirror element\n   * @property mirror\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get mirror() {\n    return this.data.mirror;\n  }\n}\n\nexports.MirrorMoveEvent = MirrorMoveEvent; /**\n                                            * Mirror destroy event\n                                            * @class MirrorDestroyEvent\n                                            * @module MirrorDestroyEvent\n                                            * @extends MirrorEvent\n                                            */\n\nMirrorMoveEvent.type = 'mirror:move';\nMirrorMoveEvent.cancelable = true;\nclass MirrorDestroyEvent extends MirrorEvent {\n\n  /**\n   * Draggables mirror element\n   * @property mirror\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get mirror() {\n    return this.data.mirror;\n  }\n}\nexports.MirrorDestroyEvent = MirrorDestroyEvent;\nMirrorDestroyEvent.type = 'mirror:destroy';\nMirrorDestroyEvent.cancelable = true;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MirrorEvent = __webpack_require__(54);\n\nObject.keys(_MirrorEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _MirrorEvent[key];\n    }\n  });\n});\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _MirrorEvent = __webpack_require__(55);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nconst onDragStart = exports.onDragStart = Symbol('onDragStart');\nconst onDragMove = exports.onDragMove = Symbol('onDragMove');\nconst onDragStop = exports.onDragStop = Symbol('onDragStop');\nconst onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');\nconst onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');\nconst onScroll = exports.onScroll = Symbol('onScroll');\nconst getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');\n\n/**\n * Mirror default options\n * @property {Object} defaultOptions\n * @property {Boolean} defaultOptions.constrainDimensions\n * @property {Boolean} defaultOptions.xAxis\n * @property {Boolean} defaultOptions.yAxis\n * @property {null} defaultOptions.cursorOffsetX\n * @property {null} defaultOptions.cursorOffsetY\n * @type {Object}\n */\nconst defaultOptions = exports.defaultOptions = {\n  constrainDimensions: false,\n  xAxis: true,\n  yAxis: true,\n  cursorOffsetX: null,\n  cursorOffsetY: null\n};\n\n/**\n * Mirror plugin which controls the mirror positioning while dragging\n * @class Mirror\n * @module Mirror\n * @extends AbstractPlugin\n */\nclass Mirror extends _AbstractPlugin2.default {\n  /**\n   * Mirror constructor.\n   * @constructs Mirror\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Mirror options\n     * @property {Object} options\n     * @property {Boolean} options.constrainDimensions\n     * @property {Boolean} options.xAxis\n     * @property {Boolean} options.yAxis\n     * @property {Number|null} options.cursorOffsetX\n     * @property {Number|null} options.cursorOffsetY\n     * @property {String|HTMLElement|Function} options.appendTo\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    /**\n     * Scroll offset for touch devices because the mirror is positioned fixed\n     * @property {Object} scrollOffset\n     * @property {Number} scrollOffset.x\n     * @property {Number} scrollOffset.y\n     */\n    this.scrollOffset = { x: 0, y: 0 };\n\n    /**\n     * Initial scroll offset for touch devices because the mirror is positioned fixed\n     * @property {Object} scrollOffset\n     * @property {Number} scrollOffset.x\n     * @property {Number} scrollOffset.y\n     */\n    this.initialScrollOffset = {\n      x: window.scrollX,\n      y: window.scrollY\n    };\n\n    this[onDragStart] = this[onDragStart].bind(this);\n    this[onDragMove] = this[onDragMove].bind(this);\n    this[onDragStop] = this[onDragStop].bind(this);\n    this[onMirrorCreated] = this[onMirrorCreated].bind(this);\n    this[onMirrorMove] = this[onMirrorMove].bind(this);\n    this[onScroll] = this[onScroll].bind(this);\n  }\n\n  /**\n   * Attaches plugins event listeners\n   */\n  attach() {\n    this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);\n  }\n\n  /**\n   * Detaches plugins event listeners\n   */\n  detach() {\n    this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);\n  }\n\n  /**\n   * Returns options passed through draggable\n   * @return {Object}\n   */\n  getOptions() {\n    return this.draggable.options.mirror || {};\n  }\n\n  [onDragStart](dragEvent) {\n    if (dragEvent.canceled()) {\n      return;\n    }\n\n    if ('ontouchstart' in window) {\n      document.addEventListener('scroll', this[onScroll], true);\n    }\n\n    this.initialScrollOffset = {\n      x: window.scrollX,\n      y: window.scrollY\n    };\n\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\n\n    const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({\n      source,\n      originalSource,\n      sourceContainer,\n      sensorEvent,\n      dragEvent\n    });\n\n    this.draggable.trigger(mirrorCreateEvent);\n\n    if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {\n      return;\n    }\n\n    const appendableContainer = this[getAppendableContainer](source) || sourceContainer;\n    this.mirror = source.cloneNode(true);\n\n    const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({\n      source,\n      originalSource,\n      sourceContainer,\n      sensorEvent,\n      dragEvent,\n      mirror: this.mirror\n    });\n\n    const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({\n      source,\n      originalSource,\n      sourceContainer,\n      sensorEvent,\n      dragEvent,\n      mirror: this.mirror\n    });\n\n    this.draggable.trigger(mirrorCreatedEvent);\n    appendableContainer.appendChild(this.mirror);\n    this.draggable.trigger(mirrorAttachedEvent);\n  }\n\n  [onDragMove](dragEvent) {\n    if (!this.mirror || dragEvent.canceled()) {\n      return;\n    }\n\n    const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;\n\n    const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({\n      source,\n      originalSource,\n      sourceContainer,\n      sensorEvent,\n      dragEvent,\n      mirror: this.mirror\n    });\n\n    this.draggable.trigger(mirrorMoveEvent);\n  }\n\n  [onDragStop](dragEvent) {\n    if ('ontouchstart' in window) {\n      document.removeEventListener('scroll', this[onScroll], true);\n    }\n\n    this.initialScrollOffset = { x: 0, y: 0 };\n    this.scrollOffset = { x: 0, y: 0 };\n\n    if (!this.mirror) {\n      return;\n    }\n\n    const { source, sourceContainer, sensorEvent } = dragEvent;\n\n    const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({\n      source,\n      mirror: this.mirror,\n      sourceContainer,\n      sensorEvent,\n      dragEvent\n    });\n\n    this.draggable.trigger(mirrorDestroyEvent);\n\n    if (!mirrorDestroyEvent.canceled()) {\n      this.mirror.parentNode.removeChild(this.mirror);\n    }\n  }\n\n  [onScroll]() {\n    this.scrollOffset = {\n      x: window.scrollX - this.initialScrollOffset.x,\n      y: window.scrollY - this.initialScrollOffset.y\n    };\n  }\n\n  /**\n   * Mirror created handler\n   * @param {MirrorCreatedEvent} mirrorEvent\n   * @return {Promise}\n   * @private\n   */\n  [onMirrorCreated]({ mirror, source, sensorEvent }) {\n    const mirrorClass = this.draggable.getClassNameFor('mirror');\n\n    const setState = (_ref) => {\n      let { mirrorOffset, initialX, initialY } = _ref,\n          args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);\n\n      this.mirrorOffset = mirrorOffset;\n      this.initialX = initialX;\n      this.initialY = initialY;\n      return _extends({ mirrorOffset, initialX, initialY }, args);\n    };\n\n    const initialState = {\n      mirror,\n      source,\n      sensorEvent,\n      mirrorClass,\n      scrollOffset: this.scrollOffset,\n      options: this.options\n    };\n\n    return Promise.resolve(initialState)\n    // Fix reflow here\n    .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);\n  }\n\n  /**\n   * Mirror move handler\n   * @param {MirrorMoveEvent} mirrorEvent\n   * @return {Promise|null}\n   * @private\n   */\n  [onMirrorMove](mirrorEvent) {\n    if (mirrorEvent.canceled()) {\n      return null;\n    }\n\n    const initialState = {\n      mirror: mirrorEvent.mirror,\n      sensorEvent: mirrorEvent.sensorEvent,\n      mirrorOffset: this.mirrorOffset,\n      options: this.options,\n      initialX: this.initialX,\n      initialY: this.initialY,\n      scrollOffset: this.scrollOffset\n    };\n\n    return Promise.resolve(initialState).then(positionMirror({ raf: true }));\n  }\n\n  /**\n   * Returns appendable container for mirror based on the appendTo option\n   * @private\n   * @param {Object} options\n   * @param {HTMLElement} options.source - Current source\n   * @return {HTMLElement}\n   */\n  [getAppendableContainer](source) {\n    const appendTo = this.options.appendTo;\n\n    if (typeof appendTo === 'string') {\n      return document.querySelector(appendTo);\n    } else if (appendTo instanceof HTMLElement) {\n      return appendTo;\n    } else if (typeof appendTo === 'function') {\n      return appendTo(source);\n    } else {\n      return source.parentNode;\n    }\n  }\n}\n\nexports.default = Mirror; /**\n                           * Computes mirror dimensions based on the source element\n                           * Adds sourceRect to state\n                           * @param {Object} state\n                           * @param {HTMLElement} state.source\n                           * @return {Promise}\n                           * @private\n                           */\n\nfunction computeMirrorDimensions(_ref2) {\n  let { source } = _ref2,\n      args = _objectWithoutProperties(_ref2, ['source']);\n\n  return withPromise(resolve => {\n    const sourceRect = source.getBoundingClientRect();\n    resolve(_extends({ source, sourceRect }, args));\n  });\n}\n\n/**\n * Calculates mirror offset\n * Adds mirrorOffset to state\n * @param {Object} state\n * @param {SensorEvent} state.sensorEvent\n * @param {DOMRect} state.sourceRect\n * @return {Promise}\n * @private\n */\nfunction calculateMirrorOffset(_ref3) {\n  let { sensorEvent, sourceRect, options } = _ref3,\n      args = _objectWithoutProperties(_ref3, ['sensorEvent', 'sourceRect', 'options']);\n\n  return withPromise(resolve => {\n    const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;\n    const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;\n\n    const mirrorOffset = { top, left };\n\n    resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));\n  });\n}\n\n/**\n * Applys mirror styles\n * @param {Object} state\n * @param {HTMLElement} state.mirror\n * @param {HTMLElement} state.source\n * @param {Object} state.options\n * @return {Promise}\n * @private\n */\nfunction resetMirror(_ref4) {\n  let { mirror, source, options } = _ref4,\n      args = _objectWithoutProperties(_ref4, ['mirror', 'source', 'options']);\n\n  return withPromise(resolve => {\n    let offsetHeight;\n    let offsetWidth;\n\n    if (options.constrainDimensions) {\n      const computedSourceStyles = getComputedStyle(source);\n      offsetHeight = computedSourceStyles.getPropertyValue('height');\n      offsetWidth = computedSourceStyles.getPropertyValue('width');\n    }\n\n    mirror.style.position = 'fixed';\n    mirror.style.pointerEvents = 'none';\n    mirror.style.top = 0;\n    mirror.style.left = 0;\n    mirror.style.margin = 0;\n\n    if (options.constrainDimensions) {\n      mirror.style.height = offsetHeight;\n      mirror.style.width = offsetWidth;\n    }\n\n    resolve(_extends({ mirror, source, options }, args));\n  });\n}\n\n/**\n * Applys mirror class on mirror element\n * @param {Object} state\n * @param {HTMLElement} state.mirror\n * @param {String} state.mirrorClass\n * @return {Promise}\n * @private\n */\nfunction addMirrorClasses(_ref5) {\n  let { mirror, mirrorClass } = _ref5,\n      args = _objectWithoutProperties(_ref5, ['mirror', 'mirrorClass']);\n\n  return withPromise(resolve => {\n    mirror.classList.add(mirrorClass);\n    resolve(_extends({ mirror, mirrorClass }, args));\n  });\n}\n\n/**\n * Removes source ID from cloned mirror element\n * @param {Object} state\n * @param {HTMLElement} state.mirror\n * @return {Promise}\n * @private\n */\nfunction removeMirrorID(_ref6) {\n  let { mirror } = _ref6,\n      args = _objectWithoutProperties(_ref6, ['mirror']);\n\n  return withPromise(resolve => {\n    mirror.removeAttribute('id');\n    delete mirror.id;\n    resolve(_extends({ mirror }, args));\n  });\n}\n\n/**\n * Positions mirror with translate3d\n * @param {Object} state\n * @param {HTMLElement} state.mirror\n * @param {SensorEvent} state.sensorEvent\n * @param {Object} state.mirrorOffset\n * @param {Number} state.initialY\n * @param {Number} state.initialX\n * @param {Object} state.options\n * @return {Promise}\n * @private\n */\nfunction positionMirror({ withFrame = false, initial = false } = {}) {\n  return (_ref7) => {\n    let { mirror, sensorEvent, mirrorOffset, initialY, initialX, scrollOffset, options } = _ref7,\n        args = _objectWithoutProperties(_ref7, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options']);\n\n    return withPromise(resolve => {\n      const result = _extends({\n        mirror,\n        sensorEvent,\n        mirrorOffset,\n        options\n      }, args);\n\n      if (mirrorOffset) {\n        const x = sensorEvent.clientX - mirrorOffset.left - scrollOffset.x;\n        const y = sensorEvent.clientY - mirrorOffset.top - scrollOffset.y;\n\n        if (options.xAxis && options.yAxis || initial) {\n          mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n        } else if (options.xAxis && !options.yAxis) {\n          mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;\n        } else if (options.yAxis && !options.xAxis) {\n          mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;\n        }\n\n        if (initial) {\n          result.initialX = x;\n          result.initialY = y;\n        }\n      }\n\n      resolve(result);\n    }, { frame: withFrame });\n  };\n}\n\n/**\n * Wraps functions in promise with potential animation frame option\n * @param {Function} callback\n * @param {Object} options\n * @param {Boolean} options.raf\n * @return {Promise}\n * @private\n */\nfunction withPromise(callback, { raf = false } = {}) {\n  return new Promise((resolve, reject) => {\n    if (raf) {\n      requestAnimationFrame(() => {\n        callback(resolve, reject);\n      });\n    } else {\n      callback(resolve, reject);\n    }\n  });\n}\n\n/**\n * Returns true if the sensor event was triggered by a native browser drag event\n * @param {SensorEvent} sensorEvent\n */\nfunction isNativeDragEvent(sensorEvent) {\n  return (/^drag/.test(sensorEvent.originalEvent.type)\n  );\n}\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _Mirror = __webpack_require__(56);\n\nvar _Mirror2 = _interopRequireDefault(_Mirror);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Mirror2.default;\nexports.defaultOptions = _Mirror.defaultOptions;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onInitialize = Symbol('onInitialize');\nconst onDestroy = Symbol('onDestroy');\n\n/**\n * Focusable default options\n * @property {Object} defaultOptions\n * @type {Object}\n */\nconst defaultOptions = {};\n\n/**\n * Focusable plugin\n * @class Focusable\n * @module Focusable\n * @extends AbstractPlugin\n */\nclass Focusable extends _AbstractPlugin2.default {\n  /**\n   * Focusable constructor.\n   * @constructs Focusable\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Focusable options\n     * @property {Object} options\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    this[onInitialize] = this[onInitialize].bind(this);\n    this[onDestroy] = this[onDestroy].bind(this);\n  }\n\n  /**\n   * Attaches listeners to draggable\n   */\n  attach() {\n    this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);\n  }\n\n  /**\n   * Detaches listeners from draggable\n   */\n  detach() {\n    this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);\n  }\n\n  /**\n   * Returns options passed through draggable\n   * @return {Object}\n   */\n  getOptions() {\n    return this.draggable.options.focusable || {};\n  }\n\n  /**\n   * Returns draggable containers and elements\n   * @return {HTMLElement[]}\n   */\n  getElements() {\n    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];\n  }\n\n  /**\n   * Intialize handler\n   * @private\n   */\n  [onInitialize]() {\n    // Can wait until the next best frame is available\n    requestAnimationFrame(() => {\n      this.getElements().forEach(element => decorateElement(element));\n    });\n  }\n\n  /**\n   * Destroy handler\n   * @private\n   */\n  [onDestroy]() {\n    // Can wait until the next best frame is available\n    requestAnimationFrame(() => {\n      this.getElements().forEach(element => stripElement(element));\n    });\n  }\n}\n\nexports.default = Focusable; /**\n                              * Keeps track of all the elements that are missing tabindex attributes\n                              * so they can be reset when draggable gets destroyed\n                              * @const {HTMLElement[]} elementsWithMissingTabIndex\n                              */\n\nconst elementsWithMissingTabIndex = [];\n\n/**\n * Decorates element with tabindex attributes\n * @param {HTMLElement} element\n * @return {Object}\n * @private\n */\nfunction decorateElement(element) {\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\n\n  if (hasMissingTabIndex) {\n    elementsWithMissingTabIndex.push(element);\n    element.tabIndex = 0;\n  }\n}\n\n/**\n * Removes elements tabindex attributes\n * @param {HTMLElement} element\n * @private\n */\nfunction stripElement(element) {\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\n\n  if (tabIndexElementPosition !== -1) {\n    element.tabIndex = -1;\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\n  }\n}\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Focusable = __webpack_require__(58);\n\nvar _Focusable2 = _interopRequireDefault(_Focusable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Focusable2.default;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * All draggable plugins inherit from this class.\n * @abstract\n * @class AbstractPlugin\n * @module AbstractPlugin\n */\nclass AbstractPlugin {\n  /**\n   * AbstractPlugin constructor.\n   * @constructs AbstractPlugin\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    /**\n     * Draggable instance\n     * @property draggable\n     * @type {Draggable}\n     */\n    this.draggable = draggable;\n  }\n\n  /**\n   * Override to add listeners\n   * @abstract\n   */\n  attach() {\n    throw new Error('Not Implemented');\n  }\n\n  /**\n   * Override to remove listeners\n   * @abstract\n   */\n  detach() {\n    throw new Error('Not Implemented');\n  }\n}\nexports.default = AbstractPlugin;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst onInitialize = Symbol('onInitialize');\nconst onDestroy = Symbol('onDestroy');\nconst announceEvent = Symbol('announceEvent');\nconst announceMessage = Symbol('announceMessage');\n\nconst ARIA_RELEVANT = 'aria-relevant';\nconst ARIA_ATOMIC = 'aria-atomic';\nconst ARIA_LIVE = 'aria-live';\nconst ROLE = 'role';\n\n/**\n * Announcement default options\n * @property {Object} defaultOptions\n * @property {Number} defaultOptions.expire\n * @type {Object}\n */\nconst defaultOptions = exports.defaultOptions = {\n  expire: 7000\n};\n\n/**\n * Announcement plugin\n * @class Announcement\n * @module Announcement\n * @extends AbstractPlugin\n */\nclass Announcement extends _AbstractPlugin2.default {\n  /**\n   * Announcement constructor.\n   * @constructs Announcement\n   * @param {Draggable} draggable - Draggable instance\n   */\n  constructor(draggable) {\n    super(draggable);\n\n    /**\n     * Plugin options\n     * @property options\n     * @type {Object}\n     */\n    this.options = _extends({}, defaultOptions, this.getOptions());\n\n    /**\n     * Original draggable trigger method. Hack until we have onAll or on('all')\n     * @property originalTriggerMethod\n     * @type {Function}\n     */\n    this.originalTriggerMethod = this.draggable.trigger;\n\n    this[onInitialize] = this[onInitialize].bind(this);\n    this[onDestroy] = this[onDestroy].bind(this);\n  }\n\n  /**\n   * Attaches listeners to draggable\n   */\n  attach() {\n    this.draggable.on('draggable:initialize', this[onInitialize]);\n  }\n\n  /**\n   * Detaches listeners from draggable\n   */\n  detach() {\n    this.draggable.off('draggable:destroy', this[onDestroy]);\n  }\n\n  /**\n   * Returns passed in options\n   */\n  getOptions() {\n    return this.draggable.options.announcements || {};\n  }\n\n  /**\n   * Announces event\n   * @private\n   * @param {AbstractEvent} event\n   */\n  [announceEvent](event) {\n    const message = this.options[event.type];\n\n    if (message && typeof message === 'string') {\n      this[announceMessage](message);\n    }\n\n    if (message && typeof message === 'function') {\n      this[announceMessage](message(event));\n    }\n  }\n\n  /**\n   * Announces message to screen reader\n   * @private\n   * @param {String} message\n   */\n  [announceMessage](message) {\n    announce(message, { expire: this.options.expire });\n  }\n\n  /**\n   * Initialize hander\n   * @private\n   */\n  [onInitialize]() {\n    // Hack until there is an api for listening for all events\n    this.draggable.trigger = event => {\n      try {\n        this[announceEvent](event);\n      } finally {\n        // Ensure that original trigger is called\n        this.originalTriggerMethod.call(this.draggable, event);\n      }\n    };\n  }\n\n  /**\n   * Destroy hander\n   * @private\n   */\n  [onDestroy]() {\n    this.draggable.trigger = this.originalTriggerMethod;\n  }\n}\n\nexports.default = Announcement; /**\n                                 * @const {HTMLElement} liveRegion\n                                 */\n\nconst liveRegion = createRegion();\n\n/**\n * Announces message via live region\n * @param {String} message\n * @param {Object} options\n * @param {Number} options.expire\n */\nfunction announce(message, { expire }) {\n  const element = document.createElement('div');\n\n  element.textContent = message;\n  liveRegion.appendChild(element);\n\n  return setTimeout(() => {\n    liveRegion.removeChild(element);\n  }, expire);\n}\n\n/**\n * Creates region element\n * @return {HTMLElement}\n */\nfunction createRegion() {\n  const element = document.createElement('div');\n\n  element.setAttribute('id', 'draggable-live-region');\n  element.setAttribute(ARIA_RELEVANT, 'additions');\n  element.setAttribute(ARIA_ATOMIC, 'true');\n  element.setAttribute(ARIA_LIVE, 'assertive');\n  element.setAttribute(ROLE, 'log');\n\n  element.style.position = 'fixed';\n  element.style.width = '1px';\n  element.style.height = '1px';\n  element.style.top = '-1px';\n  element.style.overflow = 'hidden';\n\n  return element;\n}\n\n// Append live region element as early as possible\ndocument.addEventListener('DOMContentLoaded', () => {\n  document.body.appendChild(liveRegion);\n});\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOptions = undefined;\n\nvar _Announcement = __webpack_require__(61);\n\nvar _Announcement2 = _interopRequireDefault(_Announcement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Announcement2.default;\nexports.defaultOptions = _Announcement.defaultOptions;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base draggable event\n * @class DraggableEvent\n * @module DraggableEvent\n * @extends AbstractEvent\n */\nclass DraggableEvent extends _AbstractEvent2.default {\n\n  /**\n   * Draggable instance\n   * @property draggable\n   * @type {Draggable}\n   * @readonly\n   */\n  get draggable() {\n    return this.data.draggable;\n  }\n}\n\nexports.DraggableEvent = DraggableEvent; /**\n                                          * Draggable initialized event\n                                          * @class DraggableInitializedEvent\n                                          * @module DraggableInitializedEvent\n                                          * @extends DraggableEvent\n                                          */\n\nDraggableEvent.type = 'draggable';\nclass DraggableInitializedEvent extends DraggableEvent {}\n\nexports.DraggableInitializedEvent = DraggableInitializedEvent; /**\n                                                                * Draggable destory event\n                                                                * @class DraggableInitializedEvent\n                                                                * @module DraggableDestroyEvent\n                                                                * @extends DraggableDestroyEvent\n                                                                */\n\nDraggableInitializedEvent.type = 'draggable:initialize';\nclass DraggableDestroyEvent extends DraggableEvent {}\nexports.DraggableDestroyEvent = DraggableDestroyEvent;\nDraggableDestroyEvent.type = 'draggable:destroy';\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nconst canceled = Symbol('canceled');\n\n/**\n * All events fired by draggable inherit this class. You can call `cancel()` to\n * cancel a specific event or you can check if an event has been canceled by\n * calling `canceled()`.\n * @abstract\n * @class AbstractEvent\n * @module AbstractEvent\n */\nclass AbstractEvent {\n\n  /**\n   * AbstractEvent constructor.\n   * @constructs AbstractEvent\n   * @param {object} data - Event data\n   */\n\n  /**\n   * Event type\n   * @static\n   * @abstract\n   * @property type\n   * @type {String}\n   */\n  constructor(data) {\n    this[canceled] = false;\n    this.data = data;\n  }\n\n  /**\n   * Read-only type\n   * @abstract\n   * @return {String}\n   */\n\n\n  /**\n   * Event cancelable\n   * @static\n   * @abstract\n   * @property cancelable\n   * @type {Boolean}\n   */\n  get type() {\n    return this.constructor.type;\n  }\n\n  /**\n   * Read-only cancelable\n   * @abstract\n   * @return {Boolean}\n   */\n  get cancelable() {\n    return this.constructor.cancelable;\n  }\n\n  /**\n   * Cancels the event instance\n   * @abstract\n   */\n  cancel() {\n    this[canceled] = true;\n  }\n\n  /**\n   * Check if event has been canceled\n   * @abstract\n   * @return {Boolean}\n   */\n  canceled() {\n    return Boolean(this[canceled]);\n  }\n\n  /**\n   * Returns new event instance with existing event data.\n   * This method allows for overriding of event data.\n   * @param {Object} data\n   * @return {AbstractEvent}\n   */\n  clone(data) {\n    return new this.constructor(_extends({}, this.data, data));\n  }\n}\nexports.default = AbstractEvent;\nAbstractEvent.type = 'event';\nAbstractEvent.cancelable = false;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Base drag event\n * @class DragEvent\n * @module DragEvent\n * @extends AbstractEvent\n */\nclass DragEvent extends _AbstractEvent2.default {\n\n  /**\n   * Draggables source element\n   * @property source\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get source() {\n    return this.data.source;\n  }\n\n  /**\n   * Draggables original source element\n   * @property originalSource\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get originalSource() {\n    return this.data.originalSource;\n  }\n\n  /**\n   * Draggables mirror element\n   * @property mirror\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get mirror() {\n    return this.data.mirror;\n  }\n\n  /**\n   * Draggables source container element\n   * @property sourceContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get sourceContainer() {\n    return this.data.sourceContainer;\n  }\n\n  /**\n   * Sensor event\n   * @property sensorEvent\n   * @type {SensorEvent}\n   * @readonly\n   */\n  get sensorEvent() {\n    return this.data.sensorEvent;\n  }\n\n  /**\n   * Original event that triggered sensor event\n   * @property originalEvent\n   * @type {Event}\n   * @readonly\n   */\n  get originalEvent() {\n    if (this.sensorEvent) {\n      return this.sensorEvent.originalEvent;\n    }\n\n    return null;\n  }\n}\n\nexports.DragEvent = DragEvent; /**\n                                * Drag start event\n                                * @class DragStartEvent\n                                * @module DragStartEvent\n                                * @extends DragEvent\n                                */\n\nDragEvent.type = 'drag';\nclass DragStartEvent extends DragEvent {}\n\nexports.DragStartEvent = DragStartEvent; /**\n                                          * Drag move event\n                                          * @class DragMoveEvent\n                                          * @module DragMoveEvent\n                                          * @extends DragEvent\n                                          */\n\nDragStartEvent.type = 'drag:start';\nDragStartEvent.cancelable = true;\nclass DragMoveEvent extends DragEvent {}\n\nexports.DragMoveEvent = DragMoveEvent; /**\n                                        * Drag over event\n                                        * @class DragOverEvent\n                                        * @module DragOverEvent\n                                        * @extends DragEvent\n                                        */\n\nDragMoveEvent.type = 'drag:move';\nclass DragOverEvent extends DragEvent {\n\n  /**\n   * Draggable container you are over\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.overContainer;\n  }\n\n  /**\n   * Draggable element you are over\n   * @property over\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get over() {\n    return this.data.over;\n  }\n}\n\nexports.DragOverEvent = DragOverEvent; /**\n                                        * Drag out event\n                                        * @class DragOutEvent\n                                        * @module DragOutEvent\n                                        * @extends DragEvent\n                                        */\n\nDragOverEvent.type = 'drag:over';\nDragOverEvent.cancelable = true;\nclass DragOutEvent extends DragEvent {\n\n  /**\n   * Draggable container you are over\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.overContainer;\n  }\n\n  /**\n   * Draggable element you left\n   * @property over\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get over() {\n    return this.data.over;\n  }\n}\n\nexports.DragOutEvent = DragOutEvent; /**\n                                      * Drag over container event\n                                      * @class DragOverContainerEvent\n                                      * @module DragOverContainerEvent\n                                      * @extends DragEvent\n                                      */\n\nDragOutEvent.type = 'drag:out';\nclass DragOverContainerEvent extends DragEvent {\n\n  /**\n   * Draggable container you are over\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.overContainer;\n  }\n}\n\nexports.DragOverContainerEvent = DragOverContainerEvent; /**\n                                                          * Drag out container event\n                                                          * @class DragOutContainerEvent\n                                                          * @module DragOutContainerEvent\n                                                          * @extends DragEvent\n                                                          */\n\nDragOverContainerEvent.type = 'drag:over:container';\nclass DragOutContainerEvent extends DragEvent {\n\n  /**\n   * Draggable container you left\n   * @property overContainer\n   * @type {HTMLElement}\n   * @readonly\n   */\n  get overContainer() {\n    return this.data.overContainer;\n  }\n}\n\nexports.DragOutContainerEvent = DragOutContainerEvent; /**\n                                                        * Drag pressure event\n                                                        * @class DragPressureEvent\n                                                        * @module DragPressureEvent\n                                                        * @extends DragEvent\n                                                        */\n\nDragOutContainerEvent.type = 'drag:out:container';\nclass DragPressureEvent extends DragEvent {\n\n  /**\n   * Pressure applied on draggable element\n   * @property pressure\n   * @type {Number}\n   * @readonly\n   */\n  get pressure() {\n    return this.data.pressure;\n  }\n}\n\nexports.DragPressureEvent = DragPressureEvent; /**\n                                                * Drag stop event\n                                                * @class DragStopEvent\n                                                * @module DragStopEvent\n                                                * @extends DragEvent\n                                                */\n\nDragPressureEvent.type = 'drag:pressure';\nclass DragStopEvent extends DragEvent {}\nexports.DragStopEvent = DragStopEvent;\nDragStopEvent.type = 'drag:stop';\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Plugins = exports.Sensors = exports.Sortable = exports.Swappable = exports.Droppable = exports.Draggable = exports.BasePlugin = exports.BaseEvent = undefined;\n\nvar _Draggable = __webpack_require__(5);\n\nObject.defineProperty(exports, 'Draggable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Draggable).default;\n  }\n});\n\nvar _Droppable = __webpack_require__(34);\n\nObject.defineProperty(exports, 'Droppable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Droppable).default;\n  }\n});\n\nvar _Swappable = __webpack_require__(31);\n\nObject.defineProperty(exports, 'Swappable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Swappable).default;\n  }\n});\n\nvar _Sortable = __webpack_require__(28);\n\nObject.defineProperty(exports, 'Sortable', {\n  enumerable: true,\n  get: function () {\n    return _interopRequireDefault(_Sortable).default;\n  }\n});\n\nvar _AbstractEvent = __webpack_require__(0);\n\nvar _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);\n\nvar _AbstractPlugin = __webpack_require__(1);\n\nvar _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);\n\nvar _Sensors = __webpack_require__(6);\n\nvar Sensors = _interopRequireWildcard(_Sensors);\n\nvar _Plugins = __webpack_require__(25);\n\nvar Plugins = _interopRequireWildcard(_Plugins);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.BaseEvent = _AbstractEvent2.default;\nexports.BasePlugin = _AbstractPlugin2.default;\nexports.Sensors = Sensors;\nexports.Plugins = Plugins;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvbGliL2RyYWdnYWJsZS5idW5kbGUuanM/NDY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkRyYWdnYWJsZVwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEcmFnZ2FibGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRHJhZ2dhYmxlXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjbG9zZXN0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvc2VzdCkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKS5kZWZhdWx0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuT2JqZWN0LmtleXMoX1NlbnNvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfU2Vuc29yRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfU2Vuc29yMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0RyYWdFdmVudFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5PYmplY3Qua2V5cyhfRHJhZ2dhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9EcmFnZ2FibGVFdmVudFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbk9iamVjdC5rZXlzKF9QbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfUGx1Z2luc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuT2JqZWN0LmtleXMoX1NlbnNvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9TZW5zb3JzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJhZ2dhYmxlMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NlbnNvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfTW91c2VTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNb3VzZVNlbnNvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Ub3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RvdWNoU2Vuc29yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX0RyYWdTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnU2Vuc29yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ1NlbnNvcikuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZvcmNlVG91Y2hTZW5zb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbk9iamVjdC5rZXlzKF9TZW5zb3JFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX1NlbnNvckV2ZW50W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG5PYmplY3Qua2V5cyhfU25hcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9TbmFwcGFibGVFdmVudFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9Db2xsaWRhYmxlRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuT2JqZWN0LmtleXMoX1NvcnRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9Tb3J0YWJsZUV2ZW50W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuT2JqZWN0LmtleXMoX1N3YXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfU3dhcHBhYmxlRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Ecm9wcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG5PYmplY3Qua2V5cyhfRHJvcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9Ecm9wcGFibGVFdmVudFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fubm91bmNlbWVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRBbm5vdW5jZW1lbnRPcHRpb25zJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcbiAgfVxufSk7XG5cbnZhciBfRm9jdXNhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRm9jdXNhYmxlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNaXJyb3InLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0TWlycm9yT3B0aW9ucycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XG4gIH1cbn0pO1xuXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTY3JvbGxhYmxlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTY3JvbGxhYmxlT3B0aW9ucycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xuICB9XG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cbk9iamVjdC5rZXlzKF9EcmFnZ2FibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfRHJhZ0V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbk9iamVjdC5rZXlzKF9EcmFnRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25Tb3J0YWJsZVNvcnRlZCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnRlZCcpO1xuXG4vKipcbiAqIFN3YXBBbmltYXRpb24gZGVmYXVsdCBvcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRPcHRpb25zLmVhc2luZ0Z1bmN0aW9uXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLmhvcml6b250YWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHVyYXRpb246IDE1MCxcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXG4gIGhvcml6b250YWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIFN3YXBBbmltYXRpb24gcGx1Z2luIGFkZHMgc3dhcCBhbmltYXRpb25zIGZvciBzb3J0YWJsZVxuICogQGNsYXNzIFN3YXBBbmltYXRpb25cbiAqIEBtb2R1bGUgU3dhcEFuaW1hdGlvblxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cbiAqL1xuY2xhc3MgU3dhcEFuaW1hdGlvbiBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBTd2FwQW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBTd2FwQW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICAvKipcbiAgICAgKiBTd2FwQW5pbWF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZWZhdWx0T3B0aW9ucy5lYXNpbmdGdW5jdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XG5cbiAgICAvKipcbiAgICAgKiBMYXN0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblxuICAgIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0gPSB0aGlzW29uU29ydGFibGVTb3J0ZWRdLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ3NvcnRhYmxlOnNvcnRlZCcsIHRoaXNbb25Tb3J0YWJsZVNvcnRlZF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRhYmxlIHNvcnRlZCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7U29ydGFibGVTb3J0ZWRFdmVudH0gc29ydGFibGVFdmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uU29ydGFibGVTb3J0ZWRdKHsgb2xkSW5kZXgsIG5ld0luZGV4LCBkcmFnRXZlbnQgfSkge1xuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyIH0gPSBkcmFnRXZlbnQ7XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxhc3RBbmltYXRpb25GcmFtZSk7XG5cbiAgICAvLyBDYW4gYmUgZG9uZSBpbiBhIHNlcGFyYXRlIGZyYW1lXG4gICAgdGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKG9sZEluZGV4ID49IG5ld0luZGV4KSB7XG4gICAgICAgIGFuaW1hdGUoc291cmNlLCBvdmVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0ZShvdmVyLCBzb3VyY2UsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcEFuaW1hdGlvbjsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0d28gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbmZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHsgZHVyYXRpb24sIGVhc2luZ0Z1bmN0aW9uLCBob3Jpem9udGFsIH0pIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIH1cblxuICBpZiAoaG9yaXpvbnRhbCkge1xuICAgIGNvbnN0IHdpZHRoID0gZnJvbS5vZmZzZXRXaWR0aDtcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3dpZHRofXB4LCAwLCAwKWA7XG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKC0ke3dpZHRofXB4LCAwLCAwKWA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gZnJvbS5vZmZzZXRIZWlnaHQ7XG4gICAgZnJvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgJHtoZWlnaHR9cHgsIDApYDtcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgLSR7aGVpZ2h0fXB4LCAwKWA7XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xuICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gYHRyYW5zZm9ybSAke2R1cmF0aW9ufW1zICR7ZWFzaW5nRnVuY3Rpb259YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXNldHMgYW5pbWF0aW9uIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCByZXNldEVsZW1lbnRPblRyYW5zaXRpb25FbmQpO1xufVxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xuXG52YXIgX1N3YXBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9Td2FwQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfU3dhcEFuaW1hdGlvbjIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XG5cbnZhciBfU25hcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcbmNvbnN0IG9uRHJhZ091dCA9IFN5bWJvbCgnb25EcmFnT3V0Jyk7XG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xuY29uc3Qgb25NaXJyb3JEZXN0cm95ID0gU3ltYm9sKCdvbk1pcnJvckRlc3Ryb3knKTtcblxuLyoqXG4gKiBTbmFwcGFibGUgcGx1Z2luIHdoaWNoIHNuYXBzIGRyYWdnYWJsZSBlbGVtZW50cyBpbnRvIHBsYWNlXG4gKiBAY2xhc3MgU25hcHBhYmxlXG4gKiBAbW9kdWxlIFNuYXBwYWJsZVxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cbiAqL1xuY2xhc3MgU25hcHBhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIFNuYXBwYWJsZSBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgU25hcHBhYmxlXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xuICAgIHN1cGVyKGRyYWdnYWJsZSk7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgZmlyc3Qgc291cmNlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGZpcnN0U291cmNlXG4gICAgICovXG4gICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgbWlycm9yIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBtaXJyb3JcbiAgICAgKi9cbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG5cbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3V0XSA9IHRoaXNbb25EcmFnT3V0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JEZXN0cm95XSA9IHRoaXNbb25NaXJyb3JEZXN0cm95XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9mZignZHJvcHBhYmxlOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2Ryb3BwYWJsZTpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOmRlc3Ryb3knLCB0aGlzW29uTWlycm9yRGVzdHJveV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBldmVudC5zb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxuICAgKi9cbiAgW29uRHJhZ1N0b3BdKCkge1xuICAgIHRoaXMuZmlyc3RTb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RHJhZ092ZXJFdmVudHxEcm9wcGFibGVPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XG4gICAqL1xuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdGhpcy5maXJzdFNvdXJjZSkge1xuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc25hcEluRXZlbnQgPSBuZXcgX1NuYXBwYWJsZUV2ZW50LlNuYXBJbkV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcblxuICAgIGlmIChzbmFwSW5FdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWlycm9yKSB7XG4gICAgICB0aGlzLm1pcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZUZvcignc291cmNlOmRyYWdnaW5nJykpO1xuICAgIHNvdXJjZS5jbGFzc0xpc3QuYWRkKHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZUZvcignc291cmNlOnBsYWNlZCcpKTtcblxuICAgIC8vIE5lZWQgdG8gY2FuY2VsIHRoaXMgaW4gZHJhZyBvdXRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZUZvcignc291cmNlOnBsYWNlZCcpKTtcbiAgICB9LCB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnBsYWNlZFRpbWVvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgb3V0IGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnT3V0RXZlbnR8RHJvcHBhYmxlT3V0RXZlbnR9IGV2ZW50IC0gRHJhZyBvdXQgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdPdXRdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuZHJhZ0V2ZW50LnNvdXJjZTtcblxuICAgIGNvbnN0IHNuYXBPdXRFdmVudCA9IG5ldyBfU25hcHBhYmxlRXZlbnQuU25hcE91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XG5cbiAgICBpZiAoc25hcE91dEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taXJyb3IpIHtcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG5cbiAgICBzb3VyY2UuY2xhc3NMaXN0LmFkZCh0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IgfSkge1xuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pcnJvciBkZXN0cm95IGhhbmRsZXJcbiAgICogQHBhcmFtIHtNaXJyb3JEZXN0cm95RXZlbnR9IG1pcnJvckV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNuYXBwYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TbmFwT3V0RXZlbnQgPSBleHBvcnRzLlNuYXBJbkV2ZW50ID0gZXhwb3J0cy5TbmFwRXZlbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCYXNlIHNuYXAgZXZlbnRcbiAqIEBjbGFzcyBTbmFwRXZlbnRcbiAqIEBtb2R1bGUgU25hcEV2ZW50XG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XG4gKi9cbmNsYXNzIFNuYXBFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcblxuICAvKipcbiAgICogRHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHNuYXAgZXZlbnRcbiAgICogQHByb3BlcnR5IGRyYWdFdmVudFxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkcmFnRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogU25hcHBhYmxlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHNuYXBwYWJsZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNuYXBwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNuYXBwYWJsZTtcbiAgfVxufVxuXG5leHBvcnRzLlNuYXBFdmVudCA9IFNuYXBFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU25hcCBpbiBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTbmFwSW5FdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU25hcEluRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTbmFwRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU25hcEV2ZW50LnR5cGUgPSAnc25hcCc7XG5jbGFzcyBTbmFwSW5FdmVudCBleHRlbmRzIFNuYXBFdmVudCB7fVxuXG5leHBvcnRzLlNuYXBJbkV2ZW50ID0gU25hcEluRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTbmFwIG91dCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU25hcE91dEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU25hcE91dEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNuYXBFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU25hcEluRXZlbnQudHlwZSA9ICdzbmFwOmluJztcblNuYXBJbkV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgU25hcE91dEV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IFNuYXBPdXRFdmVudDtcblNuYXBPdXRFdmVudC50eXBlID0gJ3NuYXA6b3V0JztcblNuYXBPdXRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NuYXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuT2JqZWN0LmtleXMoX1NuYXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfU25hcHBhYmxlRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfU25hcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfU25hcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NuYXBwYWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9TbmFwcGFibGUyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IFN5bWJvbCgnb25NaXJyb3JDcmVhdGVkJyk7XG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3QgcmVzaXplID0gU3ltYm9sKCdyZXNpemUnKTtcblxuLyoqXG4gKiBSZXNpemVNaXJyb3IgZGVmYXVsdCBvcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIFRoZSBSZXNpemVNaXJyb3IgcGx1Z2luIHJlc2l6ZXMgdGhlIG1pcnJvciBlbGVtZW50IHRvIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB0aGF0IHRoZSBtaXJyb3IgaXMgaG92ZXJpbmcgb3ZlclxuICogQGNsYXNzIFJlc2l6ZU1pcnJvclxuICogQG1vZHVsZSBSZXNpemVNaXJyb3JcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXG4gKi9cbmNsYXNzIFJlc2l6ZU1pcnJvciBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBSZXNpemVNaXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RzIFJlc2l6ZU1pcnJvclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplTWlycm9yIG9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVNaXJyb3IgcmVtZW1iZXJzIHRoZSBsYXN0IHdpZHRoIHdoZW4gcmVzaXppbmcgdGhlIG1pcnJvclxuICAgICAqIHRvIGF2b2lkIGFkZGl0aW9uYWwgd3JpdGVzIHRvIHRoZSBET01cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGFzdFdpZHRoXG4gICAgICovXG4gICAgdGhpcy5sYXN0V2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplTWlycm9yIHJlbWVtYmVycyB0aGUgbGFzdCBoZWlnaHQgd2hlbiByZXNpemluZyB0aGUgbWlycm9yXG4gICAgICogdG8gYXZvaWQgYWRkaXRpb25hbCB3cml0ZXMgdG8gdGhlIERPTVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0SGVpZ2h0XG4gICAgICovXG4gICAgdGhpcy5sYXN0SGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IG1pcnJvclxuICAgICAqL1xuICAgIHRoaXMubWlycm9yID0gbnVsbDtcblxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25NaXJyb3JEZXN0cm95XSA9IHRoaXNbb25NaXJyb3JEZXN0cm95XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdmVyOmNvbnRhaW5lcicsIHRoaXNbb25EcmFnT3Zlcl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucmVzaXplTWlycm9yIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1pcnJvciBjcmVhdGVkIGhhbmRsZXJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25NaXJyb3JDcmVhdGVkXSh7IG1pcnJvciB9KSB7XG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogTWlycm9yIGRlc3Ryb3kgaGFuZGxlclxuICAgKiBAcGFyYW0ge01pcnJvckRlc3Ryb3lFdmVudH0gbWlycm9yRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtvbk1pcnJvckRlc3Ryb3ldKCkge1xuICAgIHRoaXMubWlycm9yID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25EcmFnT3Zlcl0oZHJhZ0V2ZW50KSB7XG4gICAgdGhpc1tyZXNpemVdKGRyYWdFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGZ1bmN0aW9uIGZvclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbcmVzaXplXSh7IG92ZXJDb250YWluZXIsIG92ZXIgfSkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5taXJyb3IucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcikge1xuICAgICAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xuXG4gICAgICBpZiAoIW92ZXJFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgKDAsIF91dGlscy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG92ZXJSZWN0ID0gb3ZlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdEhlaWdodCA9PT0gb3ZlclJlY3QuaGVpZ2h0ICYmIHRoaXMubGFzdFdpZHRoID09PSBvdmVyUmVjdC53aWR0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWlycm9yLnN0eWxlLndpZHRoID0gYCR7b3ZlclJlY3Qud2lkdGh9cHhgO1xuICAgICAgICB0aGlzLm1pcnJvci5zdHlsZS5oZWlnaHQgPSBgJHtvdmVyUmVjdC5oZWlnaHR9cHhgO1xuXG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IG92ZXJSZWN0LmhlaWdodDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZXNpemVNaXJyb3I7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfUmVzaXplTWlycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9SZXNpemVNaXJyb3IyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XG5cbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX0NvbGxpZGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gU3ltYm9sKCdvblJlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4vKipcbiAqIENvbGxpZGFibGUgcGx1Z2luIHdoaWNoIGRldGVjdHMgY29sbGlkaW5nIGVsZW1lbnRzIHdoaWxlIGRyYWdnaW5nXG4gKiBAY2xhc3MgQ29sbGlkYWJsZVxuICogQG1vZHVsZSBDb2xsaWRhYmxlXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuICovXG5jbGFzcyBDb2xsaWRhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIENvbGxpZGFibGUgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RzIENvbGxpZGFibGVcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIGN1cnJlbnRseSBjb2xsaWRpbmcgZWxlbWVudHNcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGNvbGxpZGluZyBlbGVtZW50c1xuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8bnVsbH0gbGFzdENvbGxpZGluZ0VsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBmb3IgZmluZGluZyBjb2xsaWRpbmcgZWxlbWVudHNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxudWxsfSBjdXJyZW50QW5pbWF0aW9uRnJhbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdID0gdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IGNvbGxpZGFibGVzIGJhc2VkIG9uIGBjb2xsaWRhYmxlc2Agb3B0aW9uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXRDb2xsaWRhYmxlcygpIHtcbiAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuY29sbGlkYWJsZXM7XG5cbiAgICBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY29sbGlkYWJsZXMpKTtcbiAgICB9IGVsc2UgaWYgKGNvbGxpZGFibGVzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbGxpZGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKGNvbGxpZGFibGVzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBbY29sbGlkYWJsZXNdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY29sbGlkYWJsZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGV2ZW50IC0gRHJhZyBtb3ZlIGV2ZW50XG4gICAqL1xuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5zZW5zb3JFdmVudC50YXJnZXQ7XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpKTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbGxpZGFibGVJbkV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZUluRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudFxuICAgIH0pO1xuXG4gICAgY29uc3QgY29sbGlkYWJsZU91dEV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZU91dEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50XG4gICAgfSk7XG5cbiAgICBjb25zdCBlbnRlcmluZ0NvbGxpZGFibGUgPSBCb29sZWFuKHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50ICE9PSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQpO1xuICAgIGNvbnN0IGxlYXZpbmdDb2xsaWRhYmxlID0gQm9vbGVhbighdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpO1xuXG4gICAgaWYgKGVudGVyaW5nQ29sbGlkYWJsZSkge1xuICAgICAgaWYgKHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVJbkV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGxlYXZpbmdDb2xsaWRhYmxlKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVPdXRFdmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudCA9IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XG4gICAqL1xuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBsYXN0Q29sbGlkaW5nRWxlbWVudCA9IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCB8fCB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50O1xuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY29sbGlkaW5nRWxlbWVudDogbGFzdENvbGxpZGluZ0VsZW1lbnRcbiAgICB9KTtcblxuICAgIGlmIChsYXN0Q29sbGlkaW5nRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0aW9uIGZyYW1lIGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEN1cnJlbnQgbW92ZSB0YXJnZXRcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdKHRhcmdldCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZ2V0Q29sbGlkYWJsZXMoKTtcbiAgICAgIHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCBlbGVtZW50ID0+IGNvbGxpZGFibGVzLmluY2x1ZGVzKGVsZW1lbnQpKTtcbiAgICB9O1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsaWRhYmxlO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbGxpZGFibGVPdXRFdmVudCA9IGV4cG9ydHMuQ29sbGlkYWJsZUluRXZlbnQgPSBleHBvcnRzLkNvbGxpZGFibGVFdmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJhc2UgY29sbGlkYWJsZSBldmVudFxuICogQGNsYXNzIENvbGxpZGFibGVFdmVudFxuICogQG1vZHVsZSBDb2xsaWRhYmxlRXZlbnRcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcbiAqL1xuY2xhc3MgQ29sbGlkYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBEcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29sbGlhYmxlIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcbiAgICogQHR5cGUge0RyYWdFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuQ29sbGlkYWJsZUV2ZW50ID0gQ29sbGlkYWJsZUV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb2xsaWRhYmxlIGluIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIENvbGxpZGFibGVJbkV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlSW5FdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIENvbGxpZGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcbmNsYXNzIENvbGxpZGFibGVJbkV2ZW50IGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50IHtcblxuICAvKipcbiAgICogRWxlbWVudCB5b3UgYXJlIGN1cnJlbnRseSBjb2xsaWRpbmcgd2l0aFxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNvbGxpZGluZ0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb2xsaWRpbmdFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydHMuQ29sbGlkYWJsZUluRXZlbnQgPSBDb2xsaWRhYmxlSW5FdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgb3V0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBDb2xsaWRhYmxlT3V0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBDb2xsaWRhYmxlT3V0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Db2xsaWRhYmxlSW5FdmVudC50eXBlID0gJ2NvbGxpZGFibGU6aW4nO1xuY2xhc3MgQ29sbGlkYWJsZU91dEV2ZW50IGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50IHtcblxuICAvKipcbiAgICogRWxlbWVudCB5b3Ugd2VyZSBwcmV2aW91c2x5IGNvbGxpZGluZyB3aXRoXG4gICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdFbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XG4gIH1cbn1cbmV4cG9ydHMuQ29sbGlkYWJsZU91dEV2ZW50ID0gQ29sbGlkYWJsZU91dEV2ZW50O1xuQ29sbGlkYWJsZU91dEV2ZW50LnR5cGUgPSAnY29sbGlkYWJsZTpvdXQnO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuT2JqZWN0LmtleXMoX0NvbGxpZGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0NvbGxpZGFibGVFdmVudFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBfQ29sbGlkYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db2xsaWRhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbGxpZGFibGUyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ29sbGlkYWJsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxpZGFibGUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1Jlc2l6ZU1pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Jlc2l6ZU1pcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcikuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRSZXNpemVNaXJyb3JPcHRpb25zJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcbiAgfVxufSk7XG5cbnZhciBfU25hcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU25hcHBhYmxlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Td2FwQW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcEFuaW1hdGlvbicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U3dhcEFuaW1hdGlvbk9wdGlvbnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xuXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ092ZXJDb250YWluZXIgPSBTeW1ib2woJ29uRHJhZ092ZXJDb250YWluZXInKTtcbmNvbnN0IG9uRHJhZ092ZXIgPSBTeW1ib2woJ29uRHJhZ092ZXInKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFubm91bmNlbWVudCBtZXNzYWdlIHdoZW4gYSBEcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBzb3J0ZWQgd2l0aCBhbm90aGVyIERyYWdnYWJsZSBlbGVtZW50XG4gKiBvciBtb3ZlZCBpbnRvIGEgbmV3IGNvbnRhaW5lclxuICogQHBhcmFtIHtTb3J0YWJsZVNvcnRlZEV2ZW50fSBzb3J0YWJsZUV2ZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uU29ydGFibGVTb3J0ZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50IH0pIHtcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ3NvcnRhYmxlIGVsZW1lbnQnO1xuXG4gIGlmIChkcmFnRXZlbnQub3Zlcikge1xuICAgIGNvbnN0IG92ZXJUZXh0ID0gZHJhZ0V2ZW50Lm92ZXIudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5vdmVyLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IGRyYWdFdmVudC5zb3VyY2UuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZHJhZ0V2ZW50Lm92ZXIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG5cbiAgICBpZiAoaXNGb2xsb3dpbmcpIHtcbiAgICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gYWZ0ZXIgJHtvdmVyVGV4dH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGJlZm9yZSAke292ZXJUZXh0fWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBob3cgdG8gY29tcHV0ZSBjb250YWluZXIgbmFtZVxuICAgIHJldHVybiBgUGxhY2VkICR7c291cmNlVGV4dH0gaW50byBhIGRpZmZlcmVudCBjb250YWluZXJgO1xuICB9XG59XG5cbi8qKlxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snc29ydGFibGU6c29ydGVkJ11cbiAqL1xuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gICdzb3J0YWJsZTpzb3J0ZWQnOiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudFxufTtcblxuLyoqXG4gKiBTb3J0YWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3Mgc29ydGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuIFNvcnRhYmxlIHdpbGwga2VlcFxuICogdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGluZGV4IGFuZCBlbWl0cyB0aGUgbmV3IGluZGV4IGFzIHlvdSBkcmFnIG92ZXIgZHJhZ2dhYmxlIGVsZW1lbnRzLlxuICogQGNsYXNzIFNvcnRhYmxlXG4gKiBAbW9kdWxlIFNvcnRhYmxlXG4gKiBAZXh0ZW5kcyBEcmFnZ2FibGVcbiAqL1xuY2xhc3MgU29ydGFibGUgZXh0ZW5kcyBfRHJhZ2dhYmxlMi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIFNvcnRhYmxlIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBTb3J0YWJsZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBTb3J0YWJsZSBjb250YWluZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgU29ydGFibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIHN0YXJ0IGluZGV4IG9mIHNvdXJjZSBvbiBkcmFnIHN0YXJ0XG4gICAgICogQHByb3BlcnR5IHN0YXJ0SW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBzdGFydCBjb250YWluZXIgb24gZHJhZyBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XG5cbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSA9IHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBTb3J0YWJsZSBpbnN0YW5jZS5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSkub2ZmKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpbmRleCBvZiBlbGVtZW50IHdpdGhpbiBpdHMgY29udGFpbmVyIGR1cmluZyBkcmFnIG9wZXJhdGlvbiwgaS5lLiBleGNsdWRpbmcgbWlycm9yIGFuZCBvcmlnaW5hbCBzb3VyY2VcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgaW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKGVsZW1lbnQucGFyZW50Tm9kZSkuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XG4gICAqL1xuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IGV2ZW50LnNvdXJjZS5wYXJlbnROb2RlO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuaW5kZXgoZXZlbnQuc291cmNlKTtcblxuICAgIGNvbnN0IHNvcnRhYmxlU3RhcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgIHN0YXJ0Q29udGFpbmVyOiB0aGlzLnN0YXJ0Q29udGFpbmVyXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdGFydEV2ZW50KTtcblxuICAgIGlmIChzb3J0YWJsZVN0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgZXZlbnQuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgb3ZlciBjb250YWluZXIgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdPdmVyQ29udGFpbmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGNvbnRhaW5lciBldmVudFxuICAgKi9cbiAgW29uRHJhZ092ZXJDb250YWluZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciB9ID0gZXZlbnQ7XG4gICAgY29uc3Qgb2xkSW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XG5cbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVNvcnRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgY3VycmVudEluZGV4OiBvbGRJbmRleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIG92ZXJcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRFdmVudCk7XG5cbiAgICBpZiAoc29ydGFibGVTb3J0RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihvdmVyQ29udGFpbmVyKTtcbiAgICBjb25zdCBtb3ZlcyA9IG1vdmUoeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIsIGNoaWxkcmVuIH0pO1xuXG4gICAgaWYgKCFtb3Zlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb2xkQ29udGFpbmVyLCBuZXdDb250YWluZXIgfSA9IG1vdmVzO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xuXG4gICAgY29uc3Qgc29ydGFibGVTb3J0ZWRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVNvcnRlZEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBvbGRJbmRleCxcbiAgICAgIG5ld0luZGV4LFxuICAgICAgb2xkQ29udGFpbmVyLFxuICAgICAgbmV3Q29udGFpbmVyXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTb3J0ZWRFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxuICAgKi9cbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm92ZXIgPT09IGV2ZW50Lm9yaWdpbmFsU291cmNlIHx8IGV2ZW50Lm92ZXIgPT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyIH0gPSBldmVudDtcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcblxuICAgIGNvbnN0IHNvcnRhYmxlU29ydEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXG4gICAgICBjdXJyZW50SW5kZXg6IG9sZEluZGV4LFxuICAgICAgc291cmNlLFxuICAgICAgb3ZlclxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydEV2ZW50KTtcblxuICAgIGlmIChzb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xuICAgIGNvbnN0IG1vdmVzID0gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSk7XG5cbiAgICBpZiAoIW1vdmVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lciB9ID0gbW92ZXM7XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLmluZGV4KHNvdXJjZSk7XG5cbiAgICBjb25zdCBzb3J0YWJsZVNvcnRlZEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU29ydGVkRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIG9sZEluZGV4LFxuICAgICAgbmV3SW5kZXgsXG4gICAgICBvbGRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXJcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XG4gICAqL1xuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBzb3J0YWJsZVN0b3BFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb2xkSW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcbiAgICAgIG5ld0luZGV4OiB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSksXG4gICAgICBvbGRDb250YWluZXI6IHRoaXMuc3RhcnRDb250YWluZXIsXG4gICAgICBuZXdDb250YWluZXI6IGV2ZW50LnNvdXJjZS5wYXJlbnROb2RlXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoc29ydGFibGVTdG9wRXZlbnQpO1xuXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBTb3J0YWJsZTtcbmZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkcmVuLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gbW92ZSh7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciwgY2hpbGRyZW4gfSkge1xuICBjb25zdCBlbXB0eU92ZXJDb250YWluZXIgPSAhY2hpbGRyZW4ubGVuZ3RoO1xuICBjb25zdCBkaWZmZXJlbnRDb250YWluZXIgPSBzb3VyY2UucGFyZW50Tm9kZSAhPT0gb3ZlckNvbnRhaW5lcjtcbiAgY29uc3Qgc2FtZUNvbnRhaW5lciA9IG92ZXIgJiYgIWRpZmZlcmVudENvbnRhaW5lcjtcblxuICBpZiAoZW1wdHlPdmVyQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2UgaWYgKHNhbWVDb250YWluZXIpIHtcbiAgICByZXR1cm4gbW92ZVdpdGhpbkNvbnRhaW5lcihzb3VyY2UsIG92ZXIpO1xuICB9IGVsc2UgaWYgKGRpZmZlcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpIHtcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XG5cbiAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xuXG4gIHJldHVybiB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyOiBvdmVyQ29udGFpbmVyIH07XG59XG5cbmZ1bmN0aW9uIG1vdmVXaXRoaW5Db250YWluZXIoc291cmNlLCBvdmVyKSB7XG4gIGNvbnN0IG9sZEluZGV4ID0gaW5kZXgoc291cmNlKTtcbiAgY29uc3QgbmV3SW5kZXggPSBpbmRleChvdmVyKTtcblxuICBpZiAob2xkSW5kZXggPCBuZXdJbmRleCkge1xuICAgIHNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcbiAgfVxuXG4gIHJldHVybiB7IG9sZENvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcbn1cblxuZnVuY3Rpb24gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKSB7XG4gIGNvbnN0IG9sZENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlO1xuXG4gIGlmIChvdmVyKSB7XG4gICAgb3Zlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBwcm9wZXIgcG9zaXRpb25cbiAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNvdXJjZSk7XG4gIH1cblxuICByZXR1cm4geyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Tb3J0YWJsZVN0b3BFdmVudCA9IGV4cG9ydHMuU29ydGFibGVTb3J0ZWRFdmVudCA9IGV4cG9ydHMuU29ydGFibGVTb3J0RXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuU29ydGFibGVFdmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJhc2Ugc29ydGFibGUgZXZlbnRcbiAqIEBjbGFzcyBTb3J0YWJsZUV2ZW50XG4gKiBAbW9kdWxlIFNvcnRhYmxlRXZlbnRcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcbiAqL1xuY2xhc3MgU29ydGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcblxuICAvKipcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHNvcnRhYmxlIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcbiAgICogQHR5cGUge0RyYWdFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuU29ydGFibGVFdmVudCA9IFNvcnRhYmxlRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc3RhcnQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVN0YXJ0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU29ydGFibGVTdGFydEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU29ydGFibGVFdmVudC50eXBlID0gJ3NvcnRhYmxlJztcbmNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIC8qKlxuICAgKiBTdGFydCBpbmRleCBvZiBzb3VyY2Ugb24gc29ydGFibGUgc3RhcnRcbiAgICogQHByb3BlcnR5IHN0YXJ0SW5kZXhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc3RhcnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgY29udGFpbmVyIG9uIHNvcnRhYmxlIHN0YXJ0XG4gICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHN0YXJ0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnRDb250YWluZXI7XG4gIH1cbn1cblxuZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBTb3J0YWJsZVN0YXJ0RXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHNvcnQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU29ydGFibGVTb3J0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Tb3J0YWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdGFydCc7XG5Tb3J0YWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBjdXJyZW50IGRyYWdnYWJsZSBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBjdXJyZW50SW5kZXhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY3VycmVudEluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgaG92ZXJpbmcgb3ZlclxuICAgKiBAcHJvcGVydHkgb3ZlclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xuICB9XG59XG5cbmV4cG9ydHMuU29ydGFibGVTb3J0RXZlbnQgPSBTb3J0YWJsZVNvcnRFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHNvcnRlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydGVkRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU29ydGFibGVTb3J0RXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0JztcblNvcnRhYmxlU29ydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBsYXN0IHNvcnRlZCBldmVudFxuICAgKiBAcHJvcGVydHkgb2xkSW5kZXhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb2xkSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBOZXcgaW5kZXggb2YgdGhpcyBzb3J0ZWQgZXZlbnRcbiAgICogQHByb3BlcnR5IG5ld0luZGV4XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5ld0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogT2xkIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb2xkQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IG5ld0NvbnRhaW5lclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcbiAgfVxufVxuXG5leHBvcnRzLlNvcnRhYmxlU29ydGVkRXZlbnQgPSBTb3J0YWJsZVNvcnRlZEV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRhYmxlIHN0b3AgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVN0b3BFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTb3J0YWJsZVN0b3BFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU29ydGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblNvcnRhYmxlU29ydGVkRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzb3J0ZWQnO1xuY2xhc3MgU29ydGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcblxuICAvKipcbiAgICogT3JpZ2luYWwgaW5kZXggb24gc29ydGFibGUgc3RhcnRcbiAgICogQHByb3BlcnR5IG9sZEluZGV4XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG9sZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkSW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogTmV3IGluZGV4IG9mIGRyYWdnYWJsZSBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBuZXdJbmRleFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXdJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0luZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIE9yaWdpbmFsIGNvbnRhaW5lciBvZiBkcmFnZ2FibGUgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb2xkQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub2xkQ29udGFpbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IG5ld0NvbnRhaW5lclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5ld0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcbiAgfVxufVxuZXhwb3J0cy5Tb3J0YWJsZVN0b3BFdmVudCA9IFNvcnRhYmxlU3RvcEV2ZW50O1xuU29ydGFibGVTdG9wRXZlbnQudHlwZSA9ICdzb3J0YWJsZTpzdG9wJztcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NvcnRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5PYmplY3Qua2V5cyhfU29ydGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX1NvcnRhYmxlRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfU29ydGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIF9Tb3J0YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9Tb3J0YWJsZTIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfRHJhZ2dhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSk7XG5cbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XG5cbi8qKlxuICogUmV0dXJucyBhbiBhbm5vdW5jZW1lbnQgbWVzc2FnZSB3aGVuIHRoZSBEcmFnZ2FibGUgZWxlbWVudCBpcyBzd2FwcGVkIHdpdGggYW5vdGhlciBkcmFnZ2FibGUgZWxlbWVudFxuICogQHBhcmFtIHtTd2FwcGFibGVTd2FwcGVkRXZlbnR9IHN3YXBwYWJsZUV2ZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIHN3YXBwZWRFbGVtZW50IH0pIHtcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ3N3YXBwYWJsZSBlbGVtZW50JztcbiAgY29uc3Qgb3ZlclRleHQgPSBzd2FwcGVkRWxlbWVudC50ZXh0Q29udGVudC50cmltKCkgfHwgc3dhcHBlZEVsZW1lbnQuaWQgfHwgJ3N3YXBwYWJsZSBlbGVtZW50JztcblxuICByZXR1cm4gYFN3YXBwZWQgJHtzb3VyY2VUZXh0fSB3aXRoICR7b3ZlclRleHR9YDtcbn1cblxuLyoqXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydzd2FwcGFibGVkOnN3YXBwZWQnXVxuICovXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcbiAgJ3N3YXBwYWJsZWQ6c3dhcHBlZCc6IG9uU3dhcHBhYmxlU3dhcHBlZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5cbi8qKlxuICogU3dhcHBhYmxlIGlzIGJ1aWx0IG9uIHRvcCBvZiBEcmFnZ2FibGUgYW5kIGFsbG93cyBzd2FwcGluZyBvZiBkcmFnZ2FibGUgZWxlbWVudHMuXG4gKiBPcmRlciBpcyBpcnJlbGV2YW50IHRvIFN3YXBwYWJsZS5cbiAqIEBjbGFzcyBTd2FwcGFibGVcbiAqIEBtb2R1bGUgU3dhcHBhYmxlXG4gKiBAZXh0ZW5kcyBEcmFnZ2FibGVcbiAqL1xuY2xhc3MgU3dhcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBTd2FwcGFibGUgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBwYWJsZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBTd2FwcGFibGUgY29udGFpbmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIFN3YXBwYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogTGFzdCBkcmFnZ2FibGUgZWxlbWVudCB0aGF0IHdhcyBkcmFnZ2VkIG92ZXJcbiAgICAgKiBAcHJvcGVydHkgbGFzdE92ZXJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0T3ZlciA9IG51bGw7XG5cbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIFN3YXBwYWJsZSBpbnN0YW5jZS5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCkub2ZmKCdkcmFnOm92ZXInLCB0aGlzLl9vbkRyYWdPdmVyKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXMuX29uRHJhZ1N0b3ApO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBjb25zdCBzd2FwcGFibGVTdGFydEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTdGFydEV2ZW50KHtcbiAgICAgIGRyYWdFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTdGFydEV2ZW50KTtcblxuICAgIGlmIChzd2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XG4gICAqL1xuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzd2FwcGFibGVTd2FwRXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN3YXBFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgb3ZlcjogZXZlbnQub3ZlcixcbiAgICAgIG92ZXJDb250YWluZXI6IGV2ZW50Lm92ZXJDb250YWluZXJcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwRXZlbnQpO1xuXG4gICAgaWYgKHN3YXBwYWJsZVN3YXBFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3dhcCBvcmlnaW5hbGx5IHN3YXBwZWQgZWxlbWVudCBiYWNrXG4gICAgaWYgKHRoaXMubGFzdE92ZXIgJiYgdGhpcy5sYXN0T3ZlciAhPT0gZXZlbnQub3Zlcikge1xuICAgICAgc3dhcCh0aGlzLmxhc3RPdmVyLCBldmVudC5zb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxhc3RPdmVyID09PSBldmVudC5vdmVyKSB7XG4gICAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0T3ZlciA9IGV2ZW50Lm92ZXI7XG4gICAgfVxuXG4gICAgc3dhcChldmVudC5zb3VyY2UsIGV2ZW50Lm92ZXIpO1xuXG4gICAgY29uc3Qgc3dhcHBhYmxlU3dhcHBlZEV2ZW50ID0gbmV3IF9Td2FwcGFibGVFdmVudC5Td2FwcGFibGVTd2FwcGVkRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIHN3YXBwZWRFbGVtZW50OiBldmVudC5vdmVyXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3dhcHBlZEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XG4gICAqL1xuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcbiAgICBjb25zdCBzd2FwcGFibGVTdG9wRXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN0b3BFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3RvcEV2ZW50KTtcbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBTd2FwcGFibGU7XG5mdW5jdGlvbiB3aXRoVGVtcEVsZW1lbnQoY2FsbGJhY2spIHtcbiAgY29uc3QgdG1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjYWxsYmFjayh0bXBFbGVtZW50KTtcbiAgdG1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRtcEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBzd2FwKHNvdXJjZSwgb3Zlcikge1xuICBjb25zdCBvdmVyUGFyZW50ID0gb3Zlci5wYXJlbnROb2RlO1xuICBjb25zdCBzb3VyY2VQYXJlbnQgPSBzb3VyY2UucGFyZW50Tm9kZTtcblxuICB3aXRoVGVtcEVsZW1lbnQodG1wRWxlbWVudCA9PiB7XG4gICAgc291cmNlUGFyZW50Lmluc2VydEJlZm9yZSh0bXBFbGVtZW50LCBzb3VyY2UpO1xuICAgIG92ZXJQYXJlbnQuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XG4gICAgc291cmNlUGFyZW50Lmluc2VydEJlZm9yZShvdmVyLCB0bXBFbGVtZW50KTtcbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZVN3YXBFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCYXNlIHN3YXBwYWJsZSBldmVudFxuICogQGNsYXNzIFN3YXBwYWJsZUV2ZW50XG4gKiBAbW9kdWxlIFN3YXBwYWJsZUV2ZW50XG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XG4gKi9cbmNsYXNzIFN3YXBwYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgc3dhcHBhYmxlIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcbiAgICogQHR5cGUge0RyYWdFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuU3dhcHBhYmxlRXZlbnQgPSBTd2FwcGFibGVFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzdGFydCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3RhcnRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN0YXJ0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblN3YXBwYWJsZUV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlJztcbmNsYXNzIFN3YXBwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7fVxuXG5leHBvcnRzLlN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBTd2FwcGFibGVTdGFydEV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzd2FwIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3dhcEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN3YXBFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Td2FwcGFibGVTdGFydEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN0YXJ0JztcblN3YXBwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBTd2FwcGFibGVTd2FwRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgb3ZlclxuICAgKiBAcHJvcGVydHkgb3ZlclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuZXhwb3J0cy5Td2FwcGFibGVTd2FwRXZlbnQgPSBTd2FwcGFibGVTd2FwRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzd2FwcGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN3YXBwZWRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3dhcHBlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU3dhcHBhYmxlU3dhcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN3YXAnO1xuU3dhcHBhYmxlU3dhcEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge1xuXG4gIC8qKlxuICAgKiBUaGUgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB5b3Ugc3dhcHBlZCB3aXRoXG4gICAqIEBwcm9wZXJ0eSBzd2FwcGVkRWxlbWVudFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHN3YXBwZWRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3dhcHBlZEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBTd2FwcGFibGVTd2FwcGVkRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzdG9wIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3RvcEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuU3dhcHBhYmxlU3dhcHBlZEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN3YXBwZWQnO1xuY2xhc3MgU3dhcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgU3dhcHBhYmxlRXZlbnQge31cbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gU3dhcHBhYmxlU3RvcEV2ZW50O1xuU3dhcHBhYmxlU3RvcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN0b3AnO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuT2JqZWN0LmtleXMoX1N3YXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfU3dhcHBhYmxlRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfU3dhcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBfU3dhcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBwYWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwcGFibGUyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcblxudmFyIF9Ecm9wcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xuY29uc3QgcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lID0gU3ltYm9sKCdyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUnKTtcbmNvbnN0IGNsb3Nlc3REcm9wem9uZSA9IFN5bWJvbCgnY2xvc2VzdERyb3B6b25lJyk7XG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xuXG4vKipcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaXMgZHJvcHBlZCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxuICogQHBhcmFtIHtEcm9wcGFibGVEcm9wcGVkRXZlbnR9IGRyb3BwYWJsZUV2ZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uRHJvcHBhYmxlRHJvcHBlZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIGRyb3B6b25lIH0pIHtcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ2RyYWdnYWJsZSBlbGVtZW50JztcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XG5cbiAgcmV0dXJuIGBEcm9wcGVkICR7c291cmNlVGV4dH0gaW50byAke2Ryb3B6b25lVGV4dH1gO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaGFzIHJldHVybmVkIHRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Ryb3BwYWJsZVJldHVybmVkRXZlbnR9IGRyb3BwYWJsZUV2ZW50XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uRHJvcHBhYmxlUmV0dXJuZWREZWZhdWx0QW5ub3VuY2VtZW50KHsgZHJhZ0V2ZW50LCBkcm9wem9uZSB9KSB7XG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XG4gIGNvbnN0IGRyb3B6b25lVGV4dCA9IGRyb3B6b25lLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcm9wem9uZS5pZCB8fCAnZHJvcHBhYmxlIGVsZW1lbnQnO1xuXG4gIHJldHVybiBgUmV0dXJuZWQgJHtzb3VyY2VUZXh0fSBmcm9tICR7ZHJvcHpvbmVUZXh0fWA7XG59XG5cbi8qKlxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXG4gKiBAY29uc3Qge0Z1bmN0aW9ufSBkZWZhdWx0QW5ub3VuY2VtZW50c1snZHJvcHBhYmxlOmRyb3BwZWQnXVxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2Ryb3BwYWJsZTpyZXR1cm5lZCddXG4gKi9cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJvcHBhYmxlOmRyb3BwZWQnOiBvbkRyb3BwYWJsZURyb3BwZWREZWZhdWx0QW5ub3VuY2VtZW50LFxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAnZHJvcHBhYmxlOmFjdGl2ZSc6ICdkcmFnZ2FibGUtZHJvcHpvbmUtLWFjdGl2ZScsXG4gICdkcm9wcGFibGU6b2NjdXBpZWQnOiAnZHJhZ2dhYmxlLWRyb3B6b25lLS1vY2N1cGllZCdcbn07XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBkcm9wem9uZTogJy5kcmFnZ2FibGUtZHJvcHBhYmxlJ1xufTtcblxuLyoqXG4gKiBEcm9wcGFibGUgaXMgYnVpbHQgb24gdG9wIG9mIERyYWdnYWJsZSBhbmQgYWxsb3dzIGRyb3BwaW5nIGRyYWdnYWJsZSBlbGVtZW50c1xuICogaW50byBkcm9wem9uZSBlbGVtZW50XG4gKiBAY2xhc3MgRHJvcHBhYmxlXG4gKiBAbW9kdWxlIERyb3BwYWJsZVxuICogQGV4dGVuZHMgRHJhZ2dhYmxlXG4gKi9cbmNsYXNzIERyb3BwYWJsZSBleHRlbmRzIF9EcmFnZ2FibGUyLmRlZmF1bHQge1xuICAvKipcbiAgICogRHJvcHBhYmxlIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBEcm9wcGFibGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gRHJvcHBhYmxlIGNvbnRhaW5lcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBEcm9wcGFibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdENsYXNzZXMsIG9wdGlvbnMuY2xhc3NlcyB8fCB7fSksXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgZHJvcHpvbmUgZWxlbWVudHMgb24gZHJhZyBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSBkcm9wem9uZXNcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmRyb3B6b25lcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMYXN0IGRyb3B6b25lIGVsZW1lbnQgdGhhdCB0aGUgc291cmNlIHdhcyBkcm9wcGVkIGludG9cbiAgICAgKiBAcHJvcGVydHkgbGFzdERyb3B6b25lXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWwgZHJvcHpvbmUgZWxlbWVudCB0aGF0IHRoZSBzb3VyY2Ugd2FzIGRyYWcgZnJvbVxuICAgICAqIEBwcm9wZXJ0eSBpbml0aWFsRHJvcHpvbmVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xuXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBEcm9wcGFibGUgaW5zdGFuY2UuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XG4gICAqL1xuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyb3B6b25lcyA9IFsuLi50aGlzW2dldERyb3B6b25lc10oKV07XG4gICAgY29uc3QgZHJvcHpvbmUgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyb3B6b25lKTtcblxuICAgIGlmICghZHJvcHpvbmUpIHtcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRyb3BwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0YXJ0RXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGRyb3B6b25lXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RhcnRFdmVudCk7XG5cbiAgICBpZiAoZHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5jYW5jZWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xuXG4gICAgZm9yIChjb25zdCBkcm9wem9uZUVsZW1lbnQgb2YgdGhpcy5kcm9wem9uZXMpIHtcbiAgICAgIGlmIChkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRyb3B6b25lRWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6YWN0aXZlJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGV2ZW50IC0gRHJhZyBtb3ZlIGV2ZW50XG4gICAqL1xuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRyb3B6b25lID0gdGhpc1tjbG9zZXN0RHJvcHpvbmVdKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XG4gICAgY29uc3Qgb3ZlckVtcHR5RHJvcHpvbmUgPSBkcm9wem9uZSAmJiAhZHJvcHpvbmUuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSk7XG5cbiAgICBpZiAob3ZlckVtcHR5RHJvcHpvbmUgJiYgdGhpc1tkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSkge1xuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBkcm9wem9uZTtcbiAgICB9IGVsc2UgaWYgKCghZHJvcHpvbmUgfHwgZHJvcHpvbmUgPT09IHRoaXMuaW5pdGlhbERyb3B6b25lKSAmJiB0aGlzLmxhc3REcm9wem9uZSkge1xuICAgICAgdGhpc1tyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KTtcbiAgICAgIHRoaXMubGFzdERyb3B6b25lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxuICAgKi9cbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XG4gICAgY29uc3QgZHJvcHBhYmxlU3RvcEV2ZW50ID0gbmV3IF9Ecm9wcGFibGVFdmVudC5Ecm9wcGFibGVTdG9wRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZSB8fCB0aGlzLmluaXRpYWxEcm9wem9uZVxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0b3BFdmVudCk7XG5cbiAgICBjb25zdCBvY2N1cGllZENsYXNzID0gdGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpO1xuXG4gICAgZm9yIChjb25zdCBkcm9wem9uZSBvZiB0aGlzLmRyb3B6b25lcykge1xuICAgICAgZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOmFjdGl2ZScpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUgJiYgdGhpcy5sYXN0RHJvcHpvbmUgIT09IHRoaXMuaW5pdGlhbERyb3B6b25lKSB7XG4gICAgICB0aGlzLmluaXRpYWxEcm9wem9uZS5jbGFzc0xpc3QucmVtb3ZlKG9jY3VwaWVkQ2xhc3MpO1xuICAgIH1cblxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERyb3BzIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaW50byBhIGRyb3B6b25lIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkcm9wem9uZSAtIERyb3B6b25lIGVsZW1lbnQgdG8gZHJvcCBkcmFnZ2FibGUgaW50b1xuICAgKi9cbiAgW2Ryb3BJbkRyb3B6b25lXShldmVudCwgZHJvcHpvbmUpIHtcbiAgICBjb25zdCBkcm9wcGFibGVEcm9wcGVkRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZURyb3BwZWRFdmVudCh7XG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxuICAgICAgZHJvcHpvbmVcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihkcm9wcGFibGVEcm9wcGVkRXZlbnQpO1xuXG4gICAgaWYgKGRyb3BwYWJsZURyb3BwZWRFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcblxuICAgIGlmICh0aGlzLmxhc3REcm9wem9uZSkge1xuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZShvY2N1cGllZENsYXNzKTtcbiAgICB9XG5cbiAgICBkcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xuICAgIGRyb3B6b25lLmNsYXNzTGlzdC5hZGQob2NjdXBpZWRDbGFzcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgcHJldmlvdXNseSBkcm9wcGVkIGVsZW1lbnQgYmFjayBpbnRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGV2ZW50IC0gRHJhZyBtb3ZlIGV2ZW50XG4gICAqL1xuICBbcmV0dXJuVG9PcmlnaW5hbERyb3B6b25lXShldmVudCkge1xuICAgIGNvbnN0IGRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVJldHVybmVkRXZlbnQoe1xuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcbiAgICAgIGRyb3B6b25lOiB0aGlzLmxhc3REcm9wem9uZVxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVJldHVybmVkRXZlbnQpO1xuXG4gICAgaWYgKGRyb3BwYWJsZVJldHVybmVkRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbERyb3B6b25lLmFwcGVuZENoaWxkKGV2ZW50LnNvdXJjZSk7XG4gICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2xvc2VzdCBkcm9wem9uZSBlbGVtZW50IGZvciBldmVuIHRhcmdldFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFdmVudCB0YXJnZXRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIFtjbG9zZXN0RHJvcHpvbmVdKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5kcm9wem9uZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5kcm9wem9uZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGN1cnJlbnQgZHJvcHpvbmUgZWxlbWVudHMgZm9yIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge05vZGVMaXN0fEhUTUxFbGVtZW50W118QXJyYXl9XG4gICAqL1xuICBbZ2V0RHJvcHpvbmVzXSgpIHtcbiAgICBjb25zdCBkcm9wem9uZSA9IHRoaXMub3B0aW9ucy5kcm9wem9uZTtcblxuICAgIGlmICh0eXBlb2YgZHJvcHpvbmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkcm9wem9uZSk7XG4gICAgfSBlbHNlIGlmIChkcm9wem9uZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGRyb3B6b25lIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wem9uZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGRyb3B6b25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERyb3BwYWJsZTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Ecm9wcGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZURyb3BwZWRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCYXNlIGRyb3BwYWJsZSBldmVudFxuICogQGNsYXNzIERyb3BwYWJsZUV2ZW50XG4gKiBAbW9kdWxlIERyb3BwYWJsZUV2ZW50XG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XG4gKi9cbmNsYXNzIERyb3BwYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZHJvcHBhYmxlIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcbiAgICogQHR5cGUge0RyYWdFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSBEcm9wcGFibGVFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBzdGFydCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlU3RhcnRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0YXJ0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbkRyb3BwYWJsZUV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlJztcbmNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnRseSBkcmFnZ2luZyBkcmFnZ2FibGUgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5cbmV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IERyb3BwYWJsZVN0YXJ0RXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIGRyb3BwZWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcm9wcGFibGVEcm9wcGVkRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlRHJvcHBlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbkRyb3BwYWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdkcm9wcGFibGU6c3RhcnQnO1xuRHJvcHBhYmxlU3RhcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbmNsYXNzIERyb3BwYWJsZURyb3BwZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcblxuICAvKipcbiAgICogVGhlIGRyb3B6b25lIGVsZW1lbnQgeW91IGRyb3BwZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGludG9cbiAgICogQHByb3BlcnR5IGRyb3B6b25lXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJvcHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcbiAgfVxufVxuXG5leHBvcnRzLkRyb3BwYWJsZURyb3BwZWRFdmVudCA9IERyb3BwYWJsZURyb3BwZWRFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHJldHVybmVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVJldHVybmVkRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQudHlwZSA9ICdkcm9wcGFibGU6ZHJvcHBlZCc7XG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBEcm9wcGFibGVSZXR1cm5lZEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xuXG4gIC8qKlxuICAgKiBUaGUgZHJvcHpvbmUgZWxlbWVudCB5b3UgZHJhZ2dlZCBhd2F5IGZyb21cbiAgICogQHByb3BlcnR5IGRyb3B6b25lXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJvcHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcbiAgfVxufVxuXG5leHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBEcm9wcGFibGVSZXR1cm5lZEV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBzdG9wIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlU3RvcEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0b3BFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnJldHVybmVkJztcbkRyb3BwYWJsZVJldHVybmVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XG5jbGFzcyBEcm9wcGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XG5cbiAgLyoqXG4gICAqIFRoZSBmaW5hbCBkcm9wem9uZSBlbGVtZW50IG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkcm9wem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xuICB9XG59XG5leHBvcnRzLkRyb3BwYWJsZVN0b3BFdmVudCA9IERyb3BwYWJsZVN0b3BFdmVudDtcbkRyb3BwYWJsZVN0b3BFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdG9wJztcbkRyb3BwYWJsZVN0b3BFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0Ryb3BwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbk9iamVjdC5rZXlzKF9Ecm9wcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX0Ryb3BwYWJsZUV2ZW50W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX0Ryb3BwYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG52YXIgX0Ryb3BwYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ecm9wcGFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfRHJvcHBhYmxlMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIFRoZSBFbWl0dGVyIGlzIGEgc2ltcGxlIGVtaXR0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyB5b3Ugd2l0aCBgb24oKWAsIGBvZmYoKWAgYW5kIGB0cmlnZ2VyKClgIG1ldGhvZHNcbiAqIEBjbGFzcyBFbWl0dGVyXG4gKiBAbW9kdWxlIEVtaXR0ZXJcbiAqL1xuY2xhc3MgRW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBieSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrc1xuICAgKi9cbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0gPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXS5wdXNoKC4uLmNhbGxiYWNrcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBjYWxsYmFja3MgYnkgZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29weSA9IHRoaXMuY2FsbGJhY2tzW3R5cGVdLnNsaWNlKDApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IGNvcHlbaV0pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbdHlwZV0uc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGV2ZW50IGNhbGxiYWNrcyBieSBldmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxuICAgKi9cbiAgdHJpZ2dlcihldmVudCkge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnQudHlwZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsuLi50aGlzLmNhbGxiYWNrc1tldmVudC50eXBlXV07XG4gICAgY29uc3QgY2F1Z2h0RXJyb3JzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXVnaHRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0VtaXR0ZXIyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX1BsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIF9FbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcblxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uRHJhZ1ByZXNzdXJlID0gU3ltYm9sKCdvbkRyYWdQcmVzc3VyZScpO1xuXG4vKipcbiAqIEBjb25zdCB7T2JqZWN0fSBkZWZhdWx0QW5ub3VuY2VtZW50c1xuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RhcnQnXVxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RvcCddXG4gKi9cbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXG4gICdkcmFnOnN0b3AnOiBldmVudCA9PiBgUmVsZWFzZWQgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWBcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAnY29udGFpbmVyOmRyYWdnaW5nJzogJ2RyYWdnYWJsZS1jb250YWluZXItLWlzLWRyYWdnaW5nJyxcbiAgJ3NvdXJjZTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZycsXG4gICdzb3VyY2U6cGxhY2VkJzogJ2RyYWdnYWJsZS1zb3VyY2UtLXBsYWNlZCcsXG4gICdjb250YWluZXI6cGxhY2VkJzogJ2RyYWdnYWJsZS1jb250YWluZXItLXBsYWNlZCcsXG4gICdib2R5OmRyYWdnaW5nJzogJ2RyYWdnYWJsZS0taXMtZHJhZ2dpbmcnLFxuICAnZHJhZ2dhYmxlOm92ZXInOiAnZHJhZ2dhYmxlLS1vdmVyJyxcbiAgJ2NvbnRhaW5lcjpvdmVyJzogJ2RyYWdnYWJsZS1jb250YWluZXItLW92ZXInLFxuICAnc291cmNlOm9yaWdpbmFsJzogJ2RyYWdnYWJsZS0tb3JpZ2luYWwnLFxuICBtaXJyb3I6ICdkcmFnZ2FibGUtbWlycm9yJ1xufTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuICBkcmFnZ2FibGU6ICcuZHJhZ2dhYmxlLXNvdXJjZScsXG4gIGhhbmRsZTogbnVsbCxcbiAgZGVsYXk6IDEwMCxcbiAgcGxhY2VkVGltZW91dDogODAwLFxuICBwbHVnaW5zOiBbXSxcbiAgc2Vuc29yczogW11cbn07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29yZSBkcmFnZ2FibGUgbGlicmFyeSB0aGF0IGRvZXMgdGhlIGhlYXZ5IGxpZnRpbmdcbiAqIEBjbGFzcyBEcmFnZ2FibGVcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlXG4gKi9cbmNsYXNzIERyYWdnYWJsZSB7XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZSBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgRHJhZ2dhYmxlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyYWdnYWJsZSBjb250YWluZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZHJhZ2dhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW2RvY3VtZW50LmJvZHldLCBvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBEcmFnZ2FibGUgY29udGFpbmVyc1xuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBjb250YWluZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lcnMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXJzID0gW2NvbnRhaW5lcnNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZSBjb250YWluZXJzIGFyZSBleHBlY3RlZCB0byBiZSBvZiB0eXBlIGBOb2RlTGlzdGAsIGBIVE1MRWxlbWVudFtdYCBvciBgSFRNTEVsZW1lbnRgJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdENsYXNzZXMsIG9wdGlvbnMuY2xhc3NlcyB8fCB7fSksXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERyYWdnYWJsZXMgZXZlbnQgZW1pdHRlclxuICAgICAqIEBwcm9wZXJ0eSBlbWl0dGVyXG4gICAgICogQHR5cGUge0VtaXR0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IF9FbWl0dGVyMi5kZWZhdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRyYWcgc3RhdGVcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmUgcGx1Z2luc1xuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gICAgICogQHR5cGUge1BsdWdpbltdfVxuICAgICAqL1xuICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQWN0aXZlIHNlbnNvcnNcbiAgICAgKiBAcHJvcGVydHkgc2Vuc29yc1xuICAgICAqIEB0eXBlIHtTZW5zb3JbXX1cbiAgICAgKi9cbiAgICB0aGlzLnNlbnNvcnMgPSBbXTtcblxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdQcmVzc3VyZV0gPSB0aGlzW29uRHJhZ1ByZXNzdXJlXS5iaW5kKHRoaXMpO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xuXG4gICAgY29uc3QgZGVmYXVsdFBsdWdpbnMgPSBPYmplY3QudmFsdWVzKERyYWdnYWJsZS5QbHVnaW5zKS5tYXAoUGx1Z2luID0+IFBsdWdpbik7XG4gICAgY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbX1NlbnNvcnMuTW91c2VTZW5zb3IsIF9TZW5zb3JzLlRvdWNoU2Vuc29yXTtcblxuICAgIHRoaXMuYWRkUGx1Z2luKC4uLlsuLi5kZWZhdWx0UGx1Z2lucywgLi4udGhpcy5vcHRpb25zLnBsdWdpbnNdKTtcbiAgICB0aGlzLmFkZFNlbnNvciguLi5bLi4uZGVmYXVsdFNlbnNvcnMsIC4uLnRoaXMub3B0aW9ucy5zZW5zb3JzXSk7XG5cbiAgICBjb25zdCBkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50ID0gbmV3IF9EcmFnZ2FibGVFdmVudC5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KHtcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoeyBtaXJyb3IgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xuICAgIHRoaXMub24oJ21pcnJvcjpkZXN0cm95JywgKCkgPT4gdGhpcy5taXJyb3IgPSBudWxsKTtcblxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBEcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgcmVtb3ZlcyBhbGwgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzIGFuZFxuICAgKiBkZWFjdGl2YXRlcyBzZW5zb3JzIGFuZCBwbHVnaW5zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsdWdpbnMgZHJhZ2dhYmxlIHVzZXNcbiAgICogQHN0YXRpY1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gUGx1Z2luc1xuICAgKiBAcHJvcGVydHkge0Fubm91bmNlbWVudH0gUGx1Z2lucy5Bbm5vdW5jZW1lbnRcbiAgICogQHByb3BlcnR5IHtGb2N1c2FibGV9IFBsdWdpbnMuRm9jdXNhYmxlXG4gICAqIEBwcm9wZXJ0eSB7TWlycm9yfSBQbHVnaW5zLk1pcnJvclxuICAgKiBAcHJvcGVydHkge1Njcm9sbGFibGV9IFBsdWdpbnMuU2Nyb2xsYWJsZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6cHJlc3N1cmUnLCB0aGlzW29uRHJhZ1ByZXNzdXJlXSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZURlc3Ryb3lFdmVudCh7XG4gICAgICBkcmFnZ2FibGU6IHRoaXNcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVEZXN0cm95RXZlbnQpO1xuXG4gICAgdGhpcy5yZW1vdmVQbHVnaW4oLi4udGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLmNvbnN0cnVjdG9yKSk7XG4gICAgdGhpcy5yZW1vdmVTZW5zb3IoLi4udGhpcy5zZW5zb3JzLm1hcChzZW5zb3IgPT4gc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBwbHVnaW4gdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZyB0aGUgYXR0YWNoIG1ldGhvZCBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkUGx1Z2luKEN1c3RvbUExMXlQbHVnaW4sIEN1c3RvbU1pcnJvclBsdWdpbilcbiAgICovXG4gIGFkZFBsdWdpbiguLi5wbHVnaW5zKSB7XG4gICAgY29uc3QgYWN0aXZlUGx1Z2lucyA9IHBsdWdpbnMubWFwKFBsdWdpbiA9PiBuZXcgUGx1Z2luKHRoaXMpKTtcblxuICAgIGFjdGl2ZVBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmF0dGFjaCgpKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbLi4udGhpcy5wbHVnaW5zLCAuLi5hY3RpdmVQbHVnaW5zXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgcGx1Z2lucyB0aGF0IGFyZSBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmdcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBQbHVnaW59IHBsdWdpbnMgLSBQbHVnaW5zIHRoYXQgeW91IHdhbnQgZGV0YWNoZWQgZnJvbSBkcmFnZ2FibGVcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlUGx1Z2luKE1pcnJvclBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxuICAgKi9cbiAgcmVtb3ZlUGx1Z2luKC4uLnBsdWdpbnMpIHtcbiAgICBjb25zdCByZW1vdmVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XG5cbiAgICByZW1vdmVkUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uZGV0YWNoKCkpO1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBzZW5zb3JzIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFNlbnNvcihGb3JjZVRvdWNoU2Vuc29yLCBDdXN0b21TZW5zb3IpXG4gICAqL1xuICBhZGRTZW5zb3IoLi4uc2Vuc29ycykge1xuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xuXG4gICAgYWN0aXZlU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYXR0YWNoKCkpO1xuICAgIHRoaXMuc2Vuc29ycyA9IFsuLi50aGlzLnNlbnNvcnMsIC4uLmFjdGl2ZVNlbnNvcnNdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5zb3JzIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xuICAgKiB0aGUgZGV0YWNoIG1ldGhvZCBvZiB0aGUgc2Vuc29yXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlU2Vuc29yKFRvdWNoU2Vuc29yLCBEcmFnU2Vuc29yKVxuICAgKi9cbiAgcmVtb3ZlU2Vuc29yKC4uLnNlbnNvcnMpIHtcbiAgICBjb25zdCByZW1vdmVkU2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+IHNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XG5cbiAgICByZW1vdmVkU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuZGV0YWNoKCkpO1xuICAgIHRoaXMuc2Vuc29ycyA9IHRoaXMuc2Vuc29ycy5maWx0ZXIoc2Vuc29yID0+ICFzZW5zb3JzLmluY2x1ZGVzKHNlbnNvci5jb25zdHJ1Y3RvcikpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gYWRkIHRvIGRyYWdnYWJsZVxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5hZGRDb250YWluZXIoZG9jdW1lbnQuYm9keSlcbiAgICovXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLnRoaXMuY29udGFpbmVycywgLi4uY29udGFpbmVyc107XG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5hZGRDb250YWluZXIoLi4uY29udGFpbmVycykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY29udGFpbmVyIGZyb20gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHsuLi5IVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnMgeW91IHdhbnQgdG8gcmVtb3ZlIGZyb20gZHJhZ2dhYmxlXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxuICAgKi9cbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcbiAgICB0aGlzLnNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLnJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lciBmb3IgZHJhZ2dhYmxlIGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzIC0gRXZlbnQgY2FsbGJhY2tzXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgKGRyYWdFdmVudCkgPT4gZHJhZ0V2ZW50LmNhbmNlbCgpKTtcbiAgICovXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xuICAgIHRoaXMuZW1pdHRlci5vbih0eXBlLCAuLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgZnJvbSBkcmFnZ2FibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRXZlbnQgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUub2ZmKCdkcmFnOnN0YXJ0JywgaGFuZGxlckZ1bmN0aW9uKTtcbiAgICovXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYodHlwZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGRyYWdnYWJsZSBldmVudFxuICAgKiBAcGFyYW0ge0Fic3RyYWN0RXZlbnR9IGV2ZW50IC0gRXZlbnQgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUudHJpZ2dlcihldmVudCk7XG4gICAqL1xuICB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZSBmb3IgY2xhc3MgaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgY2xhc3MgaWRlbnRpZmllclxuICAgKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAgICovXG4gIGdldENsYXNzTmFtZUZvcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc2VzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgZHJhZ2dpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRHJhZ2dpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5kcmFnZ2luZyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXREcmFnZ2FibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmN1cnJlbnQsIC4uLnRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKV07XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGVsZW1lbnRzIGZvciBhIGdpdmVuIGNvbnRhaW5lciwgZXhjbHVkaW5nIHRoZSBtaXJyb3IgYW5kXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50IGlmIHByZXNlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBhbGxEcmFnZ2FibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgcmV0dXJuIFsuLi5hbGxEcmFnZ2FibGVFbGVtZW50c10uZmlsdGVyKGNoaWxkRWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCB7IHRhcmdldCwgY29udGFpbmVyIH0gPSBzZW5zb3JFdmVudDtcblxuICAgIGlmICghdGhpcy5jb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhbmRsZSAmJiB0YXJnZXQgJiYgISgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuaGFuZGxlKSkge1xuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluZCBkcmFnZ2FibGUgc291cmNlIGVsZW1lbnRcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsU291cmNlKSB7XG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlICYmIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGxhY2VkVGltZW91dElEKTtcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuc291cmNlLCB0aGlzLm9yaWdpbmFsU291cmNlKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBjb25zdCBkcmFnRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RhcnRFdmVudCh7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZHJhZ0V2ZW50KTtcblxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ0V2ZW50LmNhbmNlbGVkKCk7XG5cbiAgICBpZiAoZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zb3VyY2UpO1xuICAgICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcbiAgICB0aGlzLnNvdXJjZS5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignYm9keTpkcmFnZ2luZycpKTtcbiAgICBhcHBseVVzZXJTZWxlY3QoZG9jdW1lbnQuYm9keSwgJ25vbmUnKTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCBvbGRTZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IG5ld1NlbnNvckV2ZW50ID0gb2xkU2Vuc29yRXZlbnQuY2xvbmUoeyB0YXJnZXQ6IHRoaXMuc291cmNlIH0pO1xuXG4gICAgICB0aGlzW29uRHJhZ01vdmVdKF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxuICAgKi9cbiAgW29uRHJhZ01vdmVdKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XG4gICAgY29uc3QgeyBjb250YWluZXIgfSA9IHNlbnNvckV2ZW50O1xuICAgIGxldCB0YXJnZXQgPSBzZW5zb3JFdmVudC50YXJnZXQ7XG5cbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ01vdmVFdmVudCh7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHNlbnNvckV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZHJhZ01vdmVFdmVudCk7XG5cbiAgICBpZiAoZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgY29uc3Qgd2l0aGluQ29ycmVjdENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xuICAgIGNvbnN0IG92ZXJDb250YWluZXIgPSBzZW5zb3JFdmVudC5vdmVyQ29udGFpbmVyIHx8IHdpdGhpbkNvcnJlY3RDb250YWluZXI7XG4gICAgY29uc3QgaXNMZWF2aW5nQ29udGFpbmVyID0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAmJiBvdmVyQ29udGFpbmVyICE9PSB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyO1xuICAgIGNvbnN0IGlzTGVhdmluZ0RyYWdnYWJsZSA9IHRoaXMuY3VycmVudE92ZXIgJiYgdGFyZ2V0ICE9PSB0aGlzLmN1cnJlbnRPdmVyO1xuICAgIGNvbnN0IGlzT3ZlckNvbnRhaW5lciA9IG92ZXJDb250YWluZXIgJiYgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lciAhPT0gb3ZlckNvbnRhaW5lcjtcbiAgICBjb25zdCBpc092ZXJEcmFnZ2FibGUgPSB3aXRoaW5Db3JyZWN0Q29udGFpbmVyICYmIHRhcmdldCAmJiB0aGlzLmN1cnJlbnRPdmVyICE9PSB0YXJnZXQ7XG5cbiAgICBpZiAoaXNMZWF2aW5nRHJhZ2dhYmxlKSB7XG4gICAgICBjb25zdCBkcmFnT3V0RXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0RXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyOiB0aGlzLmN1cnJlbnRPdmVyXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcbiAgICAgIHRoaXMuY3VycmVudE92ZXIgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dEV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWF2aW5nQ29udGFpbmVyKSB7XG4gICAgICBjb25zdCBkcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3V0Q29udGFpbmVyRXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyQ29udGFpbmVyOiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ091dENvbnRhaW5lckV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNPdmVyQ29udGFpbmVyKSB7XG4gICAgICBvdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xuXG4gICAgICBjb25zdCBkcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ092ZXJDb250YWluZXJFdmVudCh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxuICAgICAgICBzb3VyY2VDb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICAgIG92ZXJDb250YWluZXJcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lcjtcblxuICAgICAgdGhpcy50cmlnZ2VyKGRyYWdPdmVyQ29udGFpbmVyRXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc092ZXJEcmFnZ2FibGUpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcblxuICAgICAgY29uc3QgZHJhZ092ZXJFdmVudCA9IG5ldyBfRHJhZ0V2ZW50LkRyYWdPdmVyRXZlbnQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgICBvdmVyQ29udGFpbmVyLFxuICAgICAgICBvdmVyOiB0YXJnZXRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gdGFyZ2V0O1xuXG4gICAgICB0aGlzLnRyaWdnZXIoZHJhZ092ZXJFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnU3RvcEV2ZW50KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50OiBldmVudC5zZW5zb3JFdmVudCxcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcblxuICAgIHRoaXMuc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMub3JpZ2luYWxTb3VyY2UsIHRoaXMuc291cmNlKTtcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpvcmlnaW5hbCcpKTtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdjb250YWluZXI6ZHJhZ2dpbmcnKSk7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdib2R5OmRyYWdnaW5nJykpO1xuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50T3Zlcikge1xuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdjb250YWluZXI6b3ZlcicpKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RQbGFjZWRTb3VyY2UgPSB0aGlzLm9yaWdpbmFsU291cmNlO1xuICAgIHRoaXMubGFzdFBsYWNlZENvbnRhaW5lciA9IHRoaXMuc291cmNlQ29udGFpbmVyO1xuXG4gICAgdGhpcy5wbGFjZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpwbGFjZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSBudWxsO1xuICAgIH0sIHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcblxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBwcmVzc3VyZSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdQcmVzc3VyZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5zb3JFdmVudCA9IGdldFNlbnNvckV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCAoMCwgX3V0aWxzLmNsb3Nlc3QpKHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1ByZXNzdXJlRXZlbnQoe1xuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBzb3VyY2UsXG4gICAgICBwcmVzc3VyZTogc2Vuc29yRXZlbnQucHJlc3N1cmVcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xuRHJhZ2dhYmxlLlBsdWdpbnMgPSB7IEFubm91bmNlbWVudDogX1BsdWdpbnMuQW5ub3VuY2VtZW50LCBGb2N1c2FibGU6IF9QbHVnaW5zLkZvY3VzYWJsZSwgTWlycm9yOiBfUGx1Z2lucy5NaXJyb3IsIFNjcm9sbGFibGU6IF9QbHVnaW5zLlNjcm9sbGFibGUgfTtcbmZ1bmN0aW9uIGdldFNlbnNvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5kZXRhaWw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VXNlclNlbGVjdChlbGVtZW50LCB2YWx1ZSkge1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS5tb3pVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUubXNVc2VyU2VsZWN0ID0gdmFsdWU7XG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcbiAgZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gdmFsdWU7XG59XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xuXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25Nb3VzZUZvcmNlV2lsbEJlZ2luID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VXaWxsQmVnaW4nKTtcbmNvbnN0IG9uTW91c2VGb3JjZURvd24gPSBTeW1ib2woJ29uTW91c2VGb3JjZURvd24nKTtcbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xuY29uc3Qgb25Nb3VzZUZvcmNlQ2hhbmdlID0gU3ltYm9sKCdvbk1vdXNlRm9yY2VDaGFuZ2UnKTtcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcbmNvbnN0IG9uTW91c2VGb3JjZUdsb2JhbENoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlR2xvYmFsQ2hhbmdlJyk7XG5cbi8qKlxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGZvcmNlIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXG4gKiBAY2xhc3MgRm9yY2VUb3VjaFNlbnNvclxuICogQG1vZHVsZSBGb3JjZVRvdWNoU2Vuc29yXG4gKiBAZXh0ZW5kcyBTZW5zb3JcbiAqL1xuY2xhc3MgRm9yY2VUb3VjaFNlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xuICAvKipcbiAgICogRm9yY2VUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgRm9yY2VUb3VjaFNlbnNvclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAqIEBwcm9wZXJ0eSBtaWdodERyYWdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xuXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSA9IHRoaXNbb25Nb3VzZUZvcmNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlTW92ZV0gPSB0aGlzW29uTW91c2VNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZVVwXSA9IHRoaXNbb25Nb3VzZVVwXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWRvd24nLCB0aGlzW29uTW91c2VGb3JjZURvd25dLCBmYWxzZSk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJywgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLCBmYWxzZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWRvd24nLCB0aGlzW29uTW91c2VGb3JjZURvd25dLCBmYWxzZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2VjaGFuZ2VkJywgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpc1tvbk1vdXNlTW92ZV0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gZXZlbnRcbiAgICovXG4gIFtvbk1vdXNlRm9yY2VXaWxsQmVnaW5dKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgZm9yY2UgZG93biBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZG93biBldmVudFxuICAgKi9cbiAgW29uTW91c2VGb3JjZURvd25dKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cbiAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xuXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxuICAgKi9cbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XG5cbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubWlnaHREcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVlZCB3b3JrYXJvdW5kIGZvciByZWFsIGNsaWNrXG4gICAgLy8gQ2FuY2VsIHBvdGVudGlhbCBkcmFnIGV2ZW50c1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2Ugd2lsbCBiZWdpbiBldmVudFxuICAgKi9cbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG5cbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgZm9yY2UgY2hhbmdlIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBjaGFuZ2UgZXZlbnRcbiAgICovXG4gIFtvbk1vdXNlRm9yY2VDaGFuZ2VdKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XG4gICAgICBwcmVzc3VyZTogZXZlbnQud2Via2l0Rm9yY2UsXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZ2xvYmFsIGNoYW5nZSBldmVudFxuICAgKi9cbiAgW29uTW91c2VGb3JjZUdsb2JhbENoYW5nZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBjb25zdCBkcmFnUHJlc3N1cmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQoe1xuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnUHJlc3N1cmVFdmVudCk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEZvcmNlVG91Y2hTZW5zb3I7XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfRm9yY2VUb3VjaFNlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb3JjZVRvdWNoU2Vuc29yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvcmNlVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcblxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IG9uTW91c2VEb3duID0gU3ltYm9sKCdvbk1vdXNlRG93bicpO1xuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xuY29uc3Qgb25EcmFnRW5kID0gU3ltYm9sKCdvbkRyYWdFbmQnKTtcbmNvbnN0IG9uRHJvcCA9IFN5bWJvbCgnb25Ecm9wJyk7XG5jb25zdCByZXNldCA9IFN5bWJvbCgncmVzZXQnKTtcblxuLyoqXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXG4gKiBAY2xhc3MgRHJhZ1NlbnNvclxuICogQG1vZHVsZSBEcmFnU2Vuc29yXG4gKiBAZXh0ZW5kcyBTZW5zb3JcbiAqL1xuY2xhc3MgRHJhZ1NlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xuICAvKipcbiAgICogRHJhZ1NlbnNvciBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgRHJhZ1NlbnNvclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1vdXNlIGRvd24gdGltZXIgd2hpY2ggd2lsbCBlbmQgdXAgc2V0dGluZyB0aGUgZHJhZ2dhYmxlIGF0dHJpYnV0ZSwgdW5sZXNzIGNhbmNlbGVkXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlRWxlbWVudFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogTmF0aXZlIGRyYWdnYWJsZSBlbGVtZW50IGNvdWxkIGJlIGxpbmtzIG9yIGltYWdlcywgdGhlaXIgZHJhZ2dhYmxlIHN0YXRlIHdpbGwgYmUgZGlzYWJsZWQgZHVyaW5nIGRyYWcgb3BlcmF0aW9uXG4gICAgICogQHByb3BlcnR5IG5hdGl2ZURyYWdnYWJsZUVsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ0VuZF0gPSB0aGlzW29uRHJhZ0VuZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxuICAgKi9cbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xuICAgIC8vIE5lZWQgZm9yIGZpcmVmb3guIFwidGV4dFwiIGtleSBpcyBuZWVkZWQgZm9yIElFXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSB0aGlzLm9wdGlvbnMudHlwZTtcblxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIHRoaXMuY29udGFpbmVycyk7XG5cbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIC8vIFdvcmthcm91bmRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcblxuICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcbiAgICovXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29udGFpbmVyO1xuXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcblxuICAgIGlmICghZHJhZ01vdmVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBlbmQgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgZW5kIGV2ZW50XG4gICAqL1xuICBbb25EcmFnRW5kXShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xuXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XG5cbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdG9wRXZlbnQpO1xuXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgdGhpc1tyZXNldF0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcm9wIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcm9wIGV2ZW50XG4gICAqL1xuICBbb25Ecm9wXShldmVudCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgZG93biBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxuICAgKi9cbiAgW29uTW91c2VEb3duXShldmVudCkge1xuICAgIC8vIEZpcmVmb3ggYnVnIGZvciBpbnB1dHMgd2l0aGluIGRyYWdnYWJsZXMgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzM5MDcxXG4gICAgaWYgKGV2ZW50LnRhcmdldCAmJiAoZXZlbnQudGFyZ2V0LmZvcm0gfHwgZXZlbnQudGFyZ2V0LmNvbnRlbnRlZGl0YWJsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC50YXJnZXQsIGVsZW1lbnQgPT4gZWxlbWVudC5kcmFnZ2FibGUpO1xuXG4gICAgaWYgKG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQpIHtcbiAgICAgIG5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50O1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzW29uRHJvcF0sIGZhbHNlKTtcblxuICAgIGNvbnN0IHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IHRhcmdldDtcbiAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxuICAgKi9cbiAgW29uTW91c2VVcF0oKSB7XG4gICAgdGhpc1tyZXNldF0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcbiAgICovXG4gIFtyZXNldF0oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCB0aGlzW29uRHJhZ0VuZF0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50KSB7XG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlRWxlbWVudCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdTZW5zb3I7XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9EcmFnU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbnZhciBfRHJhZ1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnU2Vuc29yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0RyYWdTZW5zb3IyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcblxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IG9uVG91Y2hTdGFydCA9IFN5bWJvbCgnb25Ub3VjaFN0YXJ0Jyk7XG5jb25zdCBvblRvdWNoSG9sZCA9IFN5bWJvbCgnb25Ub3VjaEhvbGQnKTtcbmNvbnN0IG9uVG91Y2hFbmQgPSBTeW1ib2woJ29uVG91Y2hFbmQnKTtcbmNvbnN0IG9uVG91Y2hNb3ZlID0gU3ltYm9sKCdvblRvdWNoTW92ZScpO1xuXG4vKipcbiAqIFByZXZlbnRzIHNjcm9sbGluZyB3aGVuIHNldCB0byB0cnVlXG4gKiBAdmFyIHtCb29sZWFufSBwcmV2ZW50U2Nyb2xsaW5nXG4gKi9cbmxldCBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XG5cbi8vIFdlYktpdCByZXF1aXJlcyBjYW5jZWxhYmxlIGB0b3VjaG1vdmVgIGV2ZW50cyB0byBiZSBhZGRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50ID0+IHtcbiAgaWYgKCFwcmV2ZW50U2Nyb2xsaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbi8qKlxuICogVGhpcyBzZW5zb3IgcGlja3MgdXAgbmF0aXZlIGJyb3dzZXIgdG91Y2ggZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcbiAqIEBjbGFzcyBUb3VjaFNlbnNvclxuICogQG1vZHVsZSBUb3VjaFNlbnNvclxuICogQGV4dGVuZHMgU2Vuc29yXG4gKi9cbmNsYXNzIFRvdWNoU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgVG91Y2hTZW5zb3JcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyIHNvIGFjY2lkZW50YWwgc2Nyb2xsIGNhbiBjYW5jZWwgbG9uZyB0b3VjaFxuICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50U2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRTY3JvbGxhYmxlUGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXRJRCBmb3IgbG9uZyB0b3VjaFxuICAgICAqIEBwcm9wZXJ0eSB0YXBUaW1lb3V0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRhcFRpbWVvdXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogdG91Y2hNb3ZlZCBpbmRpY2F0ZXMgaWYgdG91Y2ggaGFzIG1vdmVkIGR1cmluZyB0YXBUaW1lb3V0XG4gICAgICogQHByb3BlcnR5IHRvdWNoTW92ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcblxuICAgIHRoaXNbb25Ub3VjaFN0YXJ0XSA9IHRoaXNbb25Ub3VjaFN0YXJ0XS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Ub3VjaEhvbGRdID0gdGhpc1tvblRvdWNoSG9sZF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uVG91Y2hFbmRdID0gdGhpc1tvblRvdWNoRW5kXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Ub3VjaE1vdmVdID0gdGhpc1tvblRvdWNoTW92ZV0uYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzW29uVG91Y2hTdGFydF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXJ0IGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBzdGFydCBldmVudFxuICAgKi9cbiAgW29uVG91Y2hTdGFydF0oZXZlbnQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcblxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLnRhcFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXNbb25Ub3VjaEhvbGRdKGV2ZW50LCBjb250YWluZXIpLCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvdWNoIGhvbGQgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIHN0YXJ0IGV2ZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIENvbnRhaW5lciBlbGVtZW50XG4gICAqL1xuICBbb25Ub3VjaEhvbGRdKGV2ZW50LCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudG91Y2hNb3ZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcbiAgICAgICAgY2xpZW50WDogdG91Y2gucGFnZVgsXG4gICAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XG5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcbiAgICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0aGlzLmRyYWdnaW5nO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVG91Y2ggbW92ZSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggbW92ZSBldmVudFxuICAgKi9cbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xuICAgIHRoaXMudG91Y2hNb3ZlZCA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcblxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogdG91Y2gucGFnZVgsXG4gICAgICBjbGllbnRZOiB0b3VjaC5wYWdlWSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvdWNoIGVuZCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggZW5kIGV2ZW50XG4gICAqL1xuICBbb25Ub3VjaEVuZF0oZXZlbnQpIHtcbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICBwcmV2ZW50U2Nyb2xsaW5nID0gZmFsc2U7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpc1tvblRvdWNoRW5kXSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpc1tvblRvdWNoTW92ZV0pO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudENvbnRhaW5lcikge1xuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCk7XG5cbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RvcFNlbnNvckV2ZW50KHtcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxuICAgICAgY2xpZW50WTogdG91Y2gucGFnZVksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcblxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvdWNoU2Vuc29yO1xuZnVuY3Rpb24gb25Db250ZXh0TWVudShldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbnZhciBfVG91Y2hTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVG91Y2hTZW5zb3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gZXhwb3J0cy5TZW5zb3JFdmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEJhc2Ugc2Vuc29yIGV2ZW50XG4gKiBAY2xhc3MgU2Vuc29yRXZlbnRcbiAqIEBtb2R1bGUgU2Vuc29yRXZlbnRcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcbiAqL1xuY2xhc3MgU2Vuc29yRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBPcmlnaW5hbCBicm93c2VyIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIGEgc2Vuc29yXG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XG4gICAqIEB0eXBlIHtFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9yaWdpbmFsRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplZCBjbGllbnRYIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcbiAgICogQHByb3BlcnR5IGNsaWVudFhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY2xpZW50WCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFg7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplZCBjbGllbnRZIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcbiAgICogQHByb3BlcnR5IGNsaWVudFlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY2xpZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFk7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplZCB0YXJnZXQgZm9yIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50c1xuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVoaW5kIGN1cnNvciBvciB0b3VjaCBwb2ludGVyXG4gICAqIEBwcm9wZXJ0eSB0YXJnZXRcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udGFpbmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBzZW5zb3JcbiAgICogQHByb3BlcnR5IGNvbnRhaW5lclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3BhZCBwcmVzc3VyZVxuICAgKiBAcHJvcGVydHkgcHJlc3N1cmVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJlc3N1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wcmVzc3VyZTtcbiAgfVxufVxuXG5leHBvcnRzLlNlbnNvckV2ZW50ID0gU2Vuc29yRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IHNlbnNvciBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnU3RhcnRTZW5zb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxuXG5leHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gRHJhZ1N0YXJ0U2Vuc29yRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgc2Vuc29yIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnTW92ZVNlbnNvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ01vdmVTZW5zb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcbmNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxuXG5leHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBEcmFnTW92ZVNlbnNvckV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgc3RvcCBzZW5zb3IgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wU2Vuc29yRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNlbnNvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ01vdmVTZW5zb3JFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5jbGFzcyBEcmFnU3RvcFNlbnNvckV2ZW50IGV4dGVuZHMgU2Vuc29yRXZlbnQge31cblxuZXhwb3J0cy5EcmFnU3RvcFNlbnNvckV2ZW50ID0gRHJhZ1N0b3BTZW5zb3JFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHByZXNzdXJlIHNlbnNvciBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbkRyYWdTdG9wU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0b3AnO1xuY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxuZXhwb3J0cy5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCA9IERyYWdQcmVzc3VyZVNlbnNvckV2ZW50O1xuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xuXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcgPSBTeW1ib2woJ29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nJyk7XG5jb25zdCBvbk1vdXNlRG93biA9IFN5bWJvbCgnb25Nb3VzZURvd24nKTtcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xuY29uc3Qgb25Nb3VzZVVwID0gU3ltYm9sKCdvbk1vdXNlVXAnKTtcblxuLyoqXG4gKiBUaGlzIHNlbnNvciBwaWNrcyB1cCBuYXRpdmUgYnJvd3NlciBtb3VzZSBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xuICogQGNsYXNzIE1vdXNlU2Vuc29yXG4gKiBAbW9kdWxlIE1vdXNlU2Vuc29yXG4gKiBAZXh0ZW5kcyBTZW5zb3JcbiAqL1xuY2xhc3MgTW91c2VTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIE1vdXNlU2Vuc29yIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBNb3VzZVNlbnNvclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBtb3VzZSBidXR0b24gaXMgc3RpbGwgZG93blxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCB0cmlnZ2VyaW5nIHRoZSBkcmFnIHN0YXJ0IG9wZXJhdGlvblxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25UaW1lb3V0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGNvbnRleHQgbWVudSBoYXMgYmVlbiBvcGVuZWQgZHVyaW5nIGRyYWcgb3BlcmF0aW9uXG4gICAgICogQHByb3BlcnR5IG9wZW5lZENvbnRleHRNZW51XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vcGVuZWRDb250ZXh0TWVudSA9IGZhbHNlO1xuXG4gICAgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10gPSB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25Nb3VzZURvd25dID0gdGhpc1tvbk1vdXNlRG93bl0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgc2Vuc29ycyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIERPTVxuICAgKi9cbiAgYXR0YWNoKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXNbb25Nb3VzZURvd25dLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICBjb25zdCBjb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcblxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcHJldmVudE5hdGl2ZURyYWdTdGFydCk7XG5cbiAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZURvd25UaW1lb3V0KTtcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tb3VzZURvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xuICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XG5cbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcblxuICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIG1vdmUgZXZlbnRcbiAgICovXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KTtcblxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxuICAgKi9cbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNlRG93biA9IEJvb2xlYW4odGhpcy5vcGVuZWRDb250ZXh0TWVudSk7XG5cbiAgICBpZiAodGhpcy5vcGVuZWRDb250ZXh0TWVudSkge1xuICAgICAgdGhpcy5vcGVuZWRDb250ZXh0TWVudSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHByZXZlbnROYXRpdmVEcmFnU3RhcnQpO1xuXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICB0YXJnZXQsXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpc1tvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZ10pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcblxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRleHQgbWVudSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQ29udGV4dCBtZW51IGV2ZW50XG4gICAqL1xuICBbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm9wZW5lZENvbnRleHRNZW51ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBNb3VzZVNlbnNvcjtcbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01vdXNlU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cbnZhciBfTW91c2VTZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW91c2VTZW5zb3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfTW91c2VTZW5zb3IyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuLyoqXG4gKiBCYXNlIHNlbnNvciBjbGFzcy4gRXh0ZW5kIGZyb20gdGhpcyBjbGFzcyB0byBjcmVhdGUgYSBuZXcgb3IgY3VzdG9tIHNlbnNvclxuICogQGNsYXNzIFNlbnNvclxuICogQG1vZHVsZSBTZW5zb3JcbiAqL1xuY2xhc3MgU2Vuc29yIHtcbiAgLyoqXG4gICAqIFNlbnNvciBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgU2Vuc29yXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29udGFpbmVyc1xuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBvcHRpb25zXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZHJhZyBzdGF0ZVxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29udGFpbmVyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWluZXJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXG4gICAqIEByZXR1cm4ge1NlbnNvcn1cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIHNlbnNvciBpbnN0YW5jZVxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gdGhpcyBzZW5zb3JcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZENvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxuICAgKi9cbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4udGhpcy5jb250YWluZXJzLCAuLi5jb250YWluZXJzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNvbnRhaW5lciBmcm9tIHRoaXMgc2Vuc29yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIHRoaXMgc2Vuc29yXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVDb250YWluZXIoZG9jdW1lbnQuYm9keSlcbiAgICovXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXJzID0gdGhpcy5jb250YWluZXJzLmZpbHRlcihjb250YWluZXIgPT4gIWNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgZXZlbnQgb24gdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdHJpZ2dlciBldmVudCBvblxuICAgKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzZW5zb3JFdmVudCAtIFNlbnNvciBldmVudCB0byB0cmlnZ2VyXG4gICAqL1xuICB0cmlnZ2VyKGVsZW1lbnQsIHNlbnNvckV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5kZXRhaWwgPSBzZW5zb3JFdmVudDtcbiAgICBldmVudC5pbml0RXZlbnQoc2Vuc29yRXZlbnQudHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmxhc3RFdmVudCA9IHNlbnNvckV2ZW50O1xuXG4gICAgcmV0dXJuIHNlbnNvckV2ZW50O1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZW5zb3I7XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWU7XG5mdW5jdGlvbiByZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gIH0pO1xufVxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lMi5kZWZhdWx0O1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9zZXN0O1xuY29uc3QgbWF0Y2hGdW5jdGlvbiA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuLyoqXG4gKiBHZXQgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnQgb2YgYSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgY2hpbGQgZWxlbWVudCB0byBmaW5kIGEgcGFyZW50IG9mXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcbiAqICAgICB0aGUgcGFyZW50IGVsZW1lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdChlbGVtZW50LCB2YWx1ZSkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XG4gIGNvbnN0IGNhbGxiYWNrID0gdmFsdWU7XG4gIGNvbnN0IG5vZGVMaXN0ID0gdmFsdWU7XG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcblxuICBjb25zdCBpc1NlbGVjdG9yID0gQm9vbGVhbih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKTtcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcbiAgY29uc3QgaXNOb2RlTGlzdCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KTtcbiAgY29uc3QgaXNFbGVtZW50ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcblxuICBmdW5jdGlvbiBjb25kaXRpb25GbihjdXJyZW50RWxlbWVudCkge1xuICAgIGlmICghY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKGlzU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBtYXRjaEZ1bmN0aW9uLmNhbGwoY3VycmVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcbiAgICAgIHJldHVybiBbLi4ubm9kZUxpc3RdLmluY2x1ZGVzKGN1cnJlbnRFbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGN1cnJlbnRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuXG4gIGRvIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCB8fCBjdXJyZW50LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGN1cnJlbnQ7XG5cbiAgICBpZiAoY29uZGl0aW9uRm4oY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbG9zZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Nsb3Nlc3QyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLnNjcm9sbCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IHNjcm9sbCA9IGV4cG9ydHMuc2Nyb2xsID0gU3ltYm9sKCdzY3JvbGwnKTtcblxuLyoqXG4gKiBTY3JvbGxhYmxlIGRlZmF1bHQgb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc3BlZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZWZhdWx0T3B0aW9ucy5zZW5zaXRpdml0eVxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBkZWZhdWx0T3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3BlZWQ6IDYsXG4gIHNlbnNpdGl2aXR5OiA1MCxcbiAgc2Nyb2xsYWJsZUVsZW1lbnRzOiBbXVxufTtcblxuLyoqXG4gKiBTY3JvbGxhYmxlIHBsdWdpbiB3aGljaCBzY3JvbGxzIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50XG4gKiBAY2xhc3MgU2Nyb2xsYWJsZVxuICogQG1vZHVsZSBTY3JvbGxhYmxlXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuICovXG5jbGFzcyBTY3JvbGxhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIFNjcm9sbGFibGUgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RzIFNjcm9sbGFibGVcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbGFibGUgb3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zZW5zaXRpdml0eVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gb3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xuXG4gICAgLyoqXG4gICAgICogS2VlcHMgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjdXJyZW50TW91c2VQb3NpdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFlcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgYW5pbWF0aW9uIGZyYW1lXG4gICAgICogQHByb3BlcnR5IHNjcm9sbEFuaW1hdGlvbkZyYW1lXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsYWJsZUVsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBsb29raW5nIGZvciB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkgZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XG5cbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbc2Nyb2xsXSA9IHRoaXNbc2Nyb2xsXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLnNjcm9sbGFibGUgfHwge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjbG9zZXN0IHNjcm9sbGFibGUgZWxlbWVudHMgYnkgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXRTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5oYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkpIHtcbiAgICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cykgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xvc2VzdFNjcm9sbGFibGVFbGVtZW50KHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc2Nyb2xsYWJsZSBlbGVtZW50IGhhdmUgYmVlbiBkZWZpbmVkIHZpYSBvcHRpb25zXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzRGVmaW5lZFNjcm9sbGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzLmxlbmd0aCAhPT0gMCk7XG4gIH1cblxuICAvKipcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyLiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGluIHNlcGFyYXRlIGZyYW1lXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGRyYWdFdmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWcgbW92ZSBoYW5kbGVyLiBSZW1lbWJlcnMgbW91c2UgcG9zaXRpb24gYW5kIGluaXRpYXRlcyBzY3JvbGxpbmdcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBkcmFnRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zZW5zb3JFdmVudC50YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLnNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBkcmFnRXZlbnQuc2Vuc29yRXZlbnQ7XG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICBzY3JvbGxPZmZzZXQueSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICBzY3JvbGxPZmZzZXQueCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgMDtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0ge1xuICAgICAgY2xpZW50WDogc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNjcm9sbE9mZnNldC54LFxuICAgICAgY2xpZW50WTogc2Vuc29yRXZlbnQuY2xpZW50WSAtIHNjcm9sbE9mZnNldC55XG4gICAgfTtcblxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpc1tzY3JvbGxdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIHN0b3AgaGFuZGxlci4gQ2FuY2VscyBzY3JvbGwgYW5pbWF0aW9ucyBhbmQgcmVzZXRzIHN0YXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25EcmFnU3RvcF0oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSk7XG5cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBoZWF2eWxpZnRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtzY3JvbGxdKCkge1xuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCB8fCAhdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xuXG4gICAgY29uc3QgeyBzcGVlZCwgc2Vuc2l0aXZpdHkgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGJvdHRvbUN1dE9mZiA9IHJlY3QuYm90dG9tID4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcbiAgICBjb25zdCBjdXRPZmYgPSB0b3BDdXRPZmYgfHwgYm90dG9tQ3V0T2ZmO1xuXG4gICAgY29uc3QgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLnNjcm9sbGFibGVFbGVtZW50O1xuICAgIGNvbnN0IGNsaWVudFggPSB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uLmNsaWVudFg7XG4gICAgY29uc3QgY2xpZW50WSA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WTtcblxuICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBzY3JvbGxhYmxlRWxlbWVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFjdXRPZmYpIHtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XG5cbiAgICAgIGlmIChyZWN0LnRvcCArIG9mZnNldEhlaWdodCAtIGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFkgLSByZWN0LnRvcCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY3QubGVmdCArIG9mZnNldFdpZHRoIC0gY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudFggLSByZWN0LmxlZnQgPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0IC09IHNwZWVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XG5cbiAgICAgIGlmIChjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCAtPSBzcGVlZDtcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCArPSBzcGVlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCArPSBzcGVlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXNbc2Nyb2xsXSk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsYWJsZTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuZnVuY3Rpb24gaGFzT3ZlcmZsb3coZWxlbWVudCkge1xuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbCkvO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgY29uc3Qgb3ZlcmZsb3cgPSBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteScpICsgY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpO1xuXG4gIHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3Qob3ZlcmZsb3cpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdGF0aWNhbGx5UG9zaXRpb25lZChlbGVtZW50KSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG4vKipcbiAqIEZpbmRzIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcbiAgfVxuXG4gIGNvbnN0IHBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuXG4gIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KShlbGVtZW50LCBwYXJlbnQgPT4ge1xuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50cyAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc092ZXJmbG93KHBhcmVudCk7XG4gIH0pO1xuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNjcm9sbGFibGVFbGVtZW50O1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBlbGVtZW50IHRoYXQgc2Nyb2xscyBkb2N1bWVudFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKSB7XG4gIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcblxudmFyIF9TY3JvbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cbnZhciBfU2Nyb2xsYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TY3JvbGxhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX1Njcm9sbGFibGUyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1Njcm9sbGFibGUuZGVmYXVsdE9wdGlvbnM7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBleHBvcnRzLk1pcnJvckF0dGFjaGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IGV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBleHBvcnRzLk1pcnJvckV2ZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQmFzZSBtaXJyb3IgZXZlbnRcbiAqIEBjbGFzcyBNaXJyb3JFdmVudFxuICogQG1vZHVsZSBNaXJyb3JFdmVudFxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxuICovXG5jbGFzcyBNaXJyb3JFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcbiAgLyoqXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHNvdXJjZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogRHJhZ2dhYmxlcyBzb3VyY2UgY29udGFpbmVyIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZUNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5zb3IgZXZlbnRcbiAgICogQHByb3BlcnR5IHNlbnNvckV2ZW50XG4gICAqIEB0eXBlIHtTZW5zb3JFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2Vuc29yRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcbiAgICogQHR5cGUge0RyYWdFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZHJhZ0V2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZHJhZ0V2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIE9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHNlbnNvciBldmVudFxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxuICAgKiBAdHlwZSB7RXZlbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG9yaWdpbmFsRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuc2Vuc29yRXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5NaXJyb3JFdmVudCA9IE1pcnJvckV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7fVxuXG5leHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gTWlycm9yQ3JlYXRlRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgY3JlYXRlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yQ3JlYXRlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5NaXJyb3JDcmVhdGVFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGUnO1xuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBNaXJyb3JDcmVhdGVkRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBhdHRhY2hlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JBdHRhY2hlZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuTWlycm9yQ3JlYXRlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmNyZWF0ZWQnO1xuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcblxuICAvKipcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgbWlycm9yXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG59XG5cbmV4cG9ydHMuTWlycm9yQXR0YWNoZWRFdmVudCA9IE1pcnJvckF0dGFjaGVkRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIG1vdmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JNb3ZlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yTW92ZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbk1pcnJvckF0dGFjaGVkRXZlbnQudHlwZSA9ICdtaXJyb3I6YXR0YWNoZWQnO1xuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0cy5NaXJyb3JNb3ZlRXZlbnQgPSBNaXJyb3JNb3ZlRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBkZXN0cm95IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgTWlycm9yRGVzdHJveUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuTWlycm9yTW92ZUV2ZW50LnR5cGUgPSAnbWlycm9yOm1vdmUnO1xuTWlycm9yTW92ZUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgTWlycm9yRGVzdHJveUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBtaXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XG4gIH1cbn1cbmV4cG9ydHMuTWlycm9yRGVzdHJveUV2ZW50ID0gTWlycm9yRGVzdHJveUV2ZW50O1xuTWlycm9yRGVzdHJveUV2ZW50LnR5cGUgPSAnbWlycm9yOmRlc3Ryb3knO1xuTWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWlycm9yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcblxuT2JqZWN0LmtleXMoX01pcnJvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfTWlycm9yRXZlbnRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLm9uU2Nyb2xsID0gZXhwb3J0cy5vbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25EcmFnU3RvcCA9IGV4cG9ydHMub25EcmFnTW92ZSA9IGV4cG9ydHMub25EcmFnU3RhcnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcbmNvbnN0IG9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcbmNvbnN0IG9uTWlycm9yQ3JlYXRlZCA9IGV4cG9ydHMub25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcbmNvbnN0IG9uTWlycm9yTW92ZSA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gU3ltYm9sKCdvbk1pcnJvck1vdmUnKTtcbmNvbnN0IG9uU2Nyb2xsID0gZXhwb3J0cy5vblNjcm9sbCA9IFN5bWJvbCgnb25TY3JvbGwnKTtcbmNvbnN0IGdldEFwcGVuZGFibGVDb250YWluZXIgPSBleHBvcnRzLmdldEFwcGVuZGFibGVDb250YWluZXIgPSBTeW1ib2woJ2dldEFwcGVuZGFibGVDb250YWluZXInKTtcblxuLyoqXG4gKiBNaXJyb3IgZGVmYXVsdCBvcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy54QXhpc1xuICogQHByb3BlcnR5IHtCb29sZWFufSBkZWZhdWx0T3B0aW9ucy55QXhpc1xuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRYXG4gKiBAcHJvcGVydHkge251bGx9IGRlZmF1bHRPcHRpb25zLmN1cnNvck9mZnNldFlcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgY29uc3RyYWluRGltZW5zaW9uczogZmFsc2UsXG4gIHhBeGlzOiB0cnVlLFxuICB5QXhpczogdHJ1ZSxcbiAgY3Vyc29yT2Zmc2V0WDogbnVsbCxcbiAgY3Vyc29yT2Zmc2V0WTogbnVsbFxufTtcblxuLyoqXG4gKiBNaXJyb3IgcGx1Z2luIHdoaWNoIGNvbnRyb2xzIHRoZSBtaXJyb3IgcG9zaXRpb25pbmcgd2hpbGUgZHJhZ2dpbmdcbiAqIEBjbGFzcyBNaXJyb3JcbiAqIEBtb2R1bGUgTWlycm9yXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuICovXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xuICAvKipcbiAgICogTWlycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBNaXJyb3JcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIC8qKlxuICAgICAqIE1pcnJvciBvcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy54QXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gb3B0aW9ucy55QXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufSBvcHRpb25zLmFwcGVuZFRvXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBvZmZzZXQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSB0aGUgbWlycm9yIGlzIHBvc2l0aW9uZWQgZml4ZWRcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC54XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjcm9sbE9mZnNldC55XG4gICAgICovXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWwgc2Nyb2xsIG9mZnNldCBmb3IgdG91Y2ggZGV2aWNlcyBiZWNhdXNlIHRoZSBtaXJyb3IgaXMgcG9zaXRpb25lZCBmaXhlZFxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY3JvbGxPZmZzZXRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnlcbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcblxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbk1pcnJvck1vdmVdID0gdGhpc1tvbk1pcnJvck1vdmVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvblNjcm9sbF0gPSB0aGlzW29uU2Nyb2xsXS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6bW92ZScsIHRoaXNbb25NaXJyb3JNb3ZlXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBkcmFnZ2FibGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5taXJyb3IgfHwge307XG4gIH1cblxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNbb25TY3JvbGxdLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZXG4gICAgfTtcblxuICAgIGNvbnN0IHsgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgc291cmNlQ29udGFpbmVyLCBzZW5zb3JFdmVudCB9ID0gZHJhZ0V2ZW50O1xuXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBkcmFnRXZlbnRcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlRXZlbnQpO1xuXG4gICAgaWYgKGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB8fCBtaXJyb3JDcmVhdGVFdmVudC5jYW5jZWxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXBwZW5kYWJsZUNvbnRhaW5lciA9IHRoaXNbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB8fCBzb3VyY2VDb250YWluZXI7XG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JDcmVhdGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcblxuICAgIGNvbnN0IG1pcnJvckF0dGFjaGVkRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckF0dGFjaGVkRXZlbnQoe1xuICAgICAgc291cmNlLFxuICAgICAgb3JpZ2luYWxTb3VyY2UsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudCxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3JcbiAgICB9KTtcblxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQ3JlYXRlZEV2ZW50KTtcbiAgICBhcHBlbmRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckF0dGFjaGVkRXZlbnQpO1xuICB9XG5cbiAgW29uRHJhZ01vdmVdKGRyYWdFdmVudCkge1xuICAgIGlmICghdGhpcy5taXJyb3IgfHwgZHJhZ0V2ZW50LmNhbmNlbGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcblxuICAgIGNvbnN0IG1pcnJvck1vdmVFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yTW92ZUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsU291cmNlLFxuICAgICAgc291cmNlQ29udGFpbmVyLFxuICAgICAgc2Vuc29yRXZlbnQsXG4gICAgICBkcmFnRXZlbnQsXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXG4gICAgfSk7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvck1vdmVFdmVudCk7XG4gIH1cblxuICBbb25EcmFnU3RvcF0oZHJhZ0V2ZW50KSB7XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1tvblNjcm9sbF0sIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICBpZiAoIXRoaXMubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcblxuICAgIGNvbnN0IG1pcnJvckRlc3Ryb3lFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yRGVzdHJveUV2ZW50KHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICBzb3VyY2VDb250YWluZXIsXG4gICAgICBzZW5zb3JFdmVudCxcbiAgICAgIGRyYWdFdmVudFxuICAgIH0pO1xuXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JEZXN0cm95RXZlbnQpO1xuXG4gICAgaWYgKCFtaXJyb3JEZXN0cm95RXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgdGhpcy5taXJyb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1pcnJvcik7XG4gICAgfVxuICB9XG5cbiAgW29uU2Nyb2xsXSgpIHtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHtcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWSAtIHRoaXMuaW5pdGlhbFNjcm9sbE9mZnNldC55XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IsIHNvdXJjZSwgc2Vuc29yRXZlbnQgfSkge1xuICAgIGNvbnN0IG1pcnJvckNsYXNzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lRm9yKCdtaXJyb3InKTtcblxuICAgIGNvbnN0IHNldFN0YXRlID0gKF9yZWYpID0+IHtcbiAgICAgIGxldCB7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0gPSBfcmVmLFxuICAgICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFgnLCAnaW5pdGlhbFknXSk7XG5cbiAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgICAgdGhpcy5pbml0aWFsWCA9IGluaXRpYWxYO1xuICAgICAgdGhpcy5pbml0aWFsWSA9IGluaXRpYWxZO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSwgYXJncyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgIG1pcnJvcixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbnNvckV2ZW50LFxuICAgICAgbWlycm9yQ2xhc3MsXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0LFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXG4gICAgfTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKVxuICAgIC8vIEZpeCByZWZsb3cgaGVyZVxuICAgIC50aGVuKGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKS50aGVuKGNhbGN1bGF0ZU1pcnJvck9mZnNldCkudGhlbihyZXNldE1pcnJvcikudGhlbihhZGRNaXJyb3JDbGFzc2VzKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgaW5pdGlhbDogdHJ1ZSB9KSkudGhlbihyZW1vdmVNaXJyb3JJRCkudGhlbihzZXRTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWlycm9yIG1vdmUgaGFuZGxlclxuICAgKiBAcGFyYW0ge01pcnJvck1vdmVFdmVudH0gbWlycm9yRXZlbnRcbiAgICogQHJldHVybiB7UHJvbWlzZXxudWxsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uTWlycm9yTW92ZV0obWlycm9yRXZlbnQpIHtcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgbWlycm9yOiBtaXJyb3JFdmVudC5taXJyb3IsXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXG4gICAgICBtaXJyb3JPZmZzZXQ6IHRoaXMubWlycm9yT2Zmc2V0LFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXG4gICAgICBpbml0aWFsWTogdGhpcy5pbml0aWFsWSxcbiAgICAgIHNjcm9sbE9mZnNldDogdGhpcy5zY3JvbGxPZmZzZXRcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbml0aWFsU3RhdGUpLnRoZW4ocG9zaXRpb25NaXJyb3IoeyByYWY6IHRydWUgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXBwZW5kYWJsZSBjb250YWluZXIgZm9yIG1pcnJvciBiYXNlZCBvbiB0aGUgYXBwZW5kVG8gb3B0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc291cmNlIC0gQ3VycmVudCBzb3VyY2VcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB7XG4gICAgY29uc3QgYXBwZW5kVG8gPSB0aGlzLm9wdGlvbnMuYXBwZW5kVG87XG5cbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pO1xuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYXBwZW5kVG8oc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNvdXJjZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBNaXJyb3I7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb21wdXRlcyBtaXJyb3IgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWRkcyBzb3VyY2VSZWN0IHRvIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKF9yZWYyKSB7XG4gIGxldCB7IHNvdXJjZSB9ID0gX3JlZjIsXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3NvdXJjZSddKTtcblxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3Qgc291cmNlUmVjdCA9IHNvdXJjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc291cmNlLCBzb3VyY2VSZWN0IH0sIGFyZ3MpKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBtaXJyb3Igb2Zmc2V0XG4gKiBBZGRzIG1pcnJvck9mZnNldCB0byBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxuICogQHBhcmFtIHtET01SZWN0fSBzdGF0ZS5zb3VyY2VSZWN0XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTWlycm9yT2Zmc2V0KF9yZWYzKSB7XG4gIGxldCB7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBvcHRpb25zIH0gPSBfcmVmMyxcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc2Vuc29yRXZlbnQnLCAnc291cmNlUmVjdCcsICdvcHRpb25zJ10pO1xuXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCB0b3AgPSBvcHRpb25zLmN1cnNvck9mZnNldFkgPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRZIC0gc291cmNlUmVjdC50b3AgOiBvcHRpb25zLmN1cnNvck9mZnNldFk7XG4gICAgY29uc3QgbGVmdCA9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WCA9PT0gbnVsbCA/IHNlbnNvckV2ZW50LmNsaWVudFggLSBzb3VyY2VSZWN0LmxlZnQgOiBvcHRpb25zLmN1cnNvck9mZnNldFg7XG5cbiAgICBjb25zdCBtaXJyb3JPZmZzZXQgPSB7IHRvcCwgbGVmdCB9O1xuXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IHNlbnNvckV2ZW50LCBzb3VyY2VSZWN0LCBtaXJyb3JPZmZzZXQsIG9wdGlvbnMgfSwgYXJncykpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcHBseXMgbWlycm9yIHN0eWxlc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNldE1pcnJvcihfcmVmNCkge1xuICBsZXQgeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9ID0gX3JlZjQsXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY0LCBbJ21pcnJvcicsICdzb3VyY2UnLCAnb3B0aW9ucyddKTtcblxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IG9mZnNldEhlaWdodDtcbiAgICBsZXQgb2Zmc2V0V2lkdGg7XG5cbiAgICBpZiAob3B0aW9ucy5jb25zdHJhaW5EaW1lbnNpb25zKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFNvdXJjZVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcbiAgICAgIG9mZnNldEhlaWdodCA9IGNvbXB1dGVkU291cmNlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpO1xuICAgICAgb2Zmc2V0V2lkdGggPSBjb21wdXRlZFNvdXJjZVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpO1xuICAgIH1cblxuICAgIG1pcnJvci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgbWlycm9yLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgbWlycm9yLnN0eWxlLnRvcCA9IDA7XG4gICAgbWlycm9yLnN0eWxlLmxlZnQgPSAwO1xuICAgIG1pcnJvci5zdHlsZS5tYXJnaW4gPSAwO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xuICAgICAgbWlycm9yLnN0eWxlLmhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgICAgIG1pcnJvci5zdHlsZS53aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIHNvdXJjZSwgb3B0aW9ucyB9LCBhcmdzKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5cyBtaXJyb3IgY2xhc3Mgb24gbWlycm9yIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUubWlycm9yQ2xhc3NcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRNaXJyb3JDbGFzc2VzKF9yZWY1KSB7XG4gIGxldCB7IG1pcnJvciwgbWlycm9yQ2xhc3MgfSA9IF9yZWY1LFxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNSwgWydtaXJyb3InLCAnbWlycm9yQ2xhc3MnXSk7XG5cbiAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKG1pcnJvckNsYXNzKTtcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgbWlycm9yLCBtaXJyb3JDbGFzcyB9LCBhcmdzKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgc291cmNlIElEIGZyb20gY2xvbmVkIG1pcnJvciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKF9yZWY2KSB7XG4gIGxldCB7IG1pcnJvciB9ID0gX3JlZjYsXG4gICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY2LCBbJ21pcnJvciddKTtcblxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbWlycm9yLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICBkZWxldGUgbWlycm9yLmlkO1xuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IgfSwgYXJncykpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQb3NpdGlvbnMgbWlycm9yIHdpdGggdHJhbnNsYXRlM2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUubWlycm9yXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm1pcnJvck9mZnNldFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXRlLmluaXRpYWxZXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFhcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcG9zaXRpb25NaXJyb3IoeyB3aXRoRnJhbWUgPSBmYWxzZSwgaW5pdGlhbCA9IGZhbHNlIH0gPSB7fSkge1xuICByZXR1cm4gKF9yZWY3KSA9PiB7XG4gICAgbGV0IHsgbWlycm9yLCBzZW5zb3JFdmVudCwgbWlycm9yT2Zmc2V0LCBpbml0aWFsWSwgaW5pdGlhbFgsIHNjcm9sbE9mZnNldCwgb3B0aW9ucyB9ID0gX3JlZjcsXG4gICAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjcsIFsnbWlycm9yJywgJ3NlbnNvckV2ZW50JywgJ21pcnJvck9mZnNldCcsICdpbml0aWFsWScsICdpbml0aWFsWCcsICdzY3JvbGxPZmZzZXQnLCAnb3B0aW9ucyddKTtcblxuICAgIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IF9leHRlbmRzKHtcbiAgICAgICAgbWlycm9yLFxuICAgICAgICBzZW5zb3JFdmVudCxcbiAgICAgICAgbWlycm9yT2Zmc2V0LFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBhcmdzKTtcblxuICAgICAgaWYgKG1pcnJvck9mZnNldCkge1xuICAgICAgICBjb25zdCB4ID0gc2Vuc29yRXZlbnQuY2xpZW50WCAtIG1pcnJvck9mZnNldC5sZWZ0IC0gc2Nyb2xsT2Zmc2V0Lng7XG4gICAgICAgIGNvbnN0IHkgPSBzZW5zb3JFdmVudC5jbGllbnRZIC0gbWlycm9yT2Zmc2V0LnRvcCAtIHNjcm9sbE9mZnNldC55O1xuXG4gICAgICAgIGlmIChvcHRpb25zLnhBeGlzICYmIG9wdGlvbnMueUF4aXMgfHwgaW5pdGlhbCkge1xuICAgICAgICAgIG1pcnJvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7aW5pdGlhbFl9cHgsIDApYDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnlBeGlzICYmICFvcHRpb25zLnhBeGlzKSB7XG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxYID0geDtcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9LCB7IGZyYW1lOiB3aXRoRnJhbWUgfSk7XG4gIH07XG59XG5cbi8qKlxuICogV3JhcHMgZnVuY3Rpb25zIGluIHByb21pc2Ugd2l0aCBwb3RlbnRpYWwgYW5pbWF0aW9uIGZyYW1lIG9wdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmFmXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd2l0aFByb21pc2UoY2FsbGJhY2ssIHsgcmFmID0gZmFsc2UgfSA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHJhZikge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZW5zb3IgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBhIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRHJhZ0V2ZW50KHNlbnNvckV2ZW50KSB7XG4gIHJldHVybiAoL15kcmFnLy50ZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSlcbiAgKTtcbn1cblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcblxudmFyIF9NaXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9NaXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX01pcnJvcjIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfTWlycm9yLmRlZmF1bHRPcHRpb25zO1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XG5cbi8qKlxuICogRm9jdXNhYmxlIGRlZmF1bHQgb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEZvY3VzYWJsZSBwbHVnaW5cbiAqIEBjbGFzcyBGb2N1c2FibGVcbiAqIEBtb2R1bGUgRm9jdXNhYmxlXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxuICovXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xuICAvKipcbiAgICogRm9jdXNhYmxlIGNvbnN0cnVjdG9yLlxuICAgKiBAY29uc3RydWN0cyBGb2N1c2FibGVcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcblxuICAgIC8qKlxuICAgICAqIEZvY3VzYWJsZSBvcHRpb25zXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xuXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XG4gICAgdGhpc1tvbkRlc3Ryb3ldID0gdGhpc1tvbkRlc3Ryb3ldLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxuICAgKi9cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBsaXN0ZW5lcnMgZnJvbSBkcmFnZ2FibGVcbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWdnYWJsZTppbml0aWFsaXplJywgdGhpc1tvbkluaXRpYWxpemVdKS5vZmYoJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuZm9jdXNhYmxlIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGNvbnRhaW5lcnMgYW5kIGVsZW1lbnRzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZHJhZ2dhYmxlLmNvbnRhaW5lcnMsIC4uLnRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGlhbGl6ZSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25Jbml0aWFsaXplXSgpIHtcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IGRlY29yYXRlRWxlbWVudChlbGVtZW50KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbb25EZXN0cm95XSgpIHtcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IHN0cmlwRWxlbWVudChlbGVtZW50KSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRm9jdXNhYmxlOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBtaXNzaW5nIHRhYmluZGV4IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc28gdGhleSBjYW4gYmUgcmVzZXQgd2hlbiBkcmFnZ2FibGUgZ2V0cyBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0IHtIVE1MRWxlbWVudFtdfSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbmNvbnN0IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleCA9IFtdO1xuXG4vKipcbiAqIERlY29yYXRlcyBlbGVtZW50IHdpdGggdGFiaW5kZXggYXR0cmlidXRlc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgaGFzTWlzc2luZ1RhYkluZGV4ID0gQm9vbGVhbighZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgZWxlbWVudC50YWJJbmRleCA9PT0gLTEpO1xuXG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcbiAgICBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXgucHVzaChlbGVtZW50KTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgZWxlbWVudHMgdGFiaW5kZXggYXR0cmlidXRlc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RyaXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgdGFiSW5kZXhFbGVtZW50UG9zaXRpb24gPSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAodGFiSW5kZXhFbGVtZW50UG9zaXRpb24gIT09IC0xKSB7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5zcGxpY2UodGFiSW5kZXhFbGVtZW50UG9zaXRpb24sIDEpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblxudmFyIF9Gb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0ZvY3VzYWJsZTIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBBbGwgZHJhZ2dhYmxlIHBsdWdpbnMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBBYnN0cmFjdFBsdWdpblxuICogQG1vZHVsZSBBYnN0cmFjdFBsdWdpblxuICovXG5jbGFzcyBBYnN0cmFjdFBsdWdpbiB7XG4gIC8qKlxuICAgKiBBYnN0cmFjdFBsdWdpbiBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RQbHVnaW5cbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XG4gICAgLyoqXG4gICAgICogRHJhZ2dhYmxlIGluc3RhbmNlXG4gICAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxuICAgICAqIEB0eXBlIHtEcmFnZ2FibGV9XG4gICAgICovXG4gICAgdGhpcy5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdG8gYWRkIGxpc3RlbmVyc1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRvIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RQbHVnaW47XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XG5jb25zdCBhbm5vdW5jZUV2ZW50ID0gU3ltYm9sKCdhbm5vdW5jZUV2ZW50Jyk7XG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xuXG5jb25zdCBBUklBX1JFTEVWQU5UID0gJ2FyaWEtcmVsZXZhbnQnO1xuY29uc3QgQVJJQV9BVE9NSUMgPSAnYXJpYS1hdG9taWMnO1xuY29uc3QgQVJJQV9MSVZFID0gJ2FyaWEtbGl2ZSc7XG5jb25zdCBST0xFID0gJ3JvbGUnO1xuXG4vKipcbiAqIEFubm91bmNlbWVudCBkZWZhdWx0IG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmV4cGlyZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuICBleHBpcmU6IDcwMDBcbn07XG5cbi8qKlxuICogQW5ub3VuY2VtZW50IHBsdWdpblxuICogQGNsYXNzIEFubm91bmNlbWVudFxuICogQG1vZHVsZSBBbm5vdW5jZW1lbnRcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXG4gKi9cbmNsYXNzIEFubm91bmNlbWVudCBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBBbm5vdW5jZW1lbnQgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RzIEFubm91bmNlbWVudFxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xuXG4gICAgLyoqXG4gICAgICogUGx1Z2luIG9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XG5cbiAgICAvKipcbiAgICAgKiBPcmlnaW5hbCBkcmFnZ2FibGUgdHJpZ2dlciBtZXRob2QuIEhhY2sgdW50aWwgd2UgaGF2ZSBvbkFsbCBvciBvbignYWxsJylcbiAgICAgKiBAcHJvcGVydHkgb3JpZ2luYWxUcmlnZ2VyTWV0aG9kXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kID0gdGhpcy5kcmFnZ2FibGUudHJpZ2dlcjtcblxuICAgIHRoaXNbb25Jbml0aWFsaXplXSA9IHRoaXNbb25Jbml0aWFsaXplXS5iaW5kKHRoaXMpO1xuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGFzc2VkIGluIG9wdGlvbnNcbiAgICovXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbm5vdW5jZXMgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudFxuICAgKi9cbiAgW2Fubm91bmNlRXZlbnRdKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9uc1tldmVudC50eXBlXTtcblxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1thbm5vdW5jZU1lc3NhZ2VdKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZShldmVudCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbm5vdW5jZXMgbWVzc2FnZSB0byBzY3JlZW4gcmVhZGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqL1xuICBbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKSB7XG4gICAgYW5ub3VuY2UobWVzc2FnZSwgeyBleHBpcmU6IHRoaXMub3B0aW9ucy5leHBpcmUgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBoYW5kZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtvbkluaXRpYWxpemVdKCkge1xuICAgIC8vIEhhY2sgdW50aWwgdGhlcmUgaXMgYW4gYXBpIGZvciBsaXN0ZW5pbmcgZm9yIGFsbCBldmVudHNcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gZXZlbnQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCBvcmlnaW5hbCB0cmlnZ2VyIGlzIGNhbGxlZFxuICAgICAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZC5jYWxsKHRoaXMuZHJhZ2dhYmxlLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGhhbmRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW29uRGVzdHJveV0oKSB7XG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlciA9IHRoaXMub3JpZ2luYWxUcmlnZ2VyTWV0aG9kO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFubm91bmNlbWVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnR9IGxpdmVSZWdpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcblxuLyoqXG4gKiBBbm5vdW5jZXMgbWVzc2FnZSB2aWEgbGl2ZSByZWdpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZXhwaXJlXG4gKi9cbmZ1bmN0aW9uIGFubm91bmNlKG1lc3NhZ2UsIHsgZXhwaXJlIH0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICBsaXZlUmVnaW9uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsaXZlUmVnaW9uLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9LCBleHBpcmUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgcmVnaW9uIGVsZW1lbnRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWdpb24oKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCAnZHJhZ2dhYmxlLWxpdmUtcmVnaW9uJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVJJQV9BVE9NSUMsICd0cnVlJyk7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfTElWRSwgJ2Fzc2VydGl2ZScpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XG5cbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMXB4JztcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgZWxlbWVudC5zdHlsZS50b3AgPSAnLTFweCc7XG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLy8gQXBwZW5kIGxpdmUgcmVnaW9uIGVsZW1lbnQgYXMgZWFybHkgYXMgcG9zc2libGVcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZVJlZ2lvbik7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcblxudmFyIF9Bbm5vdW5jZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcblxudmFyIF9Bbm5vdW5jZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5ub3VuY2VtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fubm91bmNlbWVudDIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfQW5ub3VuY2VtZW50LmRlZmF1bHRPcHRpb25zO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IGV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBCYXNlIGRyYWdnYWJsZSBldmVudFxuICogQGNsYXNzIERyYWdnYWJsZUV2ZW50XG4gKiBAbW9kdWxlIERyYWdnYWJsZUV2ZW50XG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XG4gKi9cbmNsYXNzIERyYWdnYWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGUgaW5zdGFuY2VcbiAgICogQHByb3BlcnR5IGRyYWdnYWJsZVxuICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkcmFnZ2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnZ2FibGU7XG4gIH1cbn1cblxuZXhwb3J0cy5EcmFnZ2FibGVFdmVudCA9IERyYWdnYWJsZUV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGluaXRpYWxpemVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ2dhYmxlRXZlbnQudHlwZSA9ICdkcmFnZ2FibGUnO1xuY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XG5cbmV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGRlc3RvcnkgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZURlc3Ryb3lFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ2dhYmxlRGVzdHJveUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudC50eXBlID0gJ2RyYWdnYWJsZTppbml0aWFsaXplJztcbmNsYXNzIERyYWdnYWJsZURlc3Ryb3lFdmVudCBleHRlbmRzIERyYWdnYWJsZUV2ZW50IHt9XG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IERyYWdnYWJsZURlc3Ryb3lFdmVudDtcbkRyYWdnYWJsZURlc3Ryb3lFdmVudC50eXBlID0gJ2RyYWdnYWJsZTpkZXN0cm95JztcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5jb25zdCBjYW5jZWxlZCA9IFN5bWJvbCgnY2FuY2VsZWQnKTtcblxuLyoqXG4gKiBBbGwgZXZlbnRzIGZpcmVkIGJ5IGRyYWdnYWJsZSBpbmhlcml0IHRoaXMgY2xhc3MuIFlvdSBjYW4gY2FsbCBgY2FuY2VsKClgIHRvXG4gKiBjYW5jZWwgYSBzcGVjaWZpYyBldmVudCBvciB5b3UgY2FuIGNoZWNrIGlmIGFuIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkIGJ5XG4gKiBjYWxsaW5nIGBjYW5jZWxlZCgpYC5cbiAqIEBhYnN0cmFjdFxuICogQGNsYXNzIEFic3RyYWN0RXZlbnRcbiAqIEBtb2R1bGUgQWJzdHJhY3RFdmVudFxuICovXG5jbGFzcyBBYnN0cmFjdEV2ZW50IHtcblxuICAvKipcbiAgICogQWJzdHJhY3RFdmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RFdmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEV2ZW50IGRhdGFcbiAgICovXG5cbiAgLyoqXG4gICAqIEV2ZW50IHR5cGVcbiAgICogQHN0YXRpY1xuICAgKiBAYWJzdHJhY3RcbiAgICogQHByb3BlcnR5IHR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzW2NhbmNlbGVkXSA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZC1vbmx5IHR5cGVcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICAvKipcbiAgICogRXZlbnQgY2FuY2VsYWJsZVxuICAgKiBAc3RhdGljXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmVhZC1vbmx5IGNhbmNlbGFibGVcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jYW5jZWxhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIGV2ZW50IGluc3RhbmNlXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXNbY2FuY2VsZWRdID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGNhbmNlbGVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXNbY2FuY2VsZWRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBldmVudCBpbnN0YW5jZSB3aXRoIGV4aXN0aW5nIGV2ZW50IGRhdGEuXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBmb3Igb3ZlcnJpZGluZyBvZiBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdEV2ZW50fVxuICAgKi9cbiAgY2xvbmUoZGF0YSkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihfZXh0ZW5kcyh7fSwgdGhpcy5kYXRhLCBkYXRhKSk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXZlbnQ7XG5BYnN0cmFjdEV2ZW50LnR5cGUgPSAnZXZlbnQnO1xuQWJzdHJhY3RFdmVudC5jYW5jZWxhYmxlID0gZmFsc2U7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IGV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ091dEV2ZW50ID0gZXhwb3J0cy5EcmFnT3ZlckV2ZW50ID0gZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gZXhwb3J0cy5EcmFnU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJhZ0V2ZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQmFzZSBkcmFnIGV2ZW50XG4gKiBAY2xhc3MgRHJhZ0V2ZW50XG4gKiBAbW9kdWxlIERyYWdFdmVudFxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxuICovXG5jbGFzcyBEcmFnRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHNvdXJjZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbFNvdXJjZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxuICAgKiBAcHJvcGVydHkgbWlycm9yXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWlycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VDb250YWluZXJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzb3VyY2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogU2Vuc29yIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBzZW5zb3JFdmVudFxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc2Vuc29yRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogT3JpZ2luYWwgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgc2Vuc29yIGV2ZW50XG4gICAqIEBwcm9wZXJ0eSBvcmlnaW5hbEV2ZW50XG4gICAqIEB0eXBlIHtFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcbiAgICBpZiAodGhpcy5zZW5zb3JFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vuc29yRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLkRyYWdFdmVudCA9IERyYWdFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdGFydCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0RXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ0V2ZW50LnR5cGUgPSAnZHJhZyc7XG5jbGFzcyBEcmFnU3RhcnRFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxuXG5leHBvcnRzLkRyYWdTdGFydEV2ZW50ID0gRHJhZ1N0YXJ0RXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcmFnTW92ZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ1N0YXJ0RXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcbkRyYWdTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgRHJhZ01vdmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxuXG5leHBvcnRzLkRyYWdNb3ZlRXZlbnQgPSBEcmFnTW92ZUV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ092ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ01vdmVFdmVudC50eXBlID0gJ2RyYWc6bW92ZSc7XG5jbGFzcyBEcmFnT3ZlckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICAvKipcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgYXJlIG92ZXJcbiAgICogQHByb3BlcnR5IG92ZXJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcbiAgfVxufVxuXG5leHBvcnRzLkRyYWdPdmVyRXZlbnQgPSBEcmFnT3ZlckV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3V0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ091dEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdXRFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ092ZXJFdmVudC50eXBlID0gJ2RyYWc6b3Zlcic7XG5EcmFnT3ZlckV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuY2xhc3MgRHJhZ091dEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcblxuICAvKipcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgbGVmdFxuICAgKiBAcHJvcGVydHkgb3ZlclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG92ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xuICB9XG59XG5cbmV4cG9ydHMuRHJhZ091dEV2ZW50ID0gRHJhZ091dEV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG92ZXIgY29udGFpbmVyIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuRHJhZ091dEV2ZW50LnR5cGUgPSAnZHJhZzpvdXQnO1xuY2xhc3MgRHJhZ092ZXJDb250YWluZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgLyoqXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuZXhwb3J0cy5EcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gRHJhZ092ZXJDb250YWluZXJFdmVudDsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBjb250YWluZXIgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ091dENvbnRhaW5lckV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5EcmFnT3ZlckNvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdmVyOmNvbnRhaW5lcic7XG5jbGFzcyBEcmFnT3V0Q29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xuXG4gIC8qKlxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBsZWZ0XG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XG4gIH1cbn1cblxuZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBEcmFnT3V0Q29udGFpbmVyRXZlbnQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgcHJlc3N1cmUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdQcmVzc3VyZUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJhZ0V2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbkRyYWdPdXRDb250YWluZXJFdmVudC50eXBlID0gJ2RyYWc6b3V0OmNvbnRhaW5lcic7XG5jbGFzcyBEcmFnUHJlc3N1cmVFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XG5cbiAgLyoqXG4gICAqIFByZXNzdXJlIGFwcGxpZWQgb24gZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXNzdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucHJlc3N1cmU7XG4gIH1cbn1cblxuZXhwb3J0cy5EcmFnUHJlc3N1cmVFdmVudCA9IERyYWdQcmVzc3VyZUV2ZW50OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RvcEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbkRyYWdQcmVzc3VyZUV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XG5jbGFzcyBEcmFnU3RvcEV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XG5leHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBEcmFnU3RvcEV2ZW50O1xuRHJhZ1N0b3BFdmVudC50eXBlID0gJ2RyYWc6c3RvcCc7XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUGx1Z2lucyA9IGV4cG9ydHMuU2Vuc29ycyA9IGV4cG9ydHMuU29ydGFibGUgPSBleHBvcnRzLlN3YXBwYWJsZSA9IGV4cG9ydHMuRHJvcHBhYmxlID0gZXhwb3J0cy5EcmFnZ2FibGUgPSBleHBvcnRzLkJhc2VQbHVnaW4gPSBleHBvcnRzLkJhc2VFdmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RyYWdnYWJsZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdnYWJsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRHJvcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRHJvcHBhYmxlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJvcHBhYmxlKS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9Td2FwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTd2FwcGFibGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Td2FwcGFibGUpLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1NvcnRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU29ydGFibGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Tb3J0YWJsZSkuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcblxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xuXG52YXIgX1NlbnNvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgU2Vuc29ycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9TZW5zb3JzKTtcblxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbnZhciBQbHVnaW5zID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1BsdWdpbnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLkJhc2VFdmVudCA9IF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0O1xuZXhwb3J0cy5CYXNlUGx1Z2luID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xuZXhwb3J0cy5TZW5zb3JzID0gU2Vuc29ycztcbmV4cG9ydHMuUGx1Z2lucyA9IFBsdWdpbnM7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*Copyrights for code authored by Yahoo Inc. is licensed under the following terms:\nMIT License\nCopyright  2017 Yahoo Inc.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n;(function(window, document, navigator, undefined) {\n\"use strict\";\n\n/*\n  utils.js\n  ========\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nvar utils = {\n    URL: window.URL || window.webkitURL || window.mozURL || window.msURL,\n    getUserMedia: function () {\n        var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\n        return getUserMedia ? getUserMedia.bind(navigator) : getUserMedia;\n    }(),\n    requestAnimFrame: window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,\n    requestTimeout: function requestTimeout(callback, delay) {\n        callback = callback || utils.noop;\n        delay = delay || 0;\n\n        if (!utils.requestAnimFrame) {\n            return setTimeout(callback, delay);\n        }\n\n        var start = new Date().getTime();\n        var handle = new Object();\n        var requestAnimFrame = utils.requestAnimFrame;\n\n        var loop = function loop() {\n            var current = new Date().getTime();\n            var delta = current - start;\n\n            delta >= delay ? callback.call() : handle.value = requestAnimFrame(loop);\n        };\n\n        handle.value = requestAnimFrame(loop);\n\n        return handle;\n    },\n    Blob: window.Blob || window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n    btoa: function () {\n        var btoa = window.btoa || function (input) {\n            var output = '';\n            var i = 0;\n            var l = input.length;\n            var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n            var chr1 = void 0;\n            var chr2 = void 0;\n            var chr3 = void 0;\n            var enc1 = void 0;\n            var enc2 = void 0;\n            var enc3 = void 0;\n            var enc4 = void 0;\n\n            while (i < l) {\n                chr1 = input.charCodeAt(i++);\n                chr2 = input.charCodeAt(i++);\n                chr3 = input.charCodeAt(i++);\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n\n                output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);\n            }\n\n            return output;\n        };\n\n        return btoa ? btoa.bind(window) : utils.noop;\n    }(),\n    isObject: function isObject(obj) {\n        return obj && Object.prototype.toString.call(obj) === '[object Object]';\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n        return utils.isObject(obj) && !Object.keys(obj).length;\n    },\n    isArray: function isArray(arr) {\n        return arr && Array.isArray(arr);\n    },\n    isFunction: function isFunction(func) {\n        return func && typeof func === 'function';\n    },\n    isElement: function isElement(elem) {\n        return elem && elem.nodeType === 1;\n    },\n    isString: function isString(value) {\n        return typeof value === 'string' || Object.prototype.toString.call(value) === '[object String]';\n    },\n    isSupported: {\n        canvas: function canvas() {\n            var el = document.createElement('canvas');\n\n            return el && el.getContext && el.getContext('2d');\n        },\n        webworkers: function webworkers() {\n            return window.Worker;\n        },\n        blob: function blob() {\n            return utils.Blob;\n        },\n        Uint8Array: function Uint8Array() {\n            return window.Uint8Array;\n        },\n        Uint32Array: function Uint32Array() {\n            return window.Uint32Array;\n        },\n        videoCodecs: function () {\n            var testEl = document.createElement('video');\n            var supportObj = {\n                'mp4': false,\n                'h264': false,\n                'ogv': false,\n                'ogg': false,\n                'webm': false\n            };\n\n            try {\n                if (testEl && testEl.canPlayType) {\n                    // Check for MPEG-4 support\n                    supportObj.mp4 = testEl.canPlayType('video/mp4; codecs=\"mp4v.20.8\"') !== '';\n\n                    // Check for h264 support\n                    supportObj.h264 = (testEl.canPlayType('video/mp4; codecs=\"avc1.42E01E\"') || testEl.canPlayType('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"')) !== '';\n\n                    // Check for Ogv support\n                    supportObj.ogv = testEl.canPlayType('video/ogg; codecs=\"theora\"') !== '';\n\n                    // Check for Ogg support\n                    supportObj.ogg = testEl.canPlayType('video/ogg; codecs=\"theora\"') !== '';\n\n                    // Check for Webm support\n                    supportObj.webm = testEl.canPlayType('video/webm; codecs=\"vp8, vorbis\"') !== -1;\n                }\n            } catch (e) {}\n\n            return supportObj;\n        }()\n    },\n    noop: function noop() {},\n    each: function each(collection, callback) {\n        var x = void 0;\n        var len = void 0;\n\n        if (utils.isArray(collection)) {\n            x = -1;\n            len = collection.length;\n\n            while (++x < len) {\n                if (callback(x, collection[x]) === false) {\n                    break;\n                }\n            }\n        } else if (utils.isObject(collection)) {\n            for (x in collection) {\n                if (collection.hasOwnProperty(x)) {\n                    if (callback(x, collection[x]) === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    },\n    mergeOptions: function mergeOptions(defaultOptions, userOptions) {\n        if (!utils.isObject(defaultOptions) || !utils.isObject(userOptions) || !Object.keys) {\n            return;\n        }\n\n        var newObj = {};\n\n        utils.each(defaultOptions, function (key, val) {\n            newObj[key] = defaultOptions[key];\n        });\n\n        utils.each(userOptions, function (key, val) {\n            var currentUserOption = userOptions[key];\n\n            if (!utils.isObject(currentUserOption)) {\n                newObj[key] = currentUserOption;\n            } else {\n                if (!defaultOptions[key]) {\n                    newObj[key] = currentUserOption;\n                } else {\n                    newObj[key] = utils.mergeOptions(defaultOptions[key], currentUserOption);\n                }\n            }\n        });\n\n        return newObj;\n    },\n    setCSSAttr: function setCSSAttr(elem, attr, val) {\n        if (!utils.isElement(elem)) {\n            return;\n        }\n\n        if (utils.isString(attr) && utils.isString(val)) {\n            elem.style[attr] = val;\n        } else if (utils.isObject(attr)) {\n            utils.each(attr, function (key, val) {\n                elem.style[key] = val;\n            });\n        }\n    },\n    removeElement: function removeElement(node) {\n        if (!utils.isElement(node)) {\n            return;\n        }\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    },\n    createWebWorker: function createWebWorker(content) {\n        if (!utils.isString(content)) {\n            return {};\n        }\n\n        try {\n            var blob = new utils.Blob([content], {\n                'type': 'text/javascript'\n            });\n            var objectUrl = utils.URL.createObjectURL(blob);\n            var worker = new Worker(objectUrl);\n\n            return {\n                'objectUrl': objectUrl,\n                'worker': worker\n            };\n        } catch (e) {\n            return '' + e;\n        }\n    },\n    getExtension: function getExtension(src) {\n        return src.substr(src.lastIndexOf('.') + 1, src.length);\n    },\n    getFontSize: function getFontSize() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        if (!document.body || options.resizeFont === false) {\n            return options.fontSize;\n        }\n\n        var text = options.text;\n        var containerWidth = options.gifWidth;\n        var fontSize = parseInt(options.fontSize, 10);\n        var minFontSize = parseInt(options.minFontSize, 10);\n        var div = document.createElement('div');\n        var span = document.createElement('span');\n\n        div.setAttribute('width', containerWidth);\n        div.appendChild(span);\n\n        span.innerHTML = text;\n        span.style.fontSize = fontSize + 'px';\n        span.style.textIndent = '-9999px';\n        span.style.visibility = 'hidden';\n\n        document.body.appendChild(span);\n\n        while (span.offsetWidth > containerWidth && fontSize >= minFontSize) {\n            span.style.fontSize = --fontSize + 'px';\n        }\n\n        document.body.removeChild(span);\n\n        return fontSize + 'px';\n    },\n    webWorkerError: false\n};\n\n\n\nvar utils$2 = Object.freeze({\n\tdefault: utils\n});\n\n/*\n  error.js\n  ========\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nvar error = {\n    validate: function validate(skipObj) {\n        skipObj = utils.isObject(skipObj) ? skipObj : {};\n\n        var errorObj = {};\n\n        utils.each(error.validators, function (indece, currentValidator) {\n            var errorCode = currentValidator.errorCode;\n\n            if (!skipObj[errorCode] && !currentValidator.condition) {\n                errorObj = currentValidator;\n                errorObj.error = true;\n\n                return false;\n            }\n        });\n\n        delete errorObj.condition;\n\n        return errorObj;\n    },\n    isValid: function isValid(skipObj) {\n        var errorObj = error.validate(skipObj);\n        var isValid = errorObj.error !== true ? true : false;\n\n        return isValid;\n    },\n    validators: [{\n        condition: utils.isFunction(utils.getUserMedia),\n        errorCode: 'getUserMedia',\n        errorMsg: 'The getUserMedia API is not supported in your browser'\n    }, {\n        condition: utils.isSupported.canvas(),\n        errorCode: 'canvas',\n        errorMsg: 'Canvas elements are not supported in your browser'\n    }, {\n        condition: utils.isSupported.webworkers(),\n        errorCode: 'webworkers',\n        errorMsg: 'The Web Workers API is not supported in your browser'\n    }, {\n        condition: utils.isFunction(utils.URL),\n        errorCode: 'window.URL',\n        errorMsg: 'The window.URL API is not supported in your browser'\n    }, {\n        condition: utils.isSupported.blob(),\n        errorCode: 'window.Blob',\n        errorMsg: 'The window.Blob File API is not supported in your browser'\n    }, {\n        condition: utils.isSupported.Uint8Array(),\n        errorCode: 'window.Uint8Array',\n        errorMsg: 'The window.Uint8Array function constructor is not supported in your browser'\n    }, {\n        condition: utils.isSupported.Uint32Array(),\n        errorCode: 'window.Uint32Array',\n        errorMsg: 'The window.Uint32Array function constructor is not supported in your browser'\n    }],\n    messages: {\n        videoCodecs: {\n            errorCode: 'videocodec',\n            errorMsg: 'The video codec you are trying to use is not supported in your browser'\n        }\n    }\n};\n\n\n\nvar error$2 = Object.freeze({\n\tdefault: error\n});\n\n/*\n  defaultOptions.js\n  =================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Helpers\nvar noop = function noop() {};\n\nvar defaultOptions = {\n    sampleInterval: 10,\n    numWorkers: 2,\n    filter: '',\n    gifWidth: 200,\n    gifHeight: 200,\n    interval: 0.1,\n    numFrames: 10,\n    frameDuration: 1,\n    keepCameraOn: false,\n    images: [],\n    video: null,\n    webcamVideoElement: null,\n    cameraStream: null,\n    text: '',\n    fontWeight: 'normal',\n    fontSize: '16px',\n    minFontSize: '10px',\n    resizeFont: false,\n    fontFamily: 'sans-serif',\n    fontColor: '#ffffff',\n    textAlign: 'center',\n    textBaseline: 'bottom',\n    textXCoordinate: null,\n    textYCoordinate: null,\n    progressCallback: noop,\n    completeCallback: noop,\n    saveRenderingContexts: false,\n    savedRenderingContexts: [],\n    crossOrigin: 'Anonymous'\n};\n\n\n\nvar defaultOptions$2 = Object.freeze({\n\tdefault: defaultOptions\n});\n\n/*\n  isSupported.js\n  ==============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction isSupported() {\n  return error.isValid();\n}\n\n/*\n  isWebCamGIFSupported.js\n  =======================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction isWebCamGIFSupported() {\n  return error.isValid();\n}\n\n/*\n  isSupported.js\n  ==============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction isSupported$1() {\n    var options = {\n        getUserMedia: true\n    };\n\n    return error.isValid(options);\n}\n\n/*\n  isExistingVideoGIFSupported.js\n  ==============================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction isExistingVideoGIFSupported(codecs) {\n    var hasValidCodec = false;\n\n    if (utils.isArray(codecs) && codecs.length) {\n        utils.each(codecs, function (indece, currentCodec) {\n            if (utils.isSupported.videoCodecs[currentCodec]) {\n                hasValidCodec = true;\n            }\n        });\n\n        if (!hasValidCodec) {\n            return false;\n        }\n    } else if (utils.isString(codecs) && codecs.length) {\n        if (!utils.isSupported.videoCodecs[codecs]) {\n            return false;\n        }\n    }\n\n    return error.isValid({\n        'getUserMedia': true\n    });\n}\n\n/*\n  NeuQuant.js\n  ===========\n*/\n\n/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/*\n * This class handles Neural-Net quantization algorithm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @version 0.1 AS3 implementation\n * @version 0.2 JS->AS3 \"translation\" by antimatter15\n * @version 0.3 JS clean up + using modern JS idioms by sole - http://soledadpenades.com\n * Also implement fix in color conversion described at http://stackoverflow.com/questions/16371712/neuquant-js-javascript-color-quantization-hidden-bug-in-js-conversion\n */\n\nfunction NeuQuant() {\n  var netsize = 256; // number of colours used\n\n  // four primes near 500 - assume no image has a length so large\n  // that it is divisible by all four primes\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n\n  // minimum size for input image\n  var minpicturebytes = 3 * prime4;\n\n  // Network Definitions\n\n  var maxnetpos = netsize - 1;\n  var netbiasshift = 4; // bias for colour values\n  var ncycles = 100; // no. of learning cycles\n\n  // defs for freq and bias\n  var intbiasshift = 16; // bias for fractions\n  var intbias = 1 << intbiasshift;\n  var gammashift = 10; // gamma = 1024\n  var gamma = 1 << gammashift;\n  var betashift = 10;\n  var beta = intbias >> betashift; // beta = 1/1024\n  var betagamma = intbias << gammashift - betashift;\n\n  // defs for decreasing radius factor\n  // For 256 colors, radius starts at 32.0 biased by 6 bits\n  // and decreases by a factor of 1/30 each cycle\n  var initrad = netsize >> 3;\n  var radiusbiasshift = 6;\n  var radiusbias = 1 << radiusbiasshift;\n  var initradius = initrad * radiusbias;\n  var radiusdec = 30;\n\n  // defs for decreasing alpha factor\n  // Alpha starts at 1.0 biased by 10 bits\n  var alphabiasshift = 10;\n  var initalpha = 1 << alphabiasshift;\n  var alphadec;\n\n  // radbias and alpharadbias used for radpower calculation\n  var radbiasshift = 8;\n  var radbias = 1 << radbiasshift;\n  var alpharadbshift = alphabiasshift + radbiasshift;\n  var alpharadbias = 1 << alpharadbshift;\n\n  // Input image\n  var thepicture;\n  // Height * Width * 3\n  var lengthcount;\n  // Sampling factor 1..30\n  var samplefac;\n\n  // The network itself\n  var network;\n  var netindex = [];\n\n  // for network lookup - really 256\n  var bias = [];\n\n  // bias and freq arrays for learning\n  var freq = [];\n  var radpower = [];\n\n  function NeuQuantConstructor(thepic, len, sample) {\n\n    var i;\n    var p;\n\n    thepicture = thepic;\n    lengthcount = len;\n    samplefac = sample;\n\n    network = new Array(netsize);\n\n    for (i = 0; i < netsize; i++) {\n      network[i] = new Array(4);\n      p = network[i];\n      p[0] = p[1] = p[2] = (i << netbiasshift + 8) / netsize | 0;\n      freq[i] = intbias / netsize | 0; // 1 / netsize\n      bias[i] = 0;\n    }\n  }\n\n  function colorMap() {\n    var map = [];\n    var index = new Array(netsize);\n    for (var i = 0; i < netsize; i++) {\n      index[network[i][3]] = i;\n    }var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = network[j][0];\n      map[k++] = network[j][1];\n      map[k++] = network[j][2];\n    }\n    return map;\n  }\n\n  // Insertion sort of network and building of netindex[0..255]\n  // (to do after unbias)\n  function inxbuild() {\n    var i;\n    var j;\n    var smallpos;\n    var smallval;\n    var p;\n    var q;\n    var previouscol;\n    var startpos;\n\n    previouscol = 0;\n    startpos = 0;\n\n    for (i = 0; i < netsize; i++) {\n\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n\n        q = network[j];\n\n        if (q[1] < smallval) {\n          // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n\n      q = network[smallpos];\n\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      }\n\n      // smallval entry is now in position i\n      if (smallval != previouscol) {\n\n        netindex[previouscol] = startpos + i >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) {\n          netindex[j] = i;\n        }\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = startpos + maxnetpos >> 1;\n    for (j = previouscol + 1; j < 256; j++) {\n      netindex[j] = maxnetpos; // really 256\n    }\n  }\n\n  // Main Learning Loop\n\n  function learn() {\n    var i;\n    var j;\n    var b;\n    var g;\n    var r;\n    var radius;\n    var rad;\n    var alpha;\n    var step;\n    var delta;\n    var samplepixels;\n    var p;\n    var pix;\n    var lim;\n\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n    }\n\n    alphadec = 30 + (samplefac - 1) / 3;\n    p = thepicture;\n    pix = 0;\n    lim = lengthcount;\n    samplepixels = lengthcount / (3 * samplefac);\n    delta = samplepixels / ncycles | 0;\n    alpha = initalpha;\n    radius = initradius;\n\n    rad = radius >> radiusbiasshift;\n    if (rad <= 1) {\n      rad = 0;\n    }\n\n    for (i = 0; i < rad; i++) {\n      radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n    }\n\n    if (lengthcount < minpicturebytes) {\n      step = 3;\n    } else if (lengthcount % prime1 !== 0) {\n      step = 3 * prime1;\n    } else {\n\n      if (lengthcount % prime2 !== 0) {\n        step = 3 * prime2;\n      } else {\n        if (lengthcount % prime3 !== 0) {\n          step = 3 * prime3;\n        } else {\n          step = 3 * prime4;\n        }\n      }\n    }\n\n    i = 0;\n\n    while (i < samplepixels) {\n\n      b = (p[pix + 0] & 0xff) << netbiasshift;\n      g = (p[pix + 1] & 0xff) << netbiasshift;\n      r = (p[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n\n      if (rad !== 0) {\n        // Alter neighbours\n        alterneigh(rad, j, b, g, r);\n      }\n\n      pix += step;\n\n      if (pix >= lim) {\n        pix -= lengthcount;\n      }\n\n      i++;\n\n      if (delta === 0) {\n        delta = 1;\n      }\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) {\n          rad = 0;\n        }\n\n        for (j = 0; j < rad; j++) {\n          radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n        }\n      }\n    }\n  }\n\n  // Search for BGR values 0..255 (after net is unbiased) and return colour index\n  function map(b, g, r) {\n    var i;\n    var j;\n    var dist;\n    var a;\n    var bestd;\n    var p;\n    var best;\n\n    // Biggest possible distance is 256 * 3\n    bestd = 1000;\n    best = -1;\n    i = netindex[g]; // index on g\n    j = i - 1; // start at netindex[g] and work outwards\n\n    while (i < netsize || j >= 0) {\n\n      if (i < netsize) {\n\n        p = network[i];\n\n        dist = p[1] - g; // inx key\n\n        if (dist >= bestd) {\n          i = netsize; // stop iter\n        } else {\n\n          i++;\n\n          if (dist < 0) {\n            dist = -dist;\n          }\n\n          a = p[0] - b;\n\n          if (a < 0) {\n            a = -a;\n          }\n\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n\n            if (a < 0) {\n              a = -a;\n            }\n\n            dist += a;\n\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n\n      if (j >= 0) {\n\n        p = network[j];\n\n        dist = g - p[1]; // inx key - reverse dif\n\n        if (dist >= bestd) {\n          j = -1; // stop iter\n        } else {\n\n          j--;\n          if (dist < 0) {\n            dist = -dist;\n          }\n          a = p[0] - b;\n          if (a < 0) {\n            a = -a;\n          }\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) {\n              a = -a;\n            }\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n\n  function process() {\n    learn();\n    unbiasnet();\n    inxbuild();\n    return colorMap();\n  }\n\n  // Unbias network to give byte values 0..255 and record position i\n  // to prepare for sort\n  function unbiasnet() {\n    var i;\n    var j;\n\n    for (i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record colour no\n    }\n  }\n\n  // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))\n  // in radpower[|i-j|]\n  function alterneigh(rad, i, b, g, r) {\n\n    var j;\n    var k;\n    var lo;\n    var hi;\n    var a;\n    var m;\n\n    var p;\n\n    lo = i - rad;\n    if (lo < -1) {\n      lo = -1;\n    }\n\n    hi = i + rad;\n\n    if (hi > netsize) {\n      hi = netsize;\n    }\n\n    j = i + 1;\n    k = i - 1;\n    m = 1;\n\n    while (j < hi || k > lo) {\n\n      a = radpower[m++];\n\n      if (j < hi) {\n\n        p = network[j++];\n\n        try {\n\n          p[0] -= a * (p[0] - b) / alpharadbias | 0;\n          p[1] -= a * (p[1] - g) / alpharadbias | 0;\n          p[2] -= a * (p[2] - r) / alpharadbias | 0;\n        } catch (e) {}\n      }\n\n      if (k > lo) {\n\n        p = network[k--];\n\n        try {\n\n          p[0] -= a * (p[0] - b) / alpharadbias | 0;\n          p[1] -= a * (p[1] - g) / alpharadbias | 0;\n          p[2] -= a * (p[2] - r) / alpharadbias | 0;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // Move neuron i towards biased (b,g,r) by factor alpha\n  function altersingle(alpha, i, b, g, r) {\n\n    // alter hit neuron\n    var n = network[i];\n    var alphaMult = alpha / initalpha;\n    n[0] -= alphaMult * (n[0] - b) | 0;\n    n[1] -= alphaMult * (n[1] - g) | 0;\n    n[2] -= alphaMult * (n[2] - r) | 0;\n  }\n\n  // Search for biased BGR values\n  function contest(b, g, r) {\n\n    // finds closest neuron (min dist) and updates freq\n    // finds best neuron (min dist-bias) and returns position\n    // for frequently chosen neurons, freq[i] is high and bias[i] is negative\n    // bias[i] = gamma*((1/netsize)-freq[i])\n\n    var i;\n    var dist;\n    var a;\n    var biasdist;\n    var betafreq;\n    var bestpos;\n    var bestbiaspos;\n    var bestd;\n    var bestbiasd;\n    var n;\n\n    bestd = ~(1 << 31);\n    bestbiasd = bestd;\n    bestpos = -1;\n    bestbiaspos = bestpos;\n\n    for (i = 0; i < netsize; i++) {\n\n      n = network[i];\n      dist = n[0] - b;\n\n      if (dist < 0) {\n        dist = -dist;\n      }\n\n      a = n[1] - g;\n\n      if (a < 0) {\n        a = -a;\n      }\n\n      dist += a;\n\n      a = n[2] - r;\n\n      if (a < 0) {\n        a = -a;\n      }\n\n      dist += a;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = freq[i] >> betashift;\n      freq[i] -= betafreq;\n      bias[i] += betafreq << gammashift;\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return bestbiaspos;\n  }\n\n  NeuQuantConstructor.apply(this, arguments);\n\n  var exports = {};\n  exports.map = map;\n  exports.process = process;\n\n  return exports;\n}\n\n/*\n  processFrameWorker.js\n  =====================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction workerCode() {\n    var self = this;\n\n    try {\n        self.onmessage = function (ev) {\n            var data = ev.data || {};\n            var response;\n\n            if (data.gifshot) {\n                response = workerMethods.run(data);\n                postMessage(response);\n            }\n        };\n    } catch (e) {}\n\n    var workerMethods = {\n        dataToRGB: function dataToRGB(data, width, height) {\n            var length = width * height * 4;\n            var i = 0;\n            var rgb = [];\n\n            while (i < length) {\n                rgb.push(data[i++]);\n                rgb.push(data[i++]);\n                rgb.push(data[i++]);\n                i++; // for the alpha channel which we don't care about\n            }\n\n            return rgb;\n        },\n        componentizedPaletteToArray: function componentizedPaletteToArray(paletteRGB) {\n            paletteRGB = paletteRGB || [];\n\n            var paletteArray = [];\n\n            for (var i = 0; i < paletteRGB.length; i += 3) {\n                var r = paletteRGB[i];\n                var g = paletteRGB[i + 1];\n                var b = paletteRGB[i + 2];\n\n                paletteArray.push(r << 16 | g << 8 | b);\n            }\n\n            return paletteArray;\n        },\n        // This is the \"traditional\" Animated_GIF style of going from RGBA to indexed color frames\n        'processFrameWithQuantizer': function processFrameWithQuantizer(imageData, width, height, sampleInterval) {\n            var rgbComponents = this.dataToRGB(imageData, width, height);\n            var nq = new NeuQuant(rgbComponents, rgbComponents.length, sampleInterval);\n            var paletteRGB = nq.process();\n            var paletteArray = new Uint32Array(this.componentizedPaletteToArray(paletteRGB));\n            var numberPixels = width * height;\n            var indexedPixels = new Uint8Array(numberPixels);\n            var k = 0;\n\n            for (var i = 0; i < numberPixels; i++) {\n                var r = rgbComponents[k++];\n                var g = rgbComponents[k++];\n                var b = rgbComponents[k++];\n\n                indexedPixels[i] = nq.map(r, g, b);\n            }\n\n            return {\n                pixels: indexedPixels,\n                palette: paletteArray\n            };\n        },\n        'run': function run(frame) {\n            frame = frame || {};\n\n            var _frame = frame,\n                height = _frame.height,\n                palette = _frame.palette,\n                sampleInterval = _frame.sampleInterval,\n                width = _frame.width;\n\n            var imageData = frame.data;\n\n            return this.processFrameWithQuantizer(imageData, width, height, sampleInterval);\n        }\n    };\n\n    return workerMethods;\n}\n\n/*\n  gifWriter.js\n  ============\n*/\n\n// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\nfunction gifWriter(buf, width, height, gopts) {\n  var p = 0;\n\n  gopts = gopts === undefined ? {} : gopts;\n  var loop_count = gopts.loop === undefined ? null : gopts.loop;\n  var global_palette = gopts.palette === undefined ? null : gopts.palette;\n\n  if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw \"Width/Height invalid.\";\n\n  function check_palette_and_num_colors(palette) {\n    var num_colors = palette.length;\n\n    if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw \"Invalid code/color length, must be power of 2 and 2 .. 256.\";\n    return num_colors;\n  }\n\n  // - Header.\n  buf[p++] = 0x47;\n  buf[p++] = 0x49;\n  buf[p++] = 0x46; // GIF\n  buf[p++] = 0x38;\n  buf[p++] = 0x39;\n  buf[p++] = 0x61; // 89a\n\n  // Handling of Global Color Table (palette) and background index.\n  var gp_num_colors_pow2 = 0;\n  var background = 0;\n\n  // - Logical Screen Descriptor.\n  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n  buf[p++] = width & 0xff;\n  buf[p++] = width >> 8 & 0xff;\n  buf[p++] = height & 0xff;\n  buf[p++] = height >> 8 & 0xff;\n  // NOTE: Indicates 0-bpp original color resolution (unused?).\n  buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.\n  gp_num_colors_pow2; // NOTE: No sort flag (unused?).\n  buf[p++] = background; // Background Color Index.\n  buf[p++] = 0; // Pixel aspect ratio (unused?).\n\n  if (loop_count !== null) {\n    // Netscape block for looping.\n    if (loop_count < 0 || loop_count > 65535) throw \"Loop count invalid.\";\n\n    // Extension code, label, and length.\n    buf[p++] = 0x21;\n    buf[p++] = 0xff;\n    buf[p++] = 0x0b;\n    // NETSCAPE2.0\n    buf[p++] = 0x4e;\n    buf[p++] = 0x45;\n    buf[p++] = 0x54;\n    buf[p++] = 0x53;\n    buf[p++] = 0x43;\n    buf[p++] = 0x41;\n    buf[p++] = 0x50;\n    buf[p++] = 0x45;\n    buf[p++] = 0x32;\n    buf[p++] = 0x2e;\n    buf[p++] = 0x30;\n    // Sub-block\n    buf[p++] = 0x03;\n    buf[p++] = 0x01;\n    buf[p++] = loop_count & 0xff;\n    buf[p++] = loop_count >> 8 & 0xff;\n    buf[p++] = 0x00; // Terminator.\n  }\n\n  var ended = false;\n\n  this.addFrame = function (x, y, w, h, indexed_pixels, opts) {\n    if (ended === true) {\n      --p;\n      ended = false;\n    } // Un-end.\n\n    opts = opts === undefined ? {} : opts;\n\n    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n    // canvas width/height, I imagine?\n    if (x < 0 || y < 0 || x > 65535 || y > 65535) throw \"x/y invalid.\";\n\n    if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw \"Width/Height invalid.\";\n\n    if (indexed_pixels.length < w * h) throw \"Not enough pixels for the frame size.\";\n\n    var using_local_palette = true;\n    var palette = opts.palette;\n    if (palette === undefined || palette === null) {\n      using_local_palette = false;\n      palette = global_palette;\n    }\n\n    if (palette === undefined || palette === null) throw \"Must supply either a local or global palette.\";\n\n    var num_colors = check_palette_and_num_colors(palette);\n\n    // Compute the min_code_size (power of 2), destroying num_colors.\n    var min_code_size = 0;\n    while (num_colors >>= 1) {\n      ++min_code_size;\n    }num_colors = 1 << min_code_size; // Now we can easily get it back.\n\n    var delay = opts.delay === undefined ? 0 : opts.delay;\n\n    // From the spec:\n    //     0 -   No disposal specified. The decoder is\n    //           not required to take any action.\n    //     1 -   Do not dispose. The graphic is to be left\n    //           in place.\n    //     2 -   Restore to background color. The area used by the\n    //           graphic must be restored to the background color.\n    //     3 -   Restore to previous. The decoder is required to\n    //           restore the area overwritten by the graphic with\n    //           what was there prior to rendering the graphic.\n    //  4-7 -    To be defined.\n    // NOTE(deanm): Dispose background doesn't really work, apparently most\n    // browsers ignore the background palette index and clear to transparency.\n    var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n    if (disposal < 0 || disposal > 3) // 4-7 is reserved.\n      throw \"Disposal out of range.\";\n\n    var use_transparency = false;\n    var transparent_index = 0;\n    if (opts.transparent !== undefined && opts.transparent !== null) {\n      use_transparency = true;\n      transparent_index = opts.transparent;\n      if (transparent_index < 0 || transparent_index >= num_colors) throw \"Transparent color index.\";\n    }\n\n    if (disposal !== 0 || use_transparency || delay !== 0) {\n      // - Graphics Control Extension\n      buf[p++] = 0x21;\n      buf[p++] = 0xf9; // Extension / Label.\n      buf[p++] = 4; // Byte size.\n\n      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n      buf[p++] = delay & 0xff;\n      buf[p++] = delay >> 8 & 0xff;\n      buf[p++] = transparent_index; // Transparent color index.\n      buf[p++] = 0; // Block Terminator.\n    }\n\n    // - Image Descriptor\n    buf[p++] = 0x2c; // Image Seperator.\n    buf[p++] = x & 0xff;\n    buf[p++] = x >> 8 & 0xff; // Left.\n    buf[p++] = y & 0xff;\n    buf[p++] = y >> 8 & 0xff; // Top.\n    buf[p++] = w & 0xff;\n    buf[p++] = w >> 8 & 0xff;\n    buf[p++] = h & 0xff;\n    buf[p++] = h >> 8 & 0xff;\n    // NOTE: No sort flag (unused?).\n    // TODO(deanm): Support interlace.\n    buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0;\n\n    // - Local Color Table\n    if (using_local_palette === true) {\n      for (var i = 0, il = palette.length; i < il; ++i) {\n        var rgb = palette[i];\n        buf[p++] = rgb >> 16 & 0xff;\n        buf[p++] = rgb >> 8 & 0xff;\n        buf[p++] = rgb & 0xff;\n      }\n    }\n\n    p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n  };\n\n  this.end = function () {\n    if (ended === false) {\n      buf[p++] = 0x3b; // Trailer.\n      ended = true;\n    }\n    return p;\n  };\n\n  // Main compression routine, palette indexes -> LZW code stream.\n  // |index_stream| must have at least one entry.\n  function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n    buf[p++] = min_code_size;\n    var cur_subblock = p++; // Pointing at the length field.\n\n    var clear_code = 1 << min_code_size;\n    var code_mask = clear_code - 1;\n    var eoi_code = clear_code + 1;\n    var next_code = eoi_code + 1;\n\n    var cur_code_size = min_code_size + 1; // Number of bits per code.\n    var cur_shift = 0;\n    // We have at most 12-bit codes, so we should have to hold a max of 19\n    // bits here (and then we would write out).\n    var cur = 0;\n\n    function emit_bytes_to_buffer(bit_block_size) {\n      while (cur_shift >= bit_block_size) {\n        buf[p++] = cur & 0xff;\n        cur >>= 8;\n        cur_shift -= 8;\n        if (p === cur_subblock + 256) {\n          // Finished a subblock.\n          buf[cur_subblock] = 255;\n          cur_subblock = p++;\n        }\n      }\n    }\n\n    function emit_code(c) {\n      cur |= c << cur_shift;\n      cur_shift += cur_code_size;\n      emit_bytes_to_buffer(8);\n    }\n\n    // I am not an expert on the topic, and I don't want to write a thesis.\n    // However, it is good to outline here the basic algorithm and the few data\n    // structures and optimizations here that make this implementation fast.\n    // The basic idea behind LZW is to build a table of previously seen runs\n    // addressed by a short id (herein called output code).  All data is\n    // referenced by a code, which represents one or more values from the\n    // original input stream.  All input bytes can be referenced as the same\n    // value as an output code.  So if you didn't want any compression, you\n    // could more or less just output the original bytes as codes (there are\n    // some details to this, but it is the idea).  In order to achieve\n    // compression, values greater then the input range (codes can be up to\n    // 12-bit while input only 8-bit) represent a sequence of previously seen\n    // inputs.  The decompressor is able to build the same mapping while\n    // decoding, so there is always a shared common knowledge between the\n    // encoding and decoder, which is also important for \"timing\" aspects like\n    // how to handle variable bit width code encoding.\n    //\n    // One obvious but very important consequence of the table system is there\n    // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n    // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n    // can be used for an effecient lookup strategy for the code mapping.  We\n    // need to know if a run has been seen before, and be able to map that run\n    // to the output code.  Since we start with known unique ids (input bytes),\n    // and then from those build more unique ids (table entries), we can\n    // continue this chain (almost like a linked list) to always have small\n    // integer values that represent the current byte chains in the encoder.\n    // This means instead of tracking the input bytes (AAAABCD) to know our\n    // current state, we can track the table entry for AAAABC (it is guaranteed\n    // to exist by the nature of the algorithm) and the next character D.\n    // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n    // unique.  This allows us to create a simple lookup key for mapping input\n    // sequences to codes (table indices) without having to store or search\n    // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n    // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n    // key.  This leads to a integer value at most 20-bits, which can always\n    // fit in an SMI value and be used as a fast sparse array / object key.\n\n    // Output code for the current contents of the index buffer.\n    var ib_code = index_stream[0] & code_mask; // Load first input index.\n    var code_table = {}; // Key'd on our 20-bit \"tuple\".\n\n    emit_code(clear_code); // Spec says first code should be a clear code.\n\n    // First index already loaded, process the rest of the stream.\n    for (var i = 1, il = index_stream.length; i < il; ++i) {\n      var k = index_stream[i] & code_mask;\n      var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.\n      var cur_code = code_table[cur_key]; // buffer + k.\n\n      // Check if we have to create a new code table entry.\n      if (cur_code === undefined) {\n        // We don't have buffer + k.\n        // Emit index buffer (without k).\n        // This is an inline version of emit_code, because this is the core\n        // writing routine of the compressor (and V8 cannot inline emit_code\n        // because it is a closure here in a different context).  Additionally\n        // we can call emit_byte_to_buffer less often, because we can have\n        // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n        // be 12-bits, so can safely have 18-bits there without overflow.\n        // emit_code(ib_code);\n        cur |= ib_code << cur_shift;\n        cur_shift += cur_code_size;\n        while (cur_shift >= 8) {\n          buf[p++] = cur & 0xff;\n          cur >>= 8;\n          cur_shift -= 8;\n          if (p === cur_subblock + 256) {\n            // Finished a subblock.\n            buf[cur_subblock] = 255;\n            cur_subblock = p++;\n          }\n        }\n\n        if (next_code === 4096) {\n          // Table full, need a clear.\n          emit_code(clear_code);\n          next_code = eoi_code + 1;\n          cur_code_size = min_code_size + 1;\n          code_table = {};\n        } else {\n          // Table not full, insert a new entry.\n          // Increase our variable bit code sizes if necessary.  This is a bit\n          // tricky as it is based on \"timing\" between the encoding and\n          // decoder.  From the encoders perspective this should happen after\n          // we've already emitted the index buffer and are about to create the\n          // first table entry that would overflow our current code bit size.\n          if (next_code >= 1 << cur_code_size) ++cur_code_size;\n          code_table[cur_key] = next_code++; // Insert into code table.\n        }\n\n        ib_code = k; // Index buffer to single input k.\n      } else {\n        ib_code = cur_code; // Index buffer to sequence in code table.\n      }\n    }\n\n    emit_code(ib_code); // There will still be something in the index buffer.\n    emit_code(eoi_code); // End Of Information.\n\n    // Flush / finalize the sub-blocks stream to the buffer.\n    emit_bytes_to_buffer(1);\n\n    // Finish the sub-blocks, writing out any unfinished lengths and\n    // terminating with a sub-block of length 0.  If we have already started\n    // but not yet used a sub-block it can just become the terminator.\n    if (cur_subblock + 1 === p) {\n      // Started but unused.\n      buf[cur_subblock] = 0;\n    } else {\n      // Started and used, write length and additional terminator block.\n      buf[cur_subblock] = p - cur_subblock - 1;\n      buf[p++] = 0;\n    }\n    return p;\n  }\n}\n\n/*\n  animatedGIF.js\n  ==============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\n// Helpers\nvar noop$2 = function noop() {};\n\nvar AnimatedGIF = function AnimatedGIF(options) {\n    this.canvas = null;\n    this.ctx = null;\n    this.repeat = 0;\n    this.frames = [];\n    this.numRenderedFrames = 0;\n    this.onRenderCompleteCallback = noop$2;\n    this.onRenderProgressCallback = noop$2;\n    this.workers = [];\n    this.availableWorkers = [];\n    this.generatingGIF = false;\n    this.options = options;\n\n    // Constructs and initializes the the web workers appropriately\n    this.initializeWebWorkers(options);\n};\n\nAnimatedGIF.prototype = {\n    'workerMethods': workerCode(),\n    'initializeWebWorkers': function initializeWebWorkers(options) {\n        var self = this;\n        var processFrameWorkerCode = NeuQuant.toString() + '(' + workerCode.toString() + '());';\n        var webWorkerObj = void 0;\n        var objectUrl = void 0;\n        var webWorker = void 0;\n        var numWorkers = void 0;\n        var x = -1;\n        var workerError = '';\n\n        numWorkers = options.numWorkers;\n\n        while (++x < numWorkers) {\n            webWorkerObj = utils.createWebWorker(processFrameWorkerCode);\n\n            if (utils.isObject(webWorkerObj)) {\n                objectUrl = webWorkerObj.objectUrl;\n                webWorker = webWorkerObj.worker;\n\n                self.workers.push({\n                    worker: webWorker,\n                    objectUrl: objectUrl\n                });\n\n                self.availableWorkers.push(webWorker);\n            } else {\n                workerError = webWorkerObj;\n                utils.webWorkerError = !!webWorkerObj;\n            }\n        }\n\n        this.workerError = workerError;\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = options.gifWidth;\n        this.canvas.height = options.gifHeight;\n        this.ctx = this.canvas.getContext('2d');\n        this.frames = [];\n    },\n    // Return a worker for processing a frame\n    getWorker: function getWorker() {\n        return this.availableWorkers.pop();\n    },\n    // Restores a worker to the pool\n    freeWorker: function freeWorker(worker) {\n        this.availableWorkers.push(worker);\n    },\n    byteMap: function () {\n        var byteMap = [];\n\n        for (var i = 0; i < 256; i++) {\n            byteMap[i] = String.fromCharCode(i);\n        }\n\n        return byteMap;\n    }(),\n    bufferToString: function bufferToString(buffer) {\n        var numberValues = buffer.length;\n        var str = '';\n        var x = -1;\n\n        while (++x < numberValues) {\n            str += this.byteMap[buffer[x]];\n        }\n\n        return str;\n    },\n    onFrameFinished: function onFrameFinished(progressCallback) {\n        // The GIF is not written until we're done with all the frames\n        // because they might not be processed in the same order\n        var self = this;\n        var frames = self.frames;\n        var options = self.options;\n        var hasExistingImages = !!(options.images || []).length;\n        var allDone = frames.every(function (frame) {\n            return !frame.beingProcessed && frame.done;\n        });\n\n        self.numRenderedFrames++;\n\n        if (hasExistingImages) {\n            progressCallback(self.numRenderedFrames / frames.length);\n        }\n\n        self.onRenderProgressCallback(self.numRenderedFrames * 0.75 / frames.length);\n\n        if (allDone) {\n            if (!self.generatingGIF) {\n                self.generateGIF(frames, self.onRenderCompleteCallback);\n            }\n        } else {\n            utils.requestTimeout(function () {\n                self.processNextFrame();\n            }, 1);\n        }\n    },\n    processFrame: function processFrame(position) {\n        var AnimatedGifContext = this;\n        var options = this.options;\n        var _options = this.options,\n            progressCallback = _options.progressCallback,\n            sampleInterval = _options.sampleInterval;\n\n        var frames = this.frames;\n        var frame = void 0;\n        var worker = void 0;\n        var done = function done() {\n            var ev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var data = ev.data;\n\n            // Delete original data, and free memory\n            delete frame.data;\n\n            frame.pixels = Array.prototype.slice.call(data.pixels);\n            frame.palette = Array.prototype.slice.call(data.palette);\n            frame.done = true;\n            frame.beingProcessed = false;\n\n            AnimatedGifContext.freeWorker(worker);\n\n            AnimatedGifContext.onFrameFinished(progressCallback);\n        };\n\n        frame = frames[position];\n\n        if (frame.beingProcessed || frame.done) {\n            this.onFrameFinished();\n\n            return;\n        }\n\n        frame.sampleInterval = sampleInterval;\n        frame.beingProcessed = true;\n        frame.gifshot = true;\n\n        worker = this.getWorker();\n\n        if (worker) {\n            // Process the frame in a web worker\n            worker.onmessage = done;\n            worker.postMessage(frame);\n        } else {\n            // Process the frame in the current thread\n            done({\n                'data': AnimatedGifContext.workerMethods.run(frame)\n            });\n        }\n    },\n    startRendering: function startRendering(completeCallback) {\n        this.onRenderCompleteCallback = completeCallback;\n\n        for (var i = 0; i < this.options.numWorkers && i < this.frames.length; i++) {\n            this.processFrame(i);\n        }\n    },\n    processNextFrame: function processNextFrame() {\n        var position = -1;\n\n        for (var i = 0; i < this.frames.length; i++) {\n            var frame = this.frames[i];\n\n            if (!frame.done && !frame.beingProcessed) {\n                position = i;\n                break;\n            }\n        }\n\n        if (position >= 0) {\n            this.processFrame(position);\n        }\n    },\n    // Takes the already processed data in frames and feeds it to a new\n    // GifWriter instance in order to get the binary GIF file\n    generateGIF: function generateGIF(frames, callback) {\n        // TODO: Weird: using a simple JS array instead of a typed array,\n        // the files are WAY smaller o_o. Patches/explanations welcome!\n        var buffer = []; // new Uint8Array(width * height * frames.length * 5);\n        var gifOptions = {\n            loop: this.repeat\n        };\n        var options = this.options;\n        var interval = options.interval;\n\n        var frameDuration = options.frameDuration;\n        var existingImages = options.images;\n        var hasExistingImages = !!existingImages.length;\n        var height = options.gifHeight;\n        var width = options.gifWidth;\n        var gifWriter$$1 = new gifWriter(buffer, width, height, gifOptions);\n        var onRenderProgressCallback = this.onRenderProgressCallback;\n        var delay = hasExistingImages ? interval * 100 : 0;\n        var bufferToString = void 0;\n        var gif = void 0;\n\n        this.generatingGIF = true;\n\n        utils.each(frames, function (iterator, frame) {\n            var framePalette = frame.palette;\n\n            onRenderProgressCallback(0.75 + 0.25 * frame.position * 1.0 / frames.length);\n\n            for (var i = 0; i < frameDuration; i++) {\n                gifWriter$$1.addFrame(0, 0, width, height, frame.pixels, {\n                    palette: framePalette,\n                    delay: delay\n                });\n            }\n        });\n\n        gifWriter$$1.end();\n\n        onRenderProgressCallback(1.0);\n\n        this.frames = [];\n\n        this.generatingGIF = false;\n\n        if (utils.isFunction(callback)) {\n            bufferToString = this.bufferToString(buffer);\n            gif = 'data:image/gif;base64,' + utils.btoa(bufferToString);\n\n            callback(gif);\n        }\n    },\n    // From GIF: 0 = loop forever, null = not looping, n > 0 = loop n times and stop\n    setRepeat: function setRepeat(r) {\n        this.repeat = r;\n    },\n    addFrame: function addFrame(element, gifshotOptions) {\n        gifshotOptions = utils.isObject(gifshotOptions) ? gifshotOptions : {};\n\n        var self = this;\n        var ctx = self.ctx;\n        var options = self.options;\n        var width = options.gifWidth;\n        var height = options.gifHeight;\n        var fontSize = utils.getFontSize(gifshotOptions);\n        var _gifshotOptions = gifshotOptions,\n            filter = _gifshotOptions.filter,\n            fontColor = _gifshotOptions.fontColor,\n            fontFamily = _gifshotOptions.fontFamily,\n            fontWeight = _gifshotOptions.fontWeight,\n            gifHeight = _gifshotOptions.gifHeight,\n            gifWidth = _gifshotOptions.gifWidth,\n            text = _gifshotOptions.text,\n            textAlign = _gifshotOptions.textAlign,\n            textBaseline = _gifshotOptions.textBaseline;\n\n        var textXCoordinate = gifshotOptions.textXCoordinate ? gifshotOptions.textXCoordinate : textAlign === 'left' ? 1 : textAlign === 'right' ? width : width / 2;\n        var textYCoordinate = gifshotOptions.textYCoordinate ? gifshotOptions.textYCoordinate : textBaseline === 'top' ? 1 : textBaseline === 'center' ? height / 2 : height;\n        var font = fontWeight + ' ' + fontSize + ' ' + fontFamily;\n        var imageData = void 0;\n\n        try {\n            ctx.filter = filter;\n\n            ctx.drawImage(element, 0, 0, width, height);\n\n            if (text) {\n                ctx.font = font;\n                ctx.fillStyle = fontColor;\n                ctx.textAlign = textAlign;\n                ctx.textBaseline = textBaseline;\n                ctx.fillText(text, textXCoordinate, textYCoordinate);\n            }\n\n            imageData = ctx.getImageData(0, 0, width, height);\n\n            self.addFrameImageData(imageData);\n        } catch (e) {\n            return '' + e;\n        }\n    },\n    addFrameImageData: function addFrameImageData() {\n        var imageData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var frames = this.frames;\n        var imageDataArray = imageData.data;\n\n        this.frames.push({\n            'data': imageDataArray,\n            'width': imageData.width,\n            'height': imageData.height,\n            'palette': null,\n            'dithering': null,\n            'done': false,\n            'beingProcessed': false,\n            'position': frames.length\n        });\n    },\n    onRenderProgress: function onRenderProgress(callback) {\n        this.onRenderProgressCallback = callback;\n    },\n    isRendering: function isRendering() {\n        return this.generatingGIF;\n    },\n    getBase64GIF: function getBase64GIF(completeCallback) {\n        var self = this;\n        var onRenderComplete = function onRenderComplete(gif) {\n            self.destroyWorkers();\n\n            utils.requestTimeout(function () {\n                completeCallback(gif);\n            }, 0);\n        };\n\n        self.startRendering(onRenderComplete);\n    },\n    destroyWorkers: function destroyWorkers() {\n        if (this.workerError) {\n            return;\n        }\n\n        var workers = this.workers;\n\n        // Explicitly ask web workers to die so they are explicitly GC'ed\n        utils.each(workers, function (iterator, workerObj) {\n            var worker = workerObj.worker;\n            var objectUrl = workerObj.objectUrl;\n\n            worker.terminate();\n            utils.URL.revokeObjectURL(objectUrl);\n        });\n    }\n};\n\n/*\n  getBase64GIF.js\n  ===============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction getBase64GIF(animatedGifInstance, callback) {\n    // This is asynchronous, rendered with WebWorkers\n    animatedGifInstance.getBase64GIF(function (image) {\n        callback({\n            error: false,\n            errorCode: '',\n            errorMsg: '',\n            image: image\n        });\n    });\n}\n\n/*\n  existingImages.js\n  =================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction existingImages() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var self = this;\n    var callback = obj.callback,\n        images = obj.images,\n        options = obj.options;\n\n    var imagesLength = obj.imagesLength;\n    var skipObj = {\n        'getUserMedia': true,\n        'window.URL': true\n    };\n    var errorObj = error.validate(skipObj);\n    var loadedImages = [];\n    var loadedImagesLength = 0;\n    var tempImage = void 0;\n    var ag = void 0;\n\n    if (errorObj.error) {\n        return callback(errorObj);\n    }\n\n    // change workerPath to point to where Animated_GIF.worker.js is\n    ag = new AnimatedGIF(options);\n\n    utils.each(images, function (index, image) {\n        var currentImage = image;\n\n        if (image.src) {\n            currentImage = currentImage.src;\n        }\n        if (utils.isElement(currentImage)) {\n            if (options.crossOrigin) {\n                currentImage.crossOrigin = options.crossOrigin;\n            }\n\n            loadedImages[index] = currentImage;\n            loadedImagesLength += 1;\n\n            if (loadedImagesLength === imagesLength) {\n                addLoadedImagesToGif();\n            }\n        } else if (utils.isString(currentImage)) {\n            tempImage = new Image();\n\n            if (options.crossOrigin) {\n                tempImage.crossOrigin = options.crossOrigin;\n            }\n\n            (function (tempImage) {\n                if (image.text) {\n                    tempImage.text = image.text;\n                }\n\n                tempImage.onerror = function (e) {\n                    var obj = void 0;\n\n                    --imagesLength; // skips over images that error out\n\n                    if (imagesLength === 0) {\n                        obj = {};\n                        obj.error = 'None of the requested images was capable of being retrieved';\n\n                        return callback(obj);\n                    }\n                };\n\n                tempImage.onload = function (e) {\n                    if (image.text) {\n                        loadedImages[index] = {\n                            img: tempImage,\n                            text: tempImage.text\n                        };\n                    } else {\n                        loadedImages[index] = tempImage;\n                    }\n\n                    loadedImagesLength += 1;\n\n                    if (loadedImagesLength === imagesLength) {\n                        addLoadedImagesToGif();\n                    }\n\n                    utils.removeElement(tempImage);\n                };\n\n                tempImage.src = currentImage;\n            })(tempImage);\n\n            utils.setCSSAttr(tempImage, {\n                position: 'fixed',\n                opacity: '0'\n            });\n\n            document.body.appendChild(tempImage);\n        }\n    });\n\n    function addLoadedImagesToGif() {\n        utils.each(loadedImages, function (index, loadedImage) {\n            if (loadedImage) {\n                if (loadedImage.text) {\n                    ag.addFrame(loadedImage.img, options, loadedImage.text);\n                } else {\n                    ag.addFrame(loadedImage, options);\n                }\n            }\n        });\n\n        getBase64GIF(ag, callback);\n    }\n}\n\n/*\n  screenShot.js\n  =============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\n// Helpers\nvar noop$3 = function noop() {};\n\nvar screenShot = {\n    getGIF: function getGIF() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var callback = arguments[1];\n\n        callback = utils.isFunction(callback) ? callback : noop$3;\n\n        var canvas = document.createElement('canvas');\n        var context = void 0;\n        var existingImages = options.images;\n        var hasExistingImages = !!existingImages.length;\n        var cameraStream = options.cameraStream,\n            crop = options.crop,\n            filter = options.filter,\n            fontColor = options.fontColor,\n            fontFamily = options.fontFamily,\n            fontWeight = options.fontWeight,\n            keepCameraOn = options.keepCameraOn,\n            numWorkers = options.numWorkers,\n            progressCallback = options.progressCallback,\n            saveRenderingContexts = options.saveRenderingContexts,\n            savedRenderingContexts = options.savedRenderingContexts,\n            text = options.text,\n            textAlign = options.textAlign,\n            textBaseline = options.textBaseline,\n            videoElement = options.videoElement,\n            videoHeight = options.videoHeight,\n            videoWidth = options.videoWidth,\n            webcamVideoElement = options.webcamVideoElement;\n\n        var gifWidth = Number(options.gifWidth);\n        var gifHeight = Number(options.gifHeight);\n        var interval = Number(options.interval);\n        var sampleInterval = Number(options.sampleInterval);\n        var waitBetweenFrames = hasExistingImages ? 0 : interval * 1000;\n        var renderingContextsToSave = [];\n        var numFrames = savedRenderingContexts.length ? savedRenderingContexts.length : options.numFrames;\n        var pendingFrames = numFrames;\n        var ag = new AnimatedGIF(options);\n        var fontSize = utils.getFontSize(options);\n        var textXCoordinate = options.textXCoordinate ? options.textXCoordinate : textAlign === 'left' ? 1 : textAlign === 'right' ? gifWidth : gifWidth / 2;\n        var textYCoordinate = options.textYCoordinate ? options.textYCoordinate : textBaseline === 'top' ? 1 : textBaseline === 'center' ? gifHeight / 2 : gifHeight;\n        var font = fontWeight + ' ' + fontSize + ' ' + fontFamily;\n        var sourceX = crop ? Math.floor(crop.scaledWidth / 2) : 0;\n        var sourceWidth = crop ? videoWidth - crop.scaledWidth : 0;\n        var sourceY = crop ? Math.floor(crop.scaledHeight / 2) : 0;\n        var sourceHeight = crop ? videoHeight - crop.scaledHeight : 0;\n        var captureFrames = function captureSingleFrame() {\n            var framesLeft = pendingFrames - 1;\n\n            if (savedRenderingContexts.length) {\n                context.putImageData(savedRenderingContexts[numFrames - pendingFrames], 0, 0);\n\n                finishCapture();\n            } else {\n                drawVideo();\n            }\n\n            function drawVideo() {\n                try {\n                    // Makes sure the canvas video heights/widths are in bounds\n                    if (sourceWidth > videoWidth) {\n                        sourceWidth = videoWidth;\n                    }\n\n                    if (sourceHeight > videoHeight) {\n                        sourceHeight = videoHeight;\n                    }\n\n                    if (sourceX < 0) {\n                        sourceX = 0;\n                    }\n\n                    if (sourceY < 0) {\n                        sourceY = 0;\n                    }\n\n                    context.filter = filter;\n\n                    context.drawImage(videoElement, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, gifWidth, gifHeight);\n\n                    finishCapture();\n                } catch (e) {\n                    // There is a Firefox bug that sometimes throws NS_ERROR_NOT_AVAILABLE and\n                    // and IndexSizeError errors when drawing a video element to the canvas\n                    if (e.name === 'NS_ERROR_NOT_AVAILABLE') {\n                        // Wait 100ms before trying again\n                        utils.requestTimeout(drawVideo, 100);\n                    } else {\n                        throw e;\n                    }\n                }\n            }\n\n            function finishCapture() {\n                var imageData = void 0;\n\n                if (saveRenderingContexts) {\n                    renderingContextsToSave.push(context.getImageData(0, 0, gifWidth, gifHeight));\n                }\n\n                // If there is text to display, make sure to display it on the canvas after the image is drawn\n                if (text) {\n                    context.font = font;\n                    context.fillStyle = fontColor;\n                    context.textAlign = textAlign;\n                    context.textBaseline = textBaseline;\n                    context.fillText(text, textXCoordinate, textYCoordinate);\n                }\n\n                imageData = context.getImageData(0, 0, gifWidth, gifHeight);\n\n                ag.addFrameImageData(imageData);\n\n                pendingFrames = framesLeft;\n\n                // Call back with an r value indicating how far along we are in capture\n                progressCallback((numFrames - pendingFrames) / numFrames);\n\n                if (framesLeft > 0) {\n                    // test\n                    utils.requestTimeout(captureSingleFrame, waitBetweenFrames);\n                }\n\n                if (!pendingFrames) {\n                    ag.getBase64GIF(function (image) {\n                        callback({\n                            'error': false,\n                            'errorCode': '',\n                            'errorMsg': '',\n                            'image': image,\n                            'cameraStream': cameraStream,\n                            'videoElement': videoElement,\n                            'webcamVideoElement': webcamVideoElement,\n                            'savedRenderingContexts': renderingContextsToSave,\n                            'keepCameraOn': keepCameraOn\n                        });\n                    });\n                }\n            }\n        };\n\n        numFrames = numFrames !== undefined ? numFrames : 10;\n        interval = interval !== undefined ? interval : 0.1; // In seconds\n\n        canvas.width = gifWidth;\n        canvas.height = gifHeight;\n        context = canvas.getContext('2d');\n\n        (function capture() {\n            if (!savedRenderingContexts.length && videoElement.currentTime === 0) {\n                utils.requestTimeout(capture, 100);\n\n                return;\n            }\n\n            captureFrames();\n        })();\n    },\n    getCropDimensions: function getCropDimensions() {\n        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var width = obj.videoWidth;\n        var height = obj.videoHeight;\n        var gifWidth = obj.gifWidth;\n        var gifHeight = obj.gifHeight;\n        var result = {\n            width: 0,\n            height: 0,\n            scaledWidth: 0,\n            scaledHeight: 0\n        };\n\n        if (width > height) {\n            result.width = Math.round(width * (gifHeight / height)) - gifWidth;\n            result.scaledWidth = Math.round(result.width * (height / gifHeight));\n        } else {\n            result.height = Math.round(height * (gifWidth / width)) - gifHeight;\n            result.scaledHeight = Math.round(result.height * (width / gifWidth));\n        }\n\n        return result;\n    }\n};\n\n/*\n  videoStream.js\n  ==============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nvar videoStream = {\n    loadedData: false,\n    defaultVideoDimensions: {\n        width: 640,\n        height: 480\n    },\n    findVideoSize: function findVideoSizeMethod(obj) {\n        findVideoSizeMethod.attempts = findVideoSizeMethod.attempts || 0;\n\n        var cameraStream = obj.cameraStream,\n            completedCallback = obj.completedCallback,\n            videoElement = obj.videoElement;\n\n\n        if (!videoElement) {\n            return;\n        }\n\n        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n            videoElement.removeEventListener('loadeddata', videoStream.findVideoSize);\n\n            completedCallback({\n                videoElement: videoElement,\n                cameraStream: cameraStream,\n                videoWidth: videoElement.videoWidth,\n                videoHeight: videoElement.videoHeight\n            });\n        } else {\n            if (findVideoSizeMethod.attempts < 10) {\n                findVideoSizeMethod.attempts += 1;\n\n                utils.requestTimeout(function () {\n                    videoStream.findVideoSize(obj);\n                }, 400);\n            } else {\n                completedCallback({\n                    videoElement: videoElement,\n                    cameraStream: cameraStream,\n                    videoWidth: videoStream.defaultVideoDimensions.width,\n                    videoHeight: videoStream.defaultVideoDimensions.height\n                });\n            }\n        }\n    },\n    onStreamingTimeout: function onStreamingTimeout(callback) {\n        if (utils.isFunction(callback)) {\n            callback({\n                error: true,\n                errorCode: 'getUserMedia',\n                errorMsg: 'There was an issue with the getUserMedia API - Timed out while trying to start streaming',\n                image: null,\n                cameraStream: {}\n            });\n        }\n    },\n    stream: function stream(obj) {\n        var existingVideo = utils.isArray(obj.existingVideo) ? obj.existingVideo[0] : obj.existingVideo;\n        var cameraStream = obj.cameraStream,\n            completedCallback = obj.completedCallback,\n            streamedCallback = obj.streamedCallback,\n            videoElement = obj.videoElement;\n\n\n        if (utils.isFunction(streamedCallback)) {\n            streamedCallback();\n        }\n\n        if (existingVideo) {\n            if (utils.isString(existingVideo)) {\n                videoElement.src = existingVideo;\n                videoElement.innerHTML = '<source src=\"' + existingVideo + '\" type=\"video/' + utils.getExtension(existingVideo) + '\" />';\n            } else if (existingVideo instanceof Blob) {\n                try {\n                    videoElement.src = utils.URL.createObjectURL(existingVideo);\n                } catch (e) {}\n\n                videoElement.innerHTML = '<source src=\"' + existingVideo + '\" type=\"' + existingVideo.type + '\" />';\n            }\n        } else if (videoElement.mozSrcObject) {\n            videoElement.mozSrcObject = cameraStream;\n        } else if (utils.URL) {\n            try {\n                videoElement.srcObject = cameraStream;\n                videoElement.src = utils.URL.createObjectURL(cameraStream);\n            } catch (e) {\n                videoElement.srcObject = cameraStream;\n            }\n        }\n\n        videoElement.play();\n\n        utils.requestTimeout(function checkLoadedData() {\n            checkLoadedData.count = checkLoadedData.count || 0;\n\n            if (videoStream.loadedData === true) {\n                videoStream.findVideoSize({\n                    videoElement: videoElement,\n                    cameraStream: cameraStream,\n                    completedCallback: completedCallback\n                });\n\n                videoStream.loadedData = false;\n            } else {\n                checkLoadedData.count += 1;\n\n                if (checkLoadedData.count > 10) {\n                    videoStream.findVideoSize({\n                        videoElement: videoElement,\n                        cameraStream: cameraStream,\n                        completedCallback: completedCallback\n                    });\n                } else {\n                    checkLoadedData();\n                }\n            }\n        }, 0);\n    },\n    startStreaming: function startStreaming(obj) {\n        var errorCallback = utils.isFunction(obj.error) ? obj.error : utils.noop;\n        var streamedCallback = utils.isFunction(obj.streamed) ? obj.streamed : utils.noop;\n        var completedCallback = utils.isFunction(obj.completed) ? obj.completed : utils.noop;\n        var crossOrigin = obj.crossOrigin,\n            existingVideo = obj.existingVideo,\n            lastCameraStream = obj.lastCameraStream,\n            options = obj.options,\n            webcamVideoElement = obj.webcamVideoElement;\n\n        var videoElement = utils.isElement(existingVideo) ? existingVideo : webcamVideoElement ? webcamVideoElement : document.createElement('video');\n        var cameraStream = void 0;\n\n        if (crossOrigin) {\n            videoElement.crossOrigin = options.crossOrigin;\n        }\n\n        videoElement.autoplay = true;\n        videoElement.loop = true;\n        videoElement.muted = true;\n        videoElement.addEventListener('loadeddata', function (event) {\n            videoStream.loadedData = true;\n            if (options.offset) {\n                videoElement.currentTime = options.offset;\n            }\n        });\n\n        if (existingVideo) {\n            videoStream.stream({\n                videoElement: videoElement,\n                existingVideo: existingVideo,\n                completedCallback: completedCallback\n            });\n        } else if (lastCameraStream) {\n            videoStream.stream({\n                videoElement: videoElement,\n                cameraStream: lastCameraStream,\n                streamedCallback: streamedCallback,\n                completedCallback: completedCallback\n            });\n        } else {\n            utils.getUserMedia({\n                video: true\n            }, function (stream) {\n                videoStream.stream({\n                    videoElement: videoElement,\n                    cameraStream: stream,\n                    streamedCallback: streamedCallback,\n                    completedCallback: completedCallback\n                });\n            }, errorCallback);\n        }\n    },\n    startVideoStreaming: function startVideoStreaming(callback) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var timeoutLength = options.timeout !== undefined ? options.timeout : 0;\n        var originalCallback = options.callback;\n        var webcamVideoElement = options.webcamVideoElement;\n        var noGetUserMediaSupportTimeout = void 0;\n\n        // Some browsers apparently have support for video streaming because of the\n        // presence of the getUserMedia function, but then do not answer our\n        // calls for streaming.\n        // So we'll set up this timeout and if nothing happens after a while, we'll\n        // conclude that there's no actual getUserMedia support.\n        if (timeoutLength > 0) {\n            noGetUserMediaSupportTimeout = utils.requestTimeout(function () {\n                videoStream.onStreamingTimeout(originalCallback);\n            }, 10000);\n        }\n\n        videoStream.startStreaming({\n            error: function error() {\n                originalCallback({\n                    error: true,\n                    errorCode: 'getUserMedia',\n                    errorMsg: 'There was an issue with the getUserMedia API - the user probably denied permission',\n                    image: null,\n                    cameraStream: {}\n                });\n            },\n            streamed: function streamed() {\n                // The streaming started somehow, so we can assume there is getUserMedia support\n                clearTimeout(noGetUserMediaSupportTimeout);\n            },\n            completed: function completed() {\n                var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var cameraStream = obj.cameraStream,\n                    videoElement = obj.videoElement,\n                    videoHeight = obj.videoHeight,\n                    videoWidth = obj.videoWidth;\n\n\n                callback({\n                    cameraStream: cameraStream,\n                    videoElement: videoElement,\n                    videoHeight: videoHeight,\n                    videoWidth: videoWidth\n                });\n            },\n            lastCameraStream: options.lastCameraStream,\n            webcamVideoElement: webcamVideoElement,\n            crossOrigin: options.crossOrigin,\n            options: options\n        });\n    },\n    stopVideoStreaming: function stopVideoStreaming(obj) {\n        obj = utils.isObject(obj) ? obj : {};\n\n        var _obj = obj,\n            keepCameraOn = _obj.keepCameraOn,\n            videoElement = _obj.videoElement,\n            webcamVideoElement = _obj.webcamVideoElement;\n\n        var cameraStream = obj.cameraStream || {};\n        var cameraStreamTracks = cameraStream.getTracks ? cameraStream.getTracks() || [] : [];\n        var hasCameraStreamTracks = !!cameraStreamTracks.length;\n        var firstCameraStreamTrack = cameraStreamTracks[0];\n\n        if (!keepCameraOn && hasCameraStreamTracks) {\n            if (utils.isFunction(firstCameraStreamTrack.stop)) {\n                // Stops the camera stream\n                firstCameraStreamTrack.stop();\n            }\n        }\n\n        if (utils.isElement(videoElement) && !webcamVideoElement) {\n            // Pauses the video, revokes the object URL (freeing up memory), and remove the video element\n            videoElement.pause();\n\n            // Destroys the object url\n            if (utils.isFunction(utils.URL.revokeObjectURL) && !utils.webWorkerError) {\n                if (videoElement.src) {\n                    utils.URL.revokeObjectURL(videoElement.src);\n                }\n            }\n\n            // Removes the video element from the DOM\n            utils.removeElement(videoElement);\n        }\n    }\n};\n\n/*\n  stopVideoStreaming.js\n  =====================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction stopVideoStreaming(options) {\n  options = utils.isObject(options) ? options : {};\n\n  videoStream.stopVideoStreaming(options);\n}\n\n/*\n  createAndGetGIF.js\n  ==================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction createAndGetGIF(obj, callback) {\n    var options = obj.options || {};\n\n    var images = options.images,\n        video = options.video;\n\n    var gifWidth = Number(options.gifWidth);\n    var gifHeight = Number(options.gifHeight);\n    var numFrames = Number(options.numFrames);\n    var cameraStream = obj.cameraStream,\n        videoElement = obj.videoElement,\n        videoWidth = obj.videoWidth,\n        videoHeight = obj.videoHeight;\n\n    var cropDimensions = screenShot.getCropDimensions({\n        videoWidth: videoWidth,\n        videoHeight: videoHeight,\n        gifHeight: gifHeight,\n        gifWidth: gifWidth\n    });\n    var completeCallback = callback;\n\n    options.crop = cropDimensions;\n    options.videoElement = videoElement;\n    options.videoWidth = videoWidth;\n    options.videoHeight = videoHeight;\n    options.cameraStream = cameraStream;\n\n    if (!utils.isElement(videoElement)) {\n        return;\n    }\n\n    videoElement.width = gifWidth + cropDimensions.width;\n    videoElement.height = gifHeight + cropDimensions.height;\n\n    if (!options.webcamVideoElement) {\n        utils.setCSSAttr(videoElement, {\n            position: 'fixed',\n            opacity: '0'\n        });\n\n        document.body.appendChild(videoElement);\n    }\n\n    // Firefox doesn't seem to obey autoplay if the element is not in the DOM when the content\n    // is loaded, so we must manually trigger play after adding it, or the video will be frozen\n    videoElement.play();\n\n    screenShot.getGIF(options, function (obj) {\n        if ((!images || !images.length) && (!video || !video.length)) {\n            stopVideoStreaming(obj);\n        }\n\n        completeCallback(obj);\n    });\n}\n\n/*\n  existingVideo.js\n  ================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction existingVideo() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = obj.callback,\n        existingVideo = obj.existingVideo,\n        options = obj.options;\n\n    var skipObj = {\n        getUserMedia: true,\n        'window.URL': true\n    };\n    var errorObj = error.validate(skipObj);\n    var loadedImages = 0;\n    var videoType = void 0;\n    var videoSrc = void 0;\n    var tempImage = void 0;\n    var ag = void 0;\n\n    if (errorObj.error) {\n        return callback(errorObj);\n    }\n\n    if (utils.isElement(existingVideo) && existingVideo.src) {\n        videoSrc = existingVideo.src;\n        videoType = utils.getExtension(videoSrc);\n\n        if (!utils.isSupported.videoCodecs[videoType]) {\n            return callback(error.messages.videoCodecs);\n        }\n    } else if (utils.isArray(existingVideo)) {\n        utils.each(existingVideo, function (iterator, videoSrc) {\n            if (videoSrc instanceof Blob) {\n                videoType = videoSrc.type.substr(videoSrc.type.lastIndexOf('/') + 1, videoSrc.length);\n            } else {\n                videoType = videoSrc.substr(videoSrc.lastIndexOf('.') + 1, videoSrc.length);\n            }\n\n            if (utils.isSupported.videoCodecs[videoType]) {\n                existingVideo = videoSrc;\n\n                return false;\n            }\n        });\n    }\n\n    videoStream.startStreaming({\n        completed: function completed(obj) {\n            obj.options = options || {};\n\n            createAndGetGIF(obj, callback);\n        },\n        existingVideo: existingVideo,\n        crossOrigin: options.crossOrigin,\n        options: options\n    });\n}\n\n/*\n  existingWebcam.js\n  =================\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction existingWebcam() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = obj.callback,\n        lastCameraStream = obj.lastCameraStream,\n        options = obj.options,\n        webcamVideoElement = obj.webcamVideoElement;\n\n\n    if (!isWebCamGIFSupported()) {\n        return callback(error.validate());\n    }\n\n    if (options.savedRenderingContexts.length) {\n        screenShot.getGIF(options, function (obj) {\n            callback(obj);\n        });\n\n        return;\n    }\n\n    videoStream.startVideoStreaming(function () {\n        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        obj.options = options || {};\n\n        createAndGetGIF(obj, callback);\n    }, {\n        lastCameraStream: lastCameraStream,\n        callback: callback,\n        webcamVideoElement: webcamVideoElement,\n        crossOrigin: options.crossOrigin\n    });\n}\n\n/*\n  createGIF.js\n  ============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nfunction createGIF(userOptions, callback) {\n  callback = utils.isFunction(userOptions) ? userOptions : callback;\n  userOptions = utils.isObject(userOptions) ? userOptions : {};\n\n  if (!utils.isFunction(callback)) {\n    return;\n  }\n\n  var options = utils.mergeOptions(defaultOptions, userOptions) || {};\n  var lastCameraStream = userOptions.cameraStream;\n  var images = options.images;\n  var imagesLength = images ? images.length : 0;\n  var video = options.video;\n  var webcamVideoElement = options.webcamVideoElement;\n\n  options = utils.mergeOptions(options, {\n    'gifWidth': Math.floor(options.gifWidth),\n    'gifHeight': Math.floor(options.gifHeight)\n  });\n\n  // If the user would like to create a GIF from an existing image(s)\n  if (imagesLength) {\n    existingImages({\n      'images': images,\n      'imagesLength': imagesLength,\n      'callback': callback,\n      'options': options\n    });\n  } else if (video) {\n    // If the user would like to create a GIF from an existing HTML5 video\n    existingVideo({\n      'existingVideo': video,\n      callback: callback,\n      options: options\n    });\n  } else {\n    // If the user would like to create a GIF from a webcam stream\n    existingWebcam({\n      lastCameraStream: lastCameraStream,\n      callback: callback,\n      webcamVideoElement: webcamVideoElement,\n      options: options\n    });\n  }\n}\n\n/*\n  takeSnapShot.js\n  ===============\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\nfunction takeSnapShot(userOptions, callback) {\n    callback = utils.isFunction(userOptions) ? userOptions : callback;\n    userOptions = utils.isObject(userOptions) ? userOptions : {};\n\n    if (!utils.isFunction(callback)) {\n        return;\n    }\n\n    var mergedOptions = utils.mergeOptions(defaultOptions, userOptions);\n    var options = utils.mergeOptions(mergedOptions, {\n        'interval': .1,\n        'numFrames': 1,\n        'gifWidth': Math.floor(mergedOptions.gifWidth),\n        'gifHeight': Math.floor(mergedOptions.gifHeight)\n    });\n\n    createGIF(options, callback);\n}\n\n/*\n  API.js\n  ======\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n*/\n\n// Dependencies\nvar API = {\n  'utils': utils$2,\n  'error': error$2,\n  'defaultOptions': defaultOptions$2,\n  'createGIF': createGIF,\n  'takeSnapShot': takeSnapShot,\n  'stopVideoStreaming': stopVideoStreaming,\n  'isSupported': isSupported,\n  'isWebCamGIFSupported': isWebCamGIFSupported,\n  'isExistingVideoGIFSupported': isExistingVideoGIFSupported,\n  'isExistingImagesGIFSupported': isSupported$1,\n  'VERSION': '0.4.5'\n};\n\n/*\n  index.js\n  ========\n*/\n\n/* Copyright  2017 Yahoo Inc.\n * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.\n */\n\n// Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, and plain browser loading\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return API;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n}(typeof window !== \"undefined\" ? window : {}, typeof document !== \"undefined\" ? document : { createElement: function() {} }, typeof window !== \"undefined\" ? window.navigator : {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9naWZzaG90L2Rpc3QvZ2lmc2hvdC5qcz9iZDJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qQ29weXJpZ2h0cyBmb3IgY29kZSBhdXRob3JlZCBieSBZYWhvbyBJbmMuIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBmb2xsb3dpbmcgdGVybXM6XG5NSVQgTGljZW5zZVxuQ29weXJpZ2h0ICAyMDE3IFlhaG9vIEluYy5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cbjsoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgbmF2aWdhdG9yLCB1bmRlZmluZWQpIHtcblwidXNlIHN0cmljdFwiO1xuXG4vKlxuICB1dGlscy5qc1xuICA9PT09PT09PVxuKi9cblxuLyogQ29weXJpZ2h0ICAyMDE3IFlhaG9vIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxudmFyIHV0aWxzID0ge1xuICAgIFVSTDogd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMLFxuICAgIGdldFVzZXJNZWRpYTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhO1xuXG4gICAgICAgIHJldHVybiBnZXRVc2VyTWVkaWEgPyBnZXRVc2VyTWVkaWEuYmluZChuYXZpZ2F0b3IpIDogZ2V0VXNlck1lZGlhO1xuICAgIH0oKSxcbiAgICByZXF1ZXN0QW5pbUZyYW1lOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uIHJlcXVlc3RUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSkge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHV0aWxzLm5vb3A7XG4gICAgICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICAgICAgICBpZiAoIXV0aWxzLnJlcXVlc3RBbmltRnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgdmFyIHJlcXVlc3RBbmltRnJhbWUgPSB1dGlscy5yZXF1ZXN0QW5pbUZyYW1lO1xuXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBjdXJyZW50IC0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGRlbHRhID49IGRlbGF5ID8gY2FsbGJhY2suY2FsbCgpIDogaGFuZGxlLnZhbHVlID0gcmVxdWVzdEFuaW1GcmFtZShsb29wKTtcbiAgICAgICAgfTtcblxuICAgICAgICBoYW5kbGUudmFsdWUgPSByZXF1ZXN0QW5pbUZyYW1lKGxvb3ApO1xuXG4gICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfSxcbiAgICBCbG9iOiB3aW5kb3cuQmxvYiB8fCB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlciB8fCB3aW5kb3cuTVNCbG9iQnVpbGRlcixcbiAgICBidG9hOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidG9hID0gd2luZG93LmJ0b2EgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgbCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgICAgICAgICAgdmFyIGNocjEgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBjaHIzID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGVuYzEgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZW5jMiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBlbmMzID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGVuYzQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCkge1xuICAgICAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgICAgICAgICAgZW5jMiA9IChjaHIxICYgMykgPDwgNCB8IGNocjIgPj4gNDtcbiAgICAgICAgICAgICAgICBlbmMzID0gKGNocjIgJiAxNSkgPDwgMiB8IGNocjMgPj4gNjtcbiAgICAgICAgICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsga2V5LmNoYXJBdChlbmMxKSArIGtleS5jaGFyQXQoZW5jMikgKyBrZXkuY2hhckF0KGVuYzMpICsga2V5LmNoYXJBdChlbmM0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYnRvYSA/IGJ0b2EuYmluZCh3aW5kb3cpIDogdXRpbHMubm9vcDtcbiAgICB9KCksXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9LFxuICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5pc09iamVjdChvYmopICYmICFPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbiAgICB9LFxuICAgIGlzQXJyYXk6IGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIgJiYgQXJyYXkuaXNBcnJheShhcnIpO1xuICAgIH0sXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jICYmIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbSkge1xuICAgICAgICByZXR1cm4gZWxlbSAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgIH0sXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH0sXG4gICAgaXNTdXBwb3J0ZWQ6IHtcbiAgICAgICAgY2FudmFzOiBmdW5jdGlvbiBjYW52YXMoKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsICYmIGVsLmdldENvbnRleHQgJiYgZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2Vid29ya2VyczogZnVuY3Rpb24gd2Vid29ya2VycygpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuV29ya2VyO1xuICAgICAgICB9LFxuICAgICAgICBibG9iOiBmdW5jdGlvbiBibG9iKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLkJsb2I7XG4gICAgICAgIH0sXG4gICAgICAgIFVpbnQ4QXJyYXk6IGZ1bmN0aW9uIFVpbnQ4QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LlVpbnQ4QXJyYXk7XG4gICAgICAgIH0sXG4gICAgICAgIFVpbnQzMkFycmF5OiBmdW5jdGlvbiBVaW50MzJBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuVWludDMyQXJyYXk7XG4gICAgICAgIH0sXG4gICAgICAgIHZpZGVvQ29kZWNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0T2JqID0ge1xuICAgICAgICAgICAgICAgICdtcDQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnaDI2NCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdvZ3YnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnb2dnJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3dlYm0nOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdEVsICYmIHRlc3RFbC5jYW5QbGF5VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgTVBFRy00IHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydE9iai5tcDQgPSB0ZXN0RWwuY2FuUGxheVR5cGUoJ3ZpZGVvL21wNDsgY29kZWNzPVwibXA0di4yMC44XCInKSAhPT0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGgyNjQgc3VwcG9ydFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0T2JqLmgyNjQgPSAodGVzdEVsLmNhblBsYXlUeXBlKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInKSB8fCB0ZXN0RWwuY2FuUGxheVR5cGUoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsIG1wNGEuNDAuMlwiJykpICE9PSAnJztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgT2d2IHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydE9iai5vZ3YgPSB0ZXN0RWwuY2FuUGxheVR5cGUoJ3ZpZGVvL29nZzsgY29kZWNzPVwidGhlb3JhXCInKSAhPT0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIE9nZyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRPYmoub2dnID0gdGVzdEVsLmNhblBsYXlUeXBlKCd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYVwiJykgIT09ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBXZWJtIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydE9iai53ZWJtID0gdGVzdEVsLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDgsIHZvcmJpc1wiJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0T2JqO1xuICAgICAgICB9KClcbiAgICB9LFxuICAgIG5vb3A6IGZ1bmN0aW9uIG5vb3AoKSB7fSxcbiAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4ID0gdm9pZCAwO1xuICAgICAgICB2YXIgbGVuID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh1dGlscy5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICB4ID0gLTE7XG4gICAgICAgICAgICBsZW4gPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKCsreCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayh4LCBjb2xsZWN0aW9uW3hdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICBmb3IgKHggaW4gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLmhhc093blByb3BlcnR5KHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayh4LCBjb2xsZWN0aW9uW3hdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXJnZU9wdGlvbnM6IGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc09iamVjdChkZWZhdWx0T3B0aW9ucykgfHwgIXV0aWxzLmlzT2JqZWN0KHVzZXJPcHRpb25zKSB8fCAhT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICB1dGlscy5lYWNoKGRlZmF1bHRPcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgICAgIG5ld09ialtrZXldID0gZGVmYXVsdE9wdGlvbnNba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXRpbHMuZWFjaCh1c2VyT3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFVzZXJPcHRpb24gPSB1c2VyT3B0aW9uc1trZXldO1xuXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzT2JqZWN0KGN1cnJlbnRVc2VyT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gY3VycmVudFVzZXJPcHRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZGVmYXVsdE9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IGN1cnJlbnRVc2VyT3B0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gdXRpbHMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zW2tleV0sIGN1cnJlbnRVc2VyT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSxcbiAgICBzZXRDU1NBdHRyOiBmdW5jdGlvbiBzZXRDU1NBdHRyKGVsZW0sIGF0dHIsIHZhbCkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzRWxlbWVudChlbGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGF0dHIpICYmIHV0aWxzLmlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGVbYXR0cl0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoYXR0cikpIHtcbiAgICAgICAgICAgIHV0aWxzLmVhY2goYXR0ciwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQobm9kZSkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlV2ViV29ya2VyOiBmdW5jdGlvbiBjcmVhdGVXZWJXb3JrZXIoY29udGVudCkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgdXRpbHMuQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBvYmplY3RVcmwgPSB1dGlscy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnb2JqZWN0VXJsJzogb2JqZWN0VXJsLFxuICAgICAgICAgICAgICAgICd3b3JrZXInOiB3b3JrZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEV4dGVuc2lvbjogZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHNyYykge1xuICAgICAgICByZXR1cm4gc3JjLnN1YnN0cihzcmMubGFzdEluZGV4T2YoJy4nKSArIDEsIHNyYy5sZW5ndGgpO1xuICAgIH0sXG4gICAgZ2V0Rm9udFNpemU6IGZ1bmN0aW9uIGdldEZvbnRTaXplKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5IHx8IG9wdGlvbnMucmVzaXplRm9udCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZvbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IG9wdGlvbnMuZ2lmV2lkdGg7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHBhcnNlSW50KG9wdGlvbnMuZm9udFNpemUsIDEwKTtcbiAgICAgICAgdmFyIG1pbkZvbnRTaXplID0gcGFyc2VJbnQob3B0aW9ucy5taW5Gb250U2l6ZSwgMTApO1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cbiAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICBzcGFuLnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKyAncHgnO1xuICAgICAgICBzcGFuLnN0eWxlLnRleHRJbmRlbnQgPSAnLTk5OTlweCc7XG4gICAgICAgIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cbiAgICAgICAgd2hpbGUgKHNwYW4ub2Zmc2V0V2lkdGggPiBjb250YWluZXJXaWR0aCAmJiBmb250U2l6ZSA+PSBtaW5Gb250U2l6ZSkge1xuICAgICAgICAgICAgc3Bhbi5zdHlsZS5mb250U2l6ZSA9IC0tZm9udFNpemUgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzcGFuKTtcblxuICAgICAgICByZXR1cm4gZm9udFNpemUgKyAncHgnO1xuICAgIH0sXG4gICAgd2ViV29ya2VyRXJyb3I6IGZhbHNlXG59O1xuXG5cblxudmFyIHV0aWxzJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogdXRpbHNcbn0pO1xuXG4vKlxuICBlcnJvci5qc1xuICA9PT09PT09PVxuKi9cblxuLyogQ29weXJpZ2h0ICAyMDE3IFlhaG9vIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuLy8gRGVwZW5kZW5jaWVzXG52YXIgZXJyb3IgPSB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHNraXBPYmopIHtcbiAgICAgICAgc2tpcE9iaiA9IHV0aWxzLmlzT2JqZWN0KHNraXBPYmopID8gc2tpcE9iaiA6IHt9O1xuXG4gICAgICAgIHZhciBlcnJvck9iaiA9IHt9O1xuXG4gICAgICAgIHV0aWxzLmVhY2goZXJyb3IudmFsaWRhdG9ycywgZnVuY3Rpb24gKGluZGVjZSwgY3VycmVudFZhbGlkYXRvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yQ29kZSA9IGN1cnJlbnRWYWxpZGF0b3IuZXJyb3JDb2RlO1xuXG4gICAgICAgICAgICBpZiAoIXNraXBPYmpbZXJyb3JDb2RlXSAmJiAhY3VycmVudFZhbGlkYXRvci5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvck9iaiA9IGN1cnJlbnRWYWxpZGF0b3I7XG4gICAgICAgICAgICAgICAgZXJyb3JPYmouZXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkZWxldGUgZXJyb3JPYmouY29uZGl0aW9uO1xuXG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uIGlzVmFsaWQoc2tpcE9iaikge1xuICAgICAgICB2YXIgZXJyb3JPYmogPSBlcnJvci52YWxpZGF0ZShza2lwT2JqKTtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSBlcnJvck9iai5lcnJvciAhPT0gdHJ1ZSA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuICAgIHZhbGlkYXRvcnM6IFt7XG4gICAgICAgIGNvbmRpdGlvbjogdXRpbHMuaXNGdW5jdGlvbih1dGlscy5nZXRVc2VyTWVkaWEpLFxuICAgICAgICBlcnJvckNvZGU6ICdnZXRVc2VyTWVkaWEnLFxuICAgICAgICBlcnJvck1zZzogJ1RoZSBnZXRVc2VyTWVkaWEgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJ1xuICAgIH0sIHtcbiAgICAgICAgY29uZGl0aW9uOiB1dGlscy5pc1N1cHBvcnRlZC5jYW52YXMoKSxcbiAgICAgICAgZXJyb3JDb2RlOiAnY2FudmFzJyxcbiAgICAgICAgZXJyb3JNc2c6ICdDYW52YXMgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJ1xuICAgIH0sIHtcbiAgICAgICAgY29uZGl0aW9uOiB1dGlscy5pc1N1cHBvcnRlZC53ZWJ3b3JrZXJzKCksXG4gICAgICAgIGVycm9yQ29kZTogJ3dlYndvcmtlcnMnLFxuICAgICAgICBlcnJvck1zZzogJ1RoZSBXZWIgV29ya2VycyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXInXG4gICAgfSwge1xuICAgICAgICBjb25kaXRpb246IHV0aWxzLmlzRnVuY3Rpb24odXRpbHMuVVJMKSxcbiAgICAgICAgZXJyb3JDb2RlOiAnd2luZG93LlVSTCcsXG4gICAgICAgIGVycm9yTXNnOiAnVGhlIHdpbmRvdy5VUkwgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJ1xuICAgIH0sIHtcbiAgICAgICAgY29uZGl0aW9uOiB1dGlscy5pc1N1cHBvcnRlZC5ibG9iKCksXG4gICAgICAgIGVycm9yQ29kZTogJ3dpbmRvdy5CbG9iJyxcbiAgICAgICAgZXJyb3JNc2c6ICdUaGUgd2luZG93LkJsb2IgRmlsZSBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXInXG4gICAgfSwge1xuICAgICAgICBjb25kaXRpb246IHV0aWxzLmlzU3VwcG9ydGVkLlVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZXJyb3JDb2RlOiAnd2luZG93LlVpbnQ4QXJyYXknLFxuICAgICAgICBlcnJvck1zZzogJ1RoZSB3aW5kb3cuVWludDhBcnJheSBmdW5jdGlvbiBjb25zdHJ1Y3RvciBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlcidcbiAgICB9LCB7XG4gICAgICAgIGNvbmRpdGlvbjogdXRpbHMuaXNTdXBwb3J0ZWQuVWludDMyQXJyYXkoKSxcbiAgICAgICAgZXJyb3JDb2RlOiAnd2luZG93LlVpbnQzMkFycmF5JyxcbiAgICAgICAgZXJyb3JNc2c6ICdUaGUgd2luZG93LlVpbnQzMkFycmF5IGZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJ1xuICAgIH1dLFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIHZpZGVvQ29kZWNzOiB7XG4gICAgICAgICAgICBlcnJvckNvZGU6ICd2aWRlb2NvZGVjJyxcbiAgICAgICAgICAgIGVycm9yTXNnOiAnVGhlIHZpZGVvIGNvZGVjIHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSBpcyBub3Qgc3VwcG9ydGVkIGluIHlvdXIgYnJvd3NlcidcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG52YXIgZXJyb3IkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBlcnJvclxufSk7XG5cbi8qXG4gIGRlZmF1bHRPcHRpb25zLmpzXG4gID09PT09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4vLyBIZWxwZXJzXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNhbXBsZUludGVydmFsOiAxMCxcbiAgICBudW1Xb3JrZXJzOiAyLFxuICAgIGZpbHRlcjogJycsXG4gICAgZ2lmV2lkdGg6IDIwMCxcbiAgICBnaWZIZWlnaHQ6IDIwMCxcbiAgICBpbnRlcnZhbDogMC4xLFxuICAgIG51bUZyYW1lczogMTAsXG4gICAgZnJhbWVEdXJhdGlvbjogMSxcbiAgICBrZWVwQ2FtZXJhT246IGZhbHNlLFxuICAgIGltYWdlczogW10sXG4gICAgdmlkZW86IG51bGwsXG4gICAgd2ViY2FtVmlkZW9FbGVtZW50OiBudWxsLFxuICAgIGNhbWVyYVN0cmVhbTogbnVsbCxcbiAgICB0ZXh0OiAnJyxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgIG1pbkZvbnRTaXplOiAnMTBweCcsXG4gICAgcmVzaXplRm9udDogZmFsc2UsXG4gICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgIGZvbnRDb2xvcjogJyNmZmZmZmYnLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgdGV4dEJhc2VsaW5lOiAnYm90dG9tJyxcbiAgICB0ZXh0WENvb3JkaW5hdGU6IG51bGwsXG4gICAgdGV4dFlDb29yZGluYXRlOiBudWxsLFxuICAgIHByb2dyZXNzQ2FsbGJhY2s6IG5vb3AsXG4gICAgY29tcGxldGVDYWxsYmFjazogbm9vcCxcbiAgICBzYXZlUmVuZGVyaW5nQ29udGV4dHM6IGZhbHNlLFxuICAgIHNhdmVkUmVuZGVyaW5nQ29udGV4dHM6IFtdLFxuICAgIGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJ1xufTtcblxuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IGRlZmF1bHRPcHRpb25zXG59KTtcblxuLypcbiAgaXNTdXBwb3J0ZWQuanNcbiAgPT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBlcnJvci5pc1ZhbGlkKCk7XG59XG5cbi8qXG4gIGlzV2ViQ2FtR0lGU3VwcG9ydGVkLmpzXG4gID09PT09PT09PT09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG5mdW5jdGlvbiBpc1dlYkNhbUdJRlN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIGVycm9yLmlzVmFsaWQoKTtcbn1cblxuLypcbiAgaXNTdXBwb3J0ZWQuanNcbiAgPT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWQkMSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZ2V0VXNlck1lZGlhOiB0cnVlXG4gICAgfTtcblxuICAgIHJldHVybiBlcnJvci5pc1ZhbGlkKG9wdGlvbnMpO1xufVxuXG4vKlxuICBpc0V4aXN0aW5nVmlkZW9HSUZTdXBwb3J0ZWQuanNcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4vLyBEZXBlbmRlbmNpZXNcbmZ1bmN0aW9uIGlzRXhpc3RpbmdWaWRlb0dJRlN1cHBvcnRlZChjb2RlY3MpIHtcbiAgICB2YXIgaGFzVmFsaWRDb2RlYyA9IGZhbHNlO1xuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoY29kZWNzKSAmJiBjb2RlY3MubGVuZ3RoKSB7XG4gICAgICAgIHV0aWxzLmVhY2goY29kZWNzLCBmdW5jdGlvbiAoaW5kZWNlLCBjdXJyZW50Q29kZWMpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1N1cHBvcnRlZC52aWRlb0NvZGVjc1tjdXJyZW50Q29kZWNdKSB7XG4gICAgICAgICAgICAgICAgaGFzVmFsaWRDb2RlYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghaGFzVmFsaWRDb2RlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmluZyhjb2RlY3MpICYmIGNvZGVjcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc1N1cHBvcnRlZC52aWRlb0NvZGVjc1tjb2RlY3NdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3IuaXNWYWxpZCh7XG4gICAgICAgICdnZXRVc2VyTWVkaWEnOiB0cnVlXG4gICAgfSk7XG59XG5cbi8qXG4gIE5ldVF1YW50LmpzXG4gID09PT09PT09PT09XG4qL1xuXG4vKlxuICogTmV1UXVhbnQgTmV1cmFsLU5ldCBRdWFudGl6YXRpb24gQWxnb3JpdGhtXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDE5OTQgQW50aG9ueSBEZWtrZXJcbiAqXG4gKiBORVVRVUFOVCBOZXVyYWwtTmV0IHF1YW50aXphdGlvbiBhbGdvcml0aG0gYnkgQW50aG9ueSBEZWtrZXIsIDE5OTQuIFNlZVxuICogXCJLb2hvbmVuIG5ldXJhbCBuZXR3b3JrcyBmb3Igb3B0aW1hbCBjb2xvdXIgcXVhbnRpemF0aW9uXCIgaW4gXCJOZXR3b3JrOlxuICogQ29tcHV0YXRpb24gaW4gTmV1cmFsIFN5c3RlbXNcIiBWb2wuIDUgKDE5OTQpIHBwIDM1MS0zNjcuIGZvciBhIGRpc2N1c3Npb24gb2ZcbiAqIHRoZSBhbGdvcml0aG0uXG4gKlxuICogQW55IHBhcnR5IG9idGFpbmluZyBhIGNvcHkgb2YgdGhlc2UgZmlsZXMgZnJvbSB0aGUgYXV0aG9yLCBkaXJlY3RseSBvclxuICogaW5kaXJlY3RseSwgaXMgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIGEgZnVsbCBhbmQgdW5yZXN0cmljdGVkIGlycmV2b2NhYmxlLFxuICogd29ybGQtd2lkZSwgcGFpZCB1cCwgcm95YWx0eS1mcmVlLCBub25leGNsdXNpdmUgcmlnaHQgYW5kIGxpY2Vuc2UgdG8gZGVhbCBpblxuICogdGhpcyBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIGluY2x1ZGluZyB3aXRob3V0XG4gKiBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLFxuICogc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHdob1xuICogcmVjZWl2ZSBjb3BpZXMgZnJvbSBhbnkgc3VjaCBwYXJ0eSB0byBkbyBzbywgd2l0aCB0aGUgb25seSByZXF1aXJlbWVudCBiZWluZ1xuICogdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgcmVtYWluIGludGFjdC5cbiAqL1xuXG4vKlxuICogVGhpcyBjbGFzcyBoYW5kbGVzIE5ldXJhbC1OZXQgcXVhbnRpemF0aW9uIGFsZ29yaXRobVxuICogQGF1dGhvciBLZXZpbiBXZWluZXIgKG9yaWdpbmFsIEphdmEgdmVyc2lvbiAtIGt3ZWluZXJAZm1zd2FyZS5jb20pXG4gKiBAYXV0aG9yIFRoaWJhdWx0IEltYmVydCAoQVMzIHZlcnNpb24gLSBieXRlYXJyYXkub3JnKVxuICogQHZlcnNpb24gMC4xIEFTMyBpbXBsZW1lbnRhdGlvblxuICogQHZlcnNpb24gMC4yIEpTLT5BUzMgXCJ0cmFuc2xhdGlvblwiIGJ5IGFudGltYXR0ZXIxNVxuICogQHZlcnNpb24gMC4zIEpTIGNsZWFuIHVwICsgdXNpbmcgbW9kZXJuIEpTIGlkaW9tcyBieSBzb2xlIC0gaHR0cDovL3NvbGVkYWRwZW5hZGVzLmNvbVxuICogQWxzbyBpbXBsZW1lbnQgZml4IGluIGNvbG9yIGNvbnZlcnNpb24gZGVzY3JpYmVkIGF0IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTYzNzE3MTIvbmV1cXVhbnQtanMtamF2YXNjcmlwdC1jb2xvci1xdWFudGl6YXRpb24taGlkZGVuLWJ1Zy1pbi1qcy1jb252ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gTmV1UXVhbnQoKSB7XG4gIHZhciBuZXRzaXplID0gMjU2OyAvLyBudW1iZXIgb2YgY29sb3VycyB1c2VkXG5cbiAgLy8gZm91ciBwcmltZXMgbmVhciA1MDAgLSBhc3N1bWUgbm8gaW1hZ2UgaGFzIGEgbGVuZ3RoIHNvIGxhcmdlXG4gIC8vIHRoYXQgaXQgaXMgZGl2aXNpYmxlIGJ5IGFsbCBmb3VyIHByaW1lc1xuICB2YXIgcHJpbWUxID0gNDk5O1xuICB2YXIgcHJpbWUyID0gNDkxO1xuICB2YXIgcHJpbWUzID0gNDg3O1xuICB2YXIgcHJpbWU0ID0gNTAzO1xuXG4gIC8vIG1pbmltdW0gc2l6ZSBmb3IgaW5wdXQgaW1hZ2VcbiAgdmFyIG1pbnBpY3R1cmVieXRlcyA9IDMgKiBwcmltZTQ7XG5cbiAgLy8gTmV0d29yayBEZWZpbml0aW9uc1xuXG4gIHZhciBtYXhuZXRwb3MgPSBuZXRzaXplIC0gMTtcbiAgdmFyIG5ldGJpYXNzaGlmdCA9IDQ7IC8vIGJpYXMgZm9yIGNvbG91ciB2YWx1ZXNcbiAgdmFyIG5jeWNsZXMgPSAxMDA7IC8vIG5vLiBvZiBsZWFybmluZyBjeWNsZXNcblxuICAvLyBkZWZzIGZvciBmcmVxIGFuZCBiaWFzXG4gIHZhciBpbnRiaWFzc2hpZnQgPSAxNjsgLy8gYmlhcyBmb3IgZnJhY3Rpb25zXG4gIHZhciBpbnRiaWFzID0gMSA8PCBpbnRiaWFzc2hpZnQ7XG4gIHZhciBnYW1tYXNoaWZ0ID0gMTA7IC8vIGdhbW1hID0gMTAyNFxuICB2YXIgZ2FtbWEgPSAxIDw8IGdhbW1hc2hpZnQ7XG4gIHZhciBiZXRhc2hpZnQgPSAxMDtcbiAgdmFyIGJldGEgPSBpbnRiaWFzID4+IGJldGFzaGlmdDsgLy8gYmV0YSA9IDEvMTAyNFxuICB2YXIgYmV0YWdhbW1hID0gaW50YmlhcyA8PCBnYW1tYXNoaWZ0IC0gYmV0YXNoaWZ0O1xuXG4gIC8vIGRlZnMgZm9yIGRlY3JlYXNpbmcgcmFkaXVzIGZhY3RvclxuICAvLyBGb3IgMjU2IGNvbG9ycywgcmFkaXVzIHN0YXJ0cyBhdCAzMi4wIGJpYXNlZCBieSA2IGJpdHNcbiAgLy8gYW5kIGRlY3JlYXNlcyBieSBhIGZhY3RvciBvZiAxLzMwIGVhY2ggY3ljbGVcbiAgdmFyIGluaXRyYWQgPSBuZXRzaXplID4+IDM7XG4gIHZhciByYWRpdXNiaWFzc2hpZnQgPSA2O1xuICB2YXIgcmFkaXVzYmlhcyA9IDEgPDwgcmFkaXVzYmlhc3NoaWZ0O1xuICB2YXIgaW5pdHJhZGl1cyA9IGluaXRyYWQgKiByYWRpdXNiaWFzO1xuICB2YXIgcmFkaXVzZGVjID0gMzA7XG5cbiAgLy8gZGVmcyBmb3IgZGVjcmVhc2luZyBhbHBoYSBmYWN0b3JcbiAgLy8gQWxwaGEgc3RhcnRzIGF0IDEuMCBiaWFzZWQgYnkgMTAgYml0c1xuICB2YXIgYWxwaGFiaWFzc2hpZnQgPSAxMDtcbiAgdmFyIGluaXRhbHBoYSA9IDEgPDwgYWxwaGFiaWFzc2hpZnQ7XG4gIHZhciBhbHBoYWRlYztcblxuICAvLyByYWRiaWFzIGFuZCBhbHBoYXJhZGJpYXMgdXNlZCBmb3IgcmFkcG93ZXIgY2FsY3VsYXRpb25cbiAgdmFyIHJhZGJpYXNzaGlmdCA9IDg7XG4gIHZhciByYWRiaWFzID0gMSA8PCByYWRiaWFzc2hpZnQ7XG4gIHZhciBhbHBoYXJhZGJzaGlmdCA9IGFscGhhYmlhc3NoaWZ0ICsgcmFkYmlhc3NoaWZ0O1xuICB2YXIgYWxwaGFyYWRiaWFzID0gMSA8PCBhbHBoYXJhZGJzaGlmdDtcblxuICAvLyBJbnB1dCBpbWFnZVxuICB2YXIgdGhlcGljdHVyZTtcbiAgLy8gSGVpZ2h0ICogV2lkdGggKiAzXG4gIHZhciBsZW5ndGhjb3VudDtcbiAgLy8gU2FtcGxpbmcgZmFjdG9yIDEuLjMwXG4gIHZhciBzYW1wbGVmYWM7XG5cbiAgLy8gVGhlIG5ldHdvcmsgaXRzZWxmXG4gIHZhciBuZXR3b3JrO1xuICB2YXIgbmV0aW5kZXggPSBbXTtcblxuICAvLyBmb3IgbmV0d29yayBsb29rdXAgLSByZWFsbHkgMjU2XG4gIHZhciBiaWFzID0gW107XG5cbiAgLy8gYmlhcyBhbmQgZnJlcSBhcnJheXMgZm9yIGxlYXJuaW5nXG4gIHZhciBmcmVxID0gW107XG4gIHZhciByYWRwb3dlciA9IFtdO1xuXG4gIGZ1bmN0aW9uIE5ldVF1YW50Q29uc3RydWN0b3IodGhlcGljLCBsZW4sIHNhbXBsZSkge1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIHA7XG5cbiAgICB0aGVwaWN0dXJlID0gdGhlcGljO1xuICAgIGxlbmd0aGNvdW50ID0gbGVuO1xuICAgIHNhbXBsZWZhYyA9IHNhbXBsZTtcblxuICAgIG5ldHdvcmsgPSBuZXcgQXJyYXkobmV0c2l6ZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV0c2l6ZTsgaSsrKSB7XG4gICAgICBuZXR3b3JrW2ldID0gbmV3IEFycmF5KDQpO1xuICAgICAgcCA9IG5ldHdvcmtbaV07XG4gICAgICBwWzBdID0gcFsxXSA9IHBbMl0gPSAoaSA8PCBuZXRiaWFzc2hpZnQgKyA4KSAvIG5ldHNpemUgfCAwO1xuICAgICAgZnJlcVtpXSA9IGludGJpYXMgLyBuZXRzaXplIHwgMDsgLy8gMSAvIG5ldHNpemVcbiAgICAgIGJpYXNbaV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9yTWFwKCkge1xuICAgIHZhciBtYXAgPSBbXTtcbiAgICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobmV0c2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcbiAgICAgIGluZGV4W25ldHdvcmtbaV1bM11dID0gaTtcbiAgICB9dmFyIGsgPSAwO1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbmV0c2l6ZTsgbCsrKSB7XG4gICAgICB2YXIgaiA9IGluZGV4W2xdO1xuICAgICAgbWFwW2srK10gPSBuZXR3b3JrW2pdWzBdO1xuICAgICAgbWFwW2srK10gPSBuZXR3b3JrW2pdWzFdO1xuICAgICAgbWFwW2srK10gPSBuZXR3b3JrW2pdWzJdO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgLy8gSW5zZXJ0aW9uIHNvcnQgb2YgbmV0d29yayBhbmQgYnVpbGRpbmcgb2YgbmV0aW5kZXhbMC4uMjU1XVxuICAvLyAodG8gZG8gYWZ0ZXIgdW5iaWFzKVxuICBmdW5jdGlvbiBpbnhidWlsZCgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgc21hbGxwb3M7XG4gICAgdmFyIHNtYWxsdmFsO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuICAgIHZhciBwcmV2aW91c2NvbDtcbiAgICB2YXIgc3RhcnRwb3M7XG5cbiAgICBwcmV2aW91c2NvbCA9IDA7XG4gICAgc3RhcnRwb3MgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ldHNpemU7IGkrKykge1xuXG4gICAgICBwID0gbmV0d29ya1tpXTtcbiAgICAgIHNtYWxscG9zID0gaTtcbiAgICAgIHNtYWxsdmFsID0gcFsxXTsgLy8gaW5kZXggb24gZ1xuICAgICAgLy8gZmluZCBzbWFsbGVzdCBpbiBpLi5uZXRzaXplLTFcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbmV0c2l6ZTsgaisrKSB7XG5cbiAgICAgICAgcSA9IG5ldHdvcmtbal07XG5cbiAgICAgICAgaWYgKHFbMV0gPCBzbWFsbHZhbCkge1xuICAgICAgICAgIC8vIGluZGV4IG9uIGdcbiAgICAgICAgICBzbWFsbHBvcyA9IGo7XG4gICAgICAgICAgc21hbGx2YWwgPSBxWzFdOyAvLyBpbmRleCBvbiBnXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcSA9IG5ldHdvcmtbc21hbGxwb3NdO1xuXG4gICAgICAvLyBzd2FwIHAgKGkpIGFuZCBxIChzbWFsbHBvcykgZW50cmllc1xuICAgICAgaWYgKGkgIT0gc21hbGxwb3MpIHtcbiAgICAgICAgaiA9IHFbMF07XG4gICAgICAgIHFbMF0gPSBwWzBdO1xuICAgICAgICBwWzBdID0gajtcbiAgICAgICAgaiA9IHFbMV07XG4gICAgICAgIHFbMV0gPSBwWzFdO1xuICAgICAgICBwWzFdID0gajtcbiAgICAgICAgaiA9IHFbMl07XG4gICAgICAgIHFbMl0gPSBwWzJdO1xuICAgICAgICBwWzJdID0gajtcbiAgICAgICAgaiA9IHFbM107XG4gICAgICAgIHFbM10gPSBwWzNdO1xuICAgICAgICBwWzNdID0gajtcbiAgICAgIH1cblxuICAgICAgLy8gc21hbGx2YWwgZW50cnkgaXMgbm93IGluIHBvc2l0aW9uIGlcbiAgICAgIGlmIChzbWFsbHZhbCAhPSBwcmV2aW91c2NvbCkge1xuXG4gICAgICAgIG5ldGluZGV4W3ByZXZpb3VzY29sXSA9IHN0YXJ0cG9zICsgaSA+PiAxO1xuXG4gICAgICAgIGZvciAoaiA9IHByZXZpb3VzY29sICsgMTsgaiA8IHNtYWxsdmFsOyBqKyspIHtcbiAgICAgICAgICBuZXRpbmRleFtqXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c2NvbCA9IHNtYWxsdmFsO1xuICAgICAgICBzdGFydHBvcyA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV0aW5kZXhbcHJldmlvdXNjb2xdID0gc3RhcnRwb3MgKyBtYXhuZXRwb3MgPj4gMTtcbiAgICBmb3IgKGogPSBwcmV2aW91c2NvbCArIDE7IGogPCAyNTY7IGorKykge1xuICAgICAgbmV0aW5kZXhbal0gPSBtYXhuZXRwb3M7IC8vIHJlYWxseSAyNTZcbiAgICB9XG4gIH1cblxuICAvLyBNYWluIExlYXJuaW5nIExvb3BcblxuICBmdW5jdGlvbiBsZWFybigpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgYjtcbiAgICB2YXIgZztcbiAgICB2YXIgcjtcbiAgICB2YXIgcmFkaXVzO1xuICAgIHZhciByYWQ7XG4gICAgdmFyIGFscGhhO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBkZWx0YTtcbiAgICB2YXIgc2FtcGxlcGl4ZWxzO1xuICAgIHZhciBwO1xuICAgIHZhciBwaXg7XG4gICAgdmFyIGxpbTtcblxuICAgIGlmIChsZW5ndGhjb3VudCA8IG1pbnBpY3R1cmVieXRlcykge1xuICAgICAgc2FtcGxlZmFjID0gMTtcbiAgICB9XG5cbiAgICBhbHBoYWRlYyA9IDMwICsgKHNhbXBsZWZhYyAtIDEpIC8gMztcbiAgICBwID0gdGhlcGljdHVyZTtcbiAgICBwaXggPSAwO1xuICAgIGxpbSA9IGxlbmd0aGNvdW50O1xuICAgIHNhbXBsZXBpeGVscyA9IGxlbmd0aGNvdW50IC8gKDMgKiBzYW1wbGVmYWMpO1xuICAgIGRlbHRhID0gc2FtcGxlcGl4ZWxzIC8gbmN5Y2xlcyB8IDA7XG4gICAgYWxwaGEgPSBpbml0YWxwaGE7XG4gICAgcmFkaXVzID0gaW5pdHJhZGl1cztcblxuICAgIHJhZCA9IHJhZGl1cyA+PiByYWRpdXNiaWFzc2hpZnQ7XG4gICAgaWYgKHJhZCA8PSAxKSB7XG4gICAgICByYWQgPSAwO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCByYWQ7IGkrKykge1xuICAgICAgcmFkcG93ZXJbaV0gPSBhbHBoYSAqICgocmFkICogcmFkIC0gaSAqIGkpICogcmFkYmlhcyAvIChyYWQgKiByYWQpKTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoY291bnQgPCBtaW5waWN0dXJlYnl0ZXMpIHtcbiAgICAgIHN0ZXAgPSAzO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoY291bnQgJSBwcmltZTEgIT09IDApIHtcbiAgICAgIHN0ZXAgPSAzICogcHJpbWUxO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmIChsZW5ndGhjb3VudCAlIHByaW1lMiAhPT0gMCkge1xuICAgICAgICBzdGVwID0gMyAqIHByaW1lMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsZW5ndGhjb3VudCAlIHByaW1lMyAhPT0gMCkge1xuICAgICAgICAgIHN0ZXAgPSAzICogcHJpbWUzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXAgPSAzICogcHJpbWU0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHNhbXBsZXBpeGVscykge1xuXG4gICAgICBiID0gKHBbcGl4ICsgMF0gJiAweGZmKSA8PCBuZXRiaWFzc2hpZnQ7XG4gICAgICBnID0gKHBbcGl4ICsgMV0gJiAweGZmKSA8PCBuZXRiaWFzc2hpZnQ7XG4gICAgICByID0gKHBbcGl4ICsgMl0gJiAweGZmKSA8PCBuZXRiaWFzc2hpZnQ7XG4gICAgICBqID0gY29udGVzdChiLCBnLCByKTtcblxuICAgICAgYWx0ZXJzaW5nbGUoYWxwaGEsIGosIGIsIGcsIHIpO1xuXG4gICAgICBpZiAocmFkICE9PSAwKSB7XG4gICAgICAgIC8vIEFsdGVyIG5laWdoYm91cnNcbiAgICAgICAgYWx0ZXJuZWlnaChyYWQsIGosIGIsIGcsIHIpO1xuICAgICAgfVxuXG4gICAgICBwaXggKz0gc3RlcDtcblxuICAgICAgaWYgKHBpeCA+PSBsaW0pIHtcbiAgICAgICAgcGl4IC09IGxlbmd0aGNvdW50O1xuICAgICAgfVxuXG4gICAgICBpKys7XG5cbiAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICBkZWx0YSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICUgZGVsdGEgPT09IDApIHtcbiAgICAgICAgYWxwaGEgLT0gYWxwaGEgLyBhbHBoYWRlYztcbiAgICAgICAgcmFkaXVzIC09IHJhZGl1cyAvIHJhZGl1c2RlYztcbiAgICAgICAgcmFkID0gcmFkaXVzID4+IHJhZGl1c2JpYXNzaGlmdDtcblxuICAgICAgICBpZiAocmFkIDw9IDEpIHtcbiAgICAgICAgICByYWQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJhZDsgaisrKSB7XG4gICAgICAgICAgcmFkcG93ZXJbal0gPSBhbHBoYSAqICgocmFkICogcmFkIC0gaiAqIGopICogcmFkYmlhcyAvIChyYWQgKiByYWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlYXJjaCBmb3IgQkdSIHZhbHVlcyAwLi4yNTUgKGFmdGVyIG5ldCBpcyB1bmJpYXNlZCkgYW5kIHJldHVybiBjb2xvdXIgaW5kZXhcbiAgZnVuY3Rpb24gbWFwKGIsIGcsIHIpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgajtcbiAgICB2YXIgZGlzdDtcbiAgICB2YXIgYTtcbiAgICB2YXIgYmVzdGQ7XG4gICAgdmFyIHA7XG4gICAgdmFyIGJlc3Q7XG5cbiAgICAvLyBCaWdnZXN0IHBvc3NpYmxlIGRpc3RhbmNlIGlzIDI1NiAqIDNcbiAgICBiZXN0ZCA9IDEwMDA7XG4gICAgYmVzdCA9IC0xO1xuICAgIGkgPSBuZXRpbmRleFtnXTsgLy8gaW5kZXggb24gZ1xuICAgIGogPSBpIC0gMTsgLy8gc3RhcnQgYXQgbmV0aW5kZXhbZ10gYW5kIHdvcmsgb3V0d2FyZHNcblxuICAgIHdoaWxlIChpIDwgbmV0c2l6ZSB8fCBqID49IDApIHtcblxuICAgICAgaWYgKGkgPCBuZXRzaXplKSB7XG5cbiAgICAgICAgcCA9IG5ldHdvcmtbaV07XG5cbiAgICAgICAgZGlzdCA9IHBbMV0gLSBnOyAvLyBpbngga2V5XG5cbiAgICAgICAgaWYgKGRpc3QgPj0gYmVzdGQpIHtcbiAgICAgICAgICBpID0gbmV0c2l6ZTsgLy8gc3RvcCBpdGVyXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpZiAoZGlzdCA8IDApIHtcbiAgICAgICAgICAgIGRpc3QgPSAtZGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gcFswXSAtIGI7XG5cbiAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXN0ICs9IGE7XG5cbiAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XG4gICAgICAgICAgICBhID0gcFsyXSAtIHI7XG5cbiAgICAgICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3QgKz0gYTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xuICAgICAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XG4gICAgICAgICAgICAgIGJlc3QgPSBwWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaiA+PSAwKSB7XG5cbiAgICAgICAgcCA9IG5ldHdvcmtbal07XG5cbiAgICAgICAgZGlzdCA9IGcgLSBwWzFdOyAvLyBpbngga2V5IC0gcmV2ZXJzZSBkaWZcblxuICAgICAgICBpZiAoZGlzdCA+PSBiZXN0ZCkge1xuICAgICAgICAgIGogPSAtMTsgLy8gc3RvcCBpdGVyXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBqLS07XG4gICAgICAgICAgaWYgKGRpc3QgPCAwKSB7XG4gICAgICAgICAgICBkaXN0ID0gLWRpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEgPSBwWzBdIC0gYjtcbiAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdCArPSBhO1xuXG4gICAgICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xuICAgICAgICAgICAgYSA9IHBbMl0gLSByO1xuICAgICAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gYTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcbiAgICAgICAgICAgICAgYmVzdGQgPSBkaXN0O1xuICAgICAgICAgICAgICBiZXN0ID0gcFszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgbGVhcm4oKTtcbiAgICB1bmJpYXNuZXQoKTtcbiAgICBpbnhidWlsZCgpO1xuICAgIHJldHVybiBjb2xvck1hcCgpO1xuICB9XG5cbiAgLy8gVW5iaWFzIG5ldHdvcmsgdG8gZ2l2ZSBieXRlIHZhbHVlcyAwLi4yNTUgYW5kIHJlY29yZCBwb3NpdGlvbiBpXG4gIC8vIHRvIHByZXBhcmUgZm9yIHNvcnRcbiAgZnVuY3Rpb24gdW5iaWFzbmV0KCkge1xuICAgIHZhciBpO1xuICAgIHZhciBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ldHNpemU7IGkrKykge1xuICAgICAgbmV0d29ya1tpXVswXSA+Pj0gbmV0Ymlhc3NoaWZ0O1xuICAgICAgbmV0d29ya1tpXVsxXSA+Pj0gbmV0Ymlhc3NoaWZ0O1xuICAgICAgbmV0d29ya1tpXVsyXSA+Pj0gbmV0Ymlhc3NoaWZ0O1xuICAgICAgbmV0d29ya1tpXVszXSA9IGk7IC8vIHJlY29yZCBjb2xvdXIgbm9cbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIGFkamFjZW50IG5ldXJvbnMgYnkgcHJlY29tcHV0ZWQgYWxwaGEqKDEtKChpLWopXjIvW3JdXjIpKVxuICAvLyBpbiByYWRwb3dlclt8aS1qfF1cbiAgZnVuY3Rpb24gYWx0ZXJuZWlnaChyYWQsIGksIGIsIGcsIHIpIHtcblxuICAgIHZhciBqO1xuICAgIHZhciBrO1xuICAgIHZhciBsbztcbiAgICB2YXIgaGk7XG4gICAgdmFyIGE7XG4gICAgdmFyIG07XG5cbiAgICB2YXIgcDtcblxuICAgIGxvID0gaSAtIHJhZDtcbiAgICBpZiAobG8gPCAtMSkge1xuICAgICAgbG8gPSAtMTtcbiAgICB9XG5cbiAgICBoaSA9IGkgKyByYWQ7XG5cbiAgICBpZiAoaGkgPiBuZXRzaXplKSB7XG4gICAgICBoaSA9IG5ldHNpemU7XG4gICAgfVxuXG4gICAgaiA9IGkgKyAxO1xuICAgIGsgPSBpIC0gMTtcbiAgICBtID0gMTtcblxuICAgIHdoaWxlIChqIDwgaGkgfHwgayA+IGxvKSB7XG5cbiAgICAgIGEgPSByYWRwb3dlclttKytdO1xuXG4gICAgICBpZiAoaiA8IGhpKSB7XG5cbiAgICAgICAgcCA9IG5ldHdvcmtbaisrXTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgcFswXSAtPSBhICogKHBbMF0gLSBiKSAvIGFscGhhcmFkYmlhcyB8IDA7XG4gICAgICAgICAgcFsxXSAtPSBhICogKHBbMV0gLSBnKSAvIGFscGhhcmFkYmlhcyB8IDA7XG4gICAgICAgICAgcFsyXSAtPSBhICogKHBbMl0gLSByKSAvIGFscGhhcmFkYmlhcyB8IDA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmIChrID4gbG8pIHtcblxuICAgICAgICBwID0gbmV0d29ya1trLS1dO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBwWzBdIC09IGEgKiAocFswXSAtIGIpIC8gYWxwaGFyYWRiaWFzIHwgMDtcbiAgICAgICAgICBwWzFdIC09IGEgKiAocFsxXSAtIGcpIC8gYWxwaGFyYWRiaWFzIHwgMDtcbiAgICAgICAgICBwWzJdIC09IGEgKiAocFsyXSAtIHIpIC8gYWxwaGFyYWRiaWFzIHwgMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIG5ldXJvbiBpIHRvd2FyZHMgYmlhc2VkIChiLGcscikgYnkgZmFjdG9yIGFscGhhXG4gIGZ1bmN0aW9uIGFsdGVyc2luZ2xlKGFscGhhLCBpLCBiLCBnLCByKSB7XG5cbiAgICAvLyBhbHRlciBoaXQgbmV1cm9uXG4gICAgdmFyIG4gPSBuZXR3b3JrW2ldO1xuICAgIHZhciBhbHBoYU11bHQgPSBhbHBoYSAvIGluaXRhbHBoYTtcbiAgICBuWzBdIC09IGFscGhhTXVsdCAqIChuWzBdIC0gYikgfCAwO1xuICAgIG5bMV0gLT0gYWxwaGFNdWx0ICogKG5bMV0gLSBnKSB8IDA7XG4gICAgblsyXSAtPSBhbHBoYU11bHQgKiAoblsyXSAtIHIpIHwgMDtcbiAgfVxuXG4gIC8vIFNlYXJjaCBmb3IgYmlhc2VkIEJHUiB2YWx1ZXNcbiAgZnVuY3Rpb24gY29udGVzdChiLCBnLCByKSB7XG5cbiAgICAvLyBmaW5kcyBjbG9zZXN0IG5ldXJvbiAobWluIGRpc3QpIGFuZCB1cGRhdGVzIGZyZXFcbiAgICAvLyBmaW5kcyBiZXN0IG5ldXJvbiAobWluIGRpc3QtYmlhcykgYW5kIHJldHVybnMgcG9zaXRpb25cbiAgICAvLyBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXG4gICAgLy8gYmlhc1tpXSA9IGdhbW1hKigoMS9uZXRzaXplKS1mcmVxW2ldKVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRpc3Q7XG4gICAgdmFyIGE7XG4gICAgdmFyIGJpYXNkaXN0O1xuICAgIHZhciBiZXRhZnJlcTtcbiAgICB2YXIgYmVzdHBvcztcbiAgICB2YXIgYmVzdGJpYXNwb3M7XG4gICAgdmFyIGJlc3RkO1xuICAgIHZhciBiZXN0Ymlhc2Q7XG4gICAgdmFyIG47XG5cbiAgICBiZXN0ZCA9IH4oMSA8PCAzMSk7XG4gICAgYmVzdGJpYXNkID0gYmVzdGQ7XG4gICAgYmVzdHBvcyA9IC0xO1xuICAgIGJlc3RiaWFzcG9zID0gYmVzdHBvcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcblxuICAgICAgbiA9IG5ldHdvcmtbaV07XG4gICAgICBkaXN0ID0gblswXSAtIGI7XG5cbiAgICAgIGlmIChkaXN0IDwgMCkge1xuICAgICAgICBkaXN0ID0gLWRpc3Q7XG4gICAgICB9XG5cbiAgICAgIGEgPSBuWzFdIC0gZztcblxuICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgIGEgPSAtYTtcbiAgICAgIH1cblxuICAgICAgZGlzdCArPSBhO1xuXG4gICAgICBhID0gblsyXSAtIHI7XG5cbiAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICBhID0gLWE7XG4gICAgICB9XG5cbiAgICAgIGRpc3QgKz0gYTtcblxuICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xuICAgICAgICBiZXN0ZCA9IGRpc3Q7XG4gICAgICAgIGJlc3Rwb3MgPSBpO1xuICAgICAgfVxuXG4gICAgICBiaWFzZGlzdCA9IGRpc3QgLSAoYmlhc1tpXSA+PiBpbnRiaWFzc2hpZnQgLSBuZXRiaWFzc2hpZnQpO1xuXG4gICAgICBpZiAoYmlhc2Rpc3QgPCBiZXN0Ymlhc2QpIHtcbiAgICAgICAgYmVzdGJpYXNkID0gYmlhc2Rpc3Q7XG4gICAgICAgIGJlc3RiaWFzcG9zID0gaTtcbiAgICAgIH1cblxuICAgICAgYmV0YWZyZXEgPSBmcmVxW2ldID4+IGJldGFzaGlmdDtcbiAgICAgIGZyZXFbaV0gLT0gYmV0YWZyZXE7XG4gICAgICBiaWFzW2ldICs9IGJldGFmcmVxIDw8IGdhbW1hc2hpZnQ7XG4gICAgfVxuXG4gICAgZnJlcVtiZXN0cG9zXSArPSBiZXRhO1xuICAgIGJpYXNbYmVzdHBvc10gLT0gYmV0YWdhbW1hO1xuICAgIHJldHVybiBiZXN0Ymlhc3BvcztcbiAgfVxuXG4gIE5ldVF1YW50Q29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB2YXIgZXhwb3J0cyA9IHt9O1xuICBleHBvcnRzLm1hcCA9IG1hcDtcbiAgZXhwb3J0cy5wcm9jZXNzID0gcHJvY2VzcztcblxuICByZXR1cm4gZXhwb3J0cztcbn1cblxuLypcbiAgcHJvY2Vzc0ZyYW1lV29ya2VyLmpzXG4gID09PT09PT09PT09PT09PT09PT09PVxuKi9cblxuLyogQ29weXJpZ2h0ICAyMDE3IFlhaG9vIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuZnVuY3Rpb24gd29ya2VyQ29kZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBldi5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5naWZzaG90KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB3b3JrZXJNZXRob2RzLnJ1bihkYXRhKTtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHZhciB3b3JrZXJNZXRob2RzID0ge1xuICAgICAgICBkYXRhVG9SR0I6IGZ1bmN0aW9uIGRhdGFUb1JHQihkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiA0O1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIHJnYiA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJnYi5wdXNoKGRhdGFbaSsrXSk7XG4gICAgICAgICAgICAgICAgcmdiLnB1c2goZGF0YVtpKytdKTtcbiAgICAgICAgICAgICAgICByZ2IucHVzaChkYXRhW2krK10pO1xuICAgICAgICAgICAgICAgIGkrKzsgLy8gZm9yIHRoZSBhbHBoYSBjaGFubmVsIHdoaWNoIHdlIGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJnYjtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9uZW50aXplZFBhbGV0dGVUb0FycmF5OiBmdW5jdGlvbiBjb21wb25lbnRpemVkUGFsZXR0ZVRvQXJyYXkocGFsZXR0ZVJHQikge1xuICAgICAgICAgICAgcGFsZXR0ZVJHQiA9IHBhbGV0dGVSR0IgfHwgW107XG5cbiAgICAgICAgICAgIHZhciBwYWxldHRlQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWxldHRlUkdCLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBwYWxldHRlUkdCW2ldO1xuICAgICAgICAgICAgICAgIHZhciBnID0gcGFsZXR0ZVJHQltpICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBwYWxldHRlUkdCW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgIHBhbGV0dGVBcnJheS5wdXNoKHIgPDwgMTYgfCBnIDw8IDggfCBiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhbGV0dGVBcnJheTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJ0cmFkaXRpb25hbFwiIEFuaW1hdGVkX0dJRiBzdHlsZSBvZiBnb2luZyBmcm9tIFJHQkEgdG8gaW5kZXhlZCBjb2xvciBmcmFtZXNcbiAgICAgICAgJ3Byb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXInOiBmdW5jdGlvbiBwcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCwgc2FtcGxlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHZhciByZ2JDb21wb25lbnRzID0gdGhpcy5kYXRhVG9SR0IoaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBucSA9IG5ldyBOZXVRdWFudChyZ2JDb21wb25lbnRzLCByZ2JDb21wb25lbnRzLmxlbmd0aCwgc2FtcGxlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdmFyIHBhbGV0dGVSR0IgPSBucS5wcm9jZXNzKCk7XG4gICAgICAgICAgICB2YXIgcGFsZXR0ZUFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuY29tcG9uZW50aXplZFBhbGV0dGVUb0FycmF5KHBhbGV0dGVSR0IpKTtcbiAgICAgICAgICAgIHZhciBudW1iZXJQaXhlbHMgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIHZhciBpbmRleGVkUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkobnVtYmVyUGl4ZWxzKTtcbiAgICAgICAgICAgIHZhciBrID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJQaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmdiQ29tcG9uZW50c1trKytdO1xuICAgICAgICAgICAgICAgIHZhciBnID0gcmdiQ29tcG9uZW50c1trKytdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gcmdiQ29tcG9uZW50c1trKytdO1xuXG4gICAgICAgICAgICAgICAgaW5kZXhlZFBpeGVsc1tpXSA9IG5xLm1hcChyLCBnLCBiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwaXhlbHM6IGluZGV4ZWRQaXhlbHMsXG4gICAgICAgICAgICAgICAgcGFsZXR0ZTogcGFsZXR0ZUFycmF5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAncnVuJzogZnVuY3Rpb24gcnVuKGZyYW1lKSB7XG4gICAgICAgICAgICBmcmFtZSA9IGZyYW1lIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgX2ZyYW1lID0gZnJhbWUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX2ZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICBwYWxldHRlID0gX2ZyYW1lLnBhbGV0dGUsXG4gICAgICAgICAgICAgICAgc2FtcGxlSW50ZXJ2YWwgPSBfZnJhbWUuc2FtcGxlSW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgd2lkdGggPSBfZnJhbWUud2lkdGg7XG5cbiAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBmcmFtZS5kYXRhO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCwgc2FtcGxlSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB3b3JrZXJNZXRob2RzO1xufVxuXG4vKlxuICBnaWZXcml0ZXIuanNcbiAgPT09PT09PT09PT09XG4qL1xuXG4vLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuZnVuY3Rpb24gZ2lmV3JpdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgZ29wdHMpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIGdvcHRzID0gZ29wdHMgPT09IHVuZGVmaW5lZCA/IHt9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpIHRocm93IFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCI7XG5cbiAgZnVuY3Rpb24gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKSB7XG4gICAgdmFyIG51bV9jb2xvcnMgPSBwYWxldHRlLmxlbmd0aDtcblxuICAgIGlmIChudW1fY29sb3JzIDwgMiB8fCBudW1fY29sb3JzID4gMjU2IHx8IG51bV9jb2xvcnMgJiBudW1fY29sb3JzIC0gMSkgdGhyb3cgXCJJbnZhbGlkIGNvZGUvY29sb3IgbGVuZ3RoLCBtdXN0IGJlIHBvd2VyIG9mIDIgYW5kIDIgLi4gMjU2LlwiO1xuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NztcbiAgYnVmW3ArK10gPSAweDQ5O1xuICBidWZbcCsrXSA9IDB4NDY7IC8vIEdJRlxuICBidWZbcCsrXSA9IDB4Mzg7XG4gIGJ1ZltwKytdID0gMHgzOTtcbiAgYnVmW3ArK10gPSAweDYxOyAvLyA4OWFcblxuICAvLyBIYW5kbGluZyBvZiBHbG9iYWwgQ29sb3IgVGFibGUgKHBhbGV0dGUpIGFuZCBiYWNrZ3JvdW5kIGluZGV4LlxuICB2YXIgZ3BfbnVtX2NvbG9yc19wb3cyID0gMDtcbiAgdmFyIGJhY2tncm91bmQgPSAwO1xuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgLy8gTk9URShkZWFubSk6IHcvaCBhcHBhcmVudGx5IGlnbm9yZWQgYnkgaW1wbGVtZW50YXRpb25zLCBidXQgc2V0IGFueXdheS5cbiAgYnVmW3ArK10gPSB3aWR0aCAmIDB4ZmY7XG4gIGJ1ZltwKytdID0gd2lkdGggPj4gOCAmIDB4ZmY7XG4gIGJ1ZltwKytdID0gaGVpZ2h0ICYgMHhmZjtcbiAgYnVmW3ArK10gPSBoZWlnaHQgPj4gOCAmIDB4ZmY7XG4gIC8vIE5PVEU6IEluZGljYXRlcyAwLWJwcCBvcmlnaW5hbCBjb2xvciByZXNvbHV0aW9uICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwgPyAweDgwIDogMCkgfCAvLyBHbG9iYWwgQ29sb3IgVGFibGUgRmxhZy5cbiAgZ3BfbnVtX2NvbG9yc19wb3cyOyAvLyBOT1RFOiBObyBzb3J0IGZsYWcgKHVudXNlZD8pLlxuICBidWZbcCsrXSA9IGJhY2tncm91bmQ7IC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICBpZiAobG9vcF9jb3VudCAhPT0gbnVsbCkge1xuICAgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpIHRocm93IFwiTG9vcCBjb3VudCBpbnZhbGlkLlwiO1xuXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTtcbiAgICBidWZbcCsrXSA9IDB4ZmY7XG4gICAgYnVmW3ArK10gPSAweDBiO1xuICAgIC8vIE5FVFNDQVBFMi4wXG4gICAgYnVmW3ArK10gPSAweDRlO1xuICAgIGJ1ZltwKytdID0gMHg0NTtcbiAgICBidWZbcCsrXSA9IDB4NTQ7XG4gICAgYnVmW3ArK10gPSAweDUzO1xuICAgIGJ1ZltwKytdID0gMHg0MztcbiAgICBidWZbcCsrXSA9IDB4NDE7XG4gICAgYnVmW3ArK10gPSAweDUwO1xuICAgIGJ1ZltwKytdID0gMHg0NTtcbiAgICBidWZbcCsrXSA9IDB4MzI7XG4gICAgYnVmW3ArK10gPSAweDJlO1xuICAgIGJ1ZltwKytdID0gMHgzMDtcbiAgICAvLyBTdWItYmxvY2tcbiAgICBidWZbcCsrXSA9IDB4MDM7XG4gICAgYnVmW3ArK10gPSAweDAxO1xuICAgIGJ1ZltwKytdID0gbG9vcF9jb3VudCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgLy8gVGVybWluYXRvci5cbiAgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCwgaW5kZXhlZF9waXhlbHMsIG9wdHMpIHtcbiAgICBpZiAoZW5kZWQgPT09IHRydWUpIHtcbiAgICAgIC0tcDtcbiAgICAgIGVuZGVkID0gZmFsc2U7XG4gICAgfSAvLyBVbi1lbmQuXG5cbiAgICBvcHRzID0gb3B0cyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSkgdGhyb3cgXCJ4L3kgaW52YWxpZC5cIjtcblxuICAgIGlmICh3IDw9IDAgfHwgaCA8PSAwIHx8IHcgPiA2NTUzNSB8fCBoID4gNjU1MzUpIHRocm93IFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCI7XG5cbiAgICBpZiAoaW5kZXhlZF9waXhlbHMubGVuZ3RoIDwgdyAqIGgpIHRocm93IFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiO1xuXG4gICAgdmFyIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgIHZhciBwYWxldHRlID0gb3B0cy5wYWxldHRlO1xuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbCkge1xuICAgICAgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgcGFsZXR0ZSA9IGdsb2JhbF9wYWxldHRlO1xuICAgIH1cblxuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbCkgdGhyb3cgXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIjtcblxuICAgIHZhciBudW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1pbl9jb2RlX3NpemUgKHBvd2VyIG9mIDIpLCBkZXN0cm95aW5nIG51bV9jb2xvcnMuXG4gICAgdmFyIG1pbl9jb2RlX3NpemUgPSAwO1xuICAgIHdoaWxlIChudW1fY29sb3JzID4+PSAxKSB7XG4gICAgICArK21pbl9jb2RlX3NpemU7XG4gICAgfW51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7IC8vIE5vdyB3ZSBjYW4gZWFzaWx5IGdldCBpdCBiYWNrLlxuXG4gICAgdmFyIGRlbGF5ID0gb3B0cy5kZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGVsYXk7XG5cbiAgICAvLyBGcm9tIHRoZSBzcGVjOlxuICAgIC8vICAgICAwIC0gICBObyBkaXNwb3NhbCBzcGVjaWZpZWQuIFRoZSBkZWNvZGVyIGlzXG4gICAgLy8gICAgICAgICAgIG5vdCByZXF1aXJlZCB0byB0YWtlIGFueSBhY3Rpb24uXG4gICAgLy8gICAgIDEgLSAgIERvIG5vdCBkaXNwb3NlLiBUaGUgZ3JhcGhpYyBpcyB0byBiZSBsZWZ0XG4gICAgLy8gICAgICAgICAgIGluIHBsYWNlLlxuICAgIC8vICAgICAyIC0gICBSZXN0b3JlIHRvIGJhY2tncm91bmQgY29sb3IuIFRoZSBhcmVhIHVzZWQgYnkgdGhlXG4gICAgLy8gICAgICAgICAgIGdyYXBoaWMgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgMyAtICAgUmVzdG9yZSB0byBwcmV2aW91cy4gVGhlIGRlY29kZXIgaXMgcmVxdWlyZWQgdG9cbiAgICAvLyAgICAgICAgICAgcmVzdG9yZSB0aGUgYXJlYSBvdmVyd3JpdHRlbiBieSB0aGUgZ3JhcGhpYyB3aXRoXG4gICAgLy8gICAgICAgICAgIHdoYXQgd2FzIHRoZXJlIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgZ3JhcGhpYy5cbiAgICAvLyAgNC03IC0gICAgVG8gYmUgZGVmaW5lZC5cbiAgICAvLyBOT1RFKGRlYW5tKTogRGlzcG9zZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgcmVhbGx5IHdvcmssIGFwcGFyZW50bHkgbW9zdFxuICAgIC8vIGJyb3dzZXJzIGlnbm9yZSB0aGUgYmFja2dyb3VuZCBwYWxldHRlIGluZGV4IGFuZCBjbGVhciB0byB0cmFuc3BhcmVuY3kuXG4gICAgdmFyIGRpc3Bvc2FsID0gb3B0cy5kaXNwb3NhbCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGlzcG9zYWw7XG4gICAgaWYgKGRpc3Bvc2FsIDwgMCB8fCBkaXNwb3NhbCA+IDMpIC8vIDQtNyBpcyByZXNlcnZlZC5cbiAgICAgIHRocm93IFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiO1xuXG4gICAgdmFyIHVzZV90cmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSAwO1xuICAgIGlmIChvcHRzLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgb3B0cy50cmFuc3BhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdXNlX3RyYW5zcGFyZW5jeSA9IHRydWU7XG4gICAgICB0cmFuc3BhcmVudF9pbmRleCA9IG9wdHMudHJhbnNwYXJlbnQ7XG4gICAgICBpZiAodHJhbnNwYXJlbnRfaW5kZXggPCAwIHx8IHRyYW5zcGFyZW50X2luZGV4ID49IG51bV9jb2xvcnMpIHRocm93IFwiVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXCI7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTtcbiAgICAgIGJ1ZltwKytdID0gMHhmOTsgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7IC8vIEJ5dGUgc2l6ZS5cblxuICAgICAgYnVmW3ArK10gPSBkaXNwb3NhbCA8PCAyIHwgKHVzZV90cmFuc3BhcmVuY3kgPT09IHRydWUgPyAxIDogMCk7XG4gICAgICBidWZbcCsrXSA9IGRlbGF5ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAvLyBUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cbiAgICAgIGJ1ZltwKytdID0gMDsgLy8gQmxvY2sgVGVybWluYXRvci5cbiAgICB9XG5cbiAgICAvLyAtIEltYWdlIERlc2NyaXB0b3JcbiAgICBidWZbcCsrXSA9IDB4MmM7IC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmO1xuICAgIGJ1ZltwKytdID0geCA+PiA4ICYgMHhmZjsgLy8gTGVmdC5cbiAgICBidWZbcCsrXSA9IHkgJiAweGZmO1xuICAgIGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgLy8gVG9wLlxuICAgIGJ1ZltwKytdID0gdyAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSB3ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gaCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/IDB4ODAgfCBtaW5fY29kZV9zaXplIC0gMSA6IDA7XG5cbiAgICAvLyAtIExvY2FsIENvbG9yIFRhYmxlXG4gICAgaWYgKHVzaW5nX2xvY2FsX3BhbGV0dGUgPT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcmdiID0gcGFsZXR0ZVtpXTtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgJiAweGZmO1xuICAgICAgfVxuICAgIH1cblxuICAgIHAgPSBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSA8IDIgPyAyIDogbWluX2NvZGVfc2l6ZSwgaW5kZXhlZF9waXhlbHMpO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGJ1ZltwKytdID0gMHgzYjsgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgLy8gTWFpbiBjb21wcmVzc2lvbiByb3V0aW5lLCBwYWxldHRlIGluZGV4ZXMgLT4gTFpXIGNvZGUgc3RyZWFtLlxuICAvLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuICBmdW5jdGlvbiBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSwgaW5kZXhfc3RyZWFtKSB7XG4gICAgYnVmW3ArK10gPSBtaW5fY29kZV9zaXplO1xuICAgIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7IC8vIFBvaW50aW5nIGF0IHRoZSBsZW5ndGggZmllbGQuXG5cbiAgICB2YXIgY2xlYXJfY29kZSA9IDEgPDwgbWluX2NvZGVfc2l6ZTtcbiAgICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gICAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gICAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICAgIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7IC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICAgIHZhciBjdXJfc2hpZnQgPSAwO1xuICAgIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgICAvLyBiaXRzIGhlcmUgKGFuZCB0aGVuIHdlIHdvdWxkIHdyaXRlIG91dCkuXG4gICAgdmFyIGN1ciA9IDA7XG5cbiAgICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSBiaXRfYmxvY2tfc2l6ZSkge1xuICAgICAgICBidWZbcCsrXSA9IGN1ciAmIDB4ZmY7XG4gICAgICAgIGN1ciA+Pj0gODtcbiAgICAgICAgY3VyX3NoaWZ0IC09IDg7XG4gICAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHtcbiAgICAgICAgICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgICBjdXIgfD0gYyA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICAgIH1cblxuICAgIC8vIEkgYW0gbm90IGFuIGV4cGVydCBvbiB0aGUgdG9waWMsIGFuZCBJIGRvbid0IHdhbnQgdG8gd3JpdGUgYSB0aGVzaXMuXG4gICAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gICAgLy8gc3RydWN0dXJlcyBhbmQgb3B0aW1pemF0aW9ucyBoZXJlIHRoYXQgbWFrZSB0aGlzIGltcGxlbWVudGF0aW9uIGZhc3QuXG4gICAgLy8gVGhlIGJhc2ljIGlkZWEgYmVoaW5kIExaVyBpcyB0byBidWlsZCBhIHRhYmxlIG9mIHByZXZpb3VzbHkgc2VlbiBydW5zXG4gICAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGEgY29kZSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb3IgbW9yZSB2YWx1ZXMgZnJvbSB0aGVcbiAgICAvLyBvcmlnaW5hbCBpbnB1dCBzdHJlYW0uICBBbGwgaW5wdXQgYnl0ZXMgY2FuIGJlIHJlZmVyZW5jZWQgYXMgdGhlIHNhbWVcbiAgICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAgIC8vIGNvdWxkIG1vcmUgb3IgbGVzcyBqdXN0IG91dHB1dCB0aGUgb3JpZ2luYWwgYnl0ZXMgYXMgY29kZXMgKHRoZXJlIGFyZVxuICAgIC8vIHNvbWUgZGV0YWlscyB0byB0aGlzLCBidXQgaXQgaXMgdGhlIGlkZWEpLiAgSW4gb3JkZXIgdG8gYWNoaWV2ZVxuICAgIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gICAgLy8gMTItYml0IHdoaWxlIGlucHV0IG9ubHkgOC1iaXQpIHJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIHByZXZpb3VzbHkgc2VlblxuICAgIC8vIGlucHV0cy4gIFRoZSBkZWNvbXByZXNzb3IgaXMgYWJsZSB0byBidWlsZCB0aGUgc2FtZSBtYXBwaW5nIHdoaWxlXG4gICAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gICAgLy8gZW5jb2RpbmcgYW5kIGRlY29kZXIsIHdoaWNoIGlzIGFsc28gaW1wb3J0YW50IGZvciBcInRpbWluZ1wiIGFzcGVjdHMgbGlrZVxuICAgIC8vIGhvdyB0byBoYW5kbGUgdmFyaWFibGUgYml0IHdpZHRoIGNvZGUgZW5jb2RpbmcuXG4gICAgLy9cbiAgICAvLyBPbmUgb2J2aW91cyBidXQgdmVyeSBpbXBvcnRhbnQgY29uc2VxdWVuY2Ugb2YgdGhlIHRhYmxlIHN5c3RlbSBpcyB0aGVyZVxuICAgIC8vIGlzIGFsd2F5cyBhIHVuaXF1ZSBpZCAoYXQgbW9zdCAxMi1iaXRzKSB0byBtYXAgdGhlIHJ1bnMuICAnQScgbWlnaHQgYmVcbiAgICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gICAgLy8gY2FuIGJlIHVzZWQgZm9yIGFuIGVmZmVjaWVudCBsb29rdXAgc3RyYXRlZ3kgZm9yIHRoZSBjb2RlIG1hcHBpbmcuICBXZVxuICAgIC8vIG5lZWQgdG8ga25vdyBpZiBhIHJ1biBoYXMgYmVlbiBzZWVuIGJlZm9yZSwgYW5kIGJlIGFibGUgdG8gbWFwIHRoYXQgcnVuXG4gICAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gICAgLy8gYW5kIHRoZW4gZnJvbSB0aG9zZSBidWlsZCBtb3JlIHVuaXF1ZSBpZHMgKHRhYmxlIGVudHJpZXMpLCB3ZSBjYW5cbiAgICAvLyBjb250aW51ZSB0aGlzIGNoYWluIChhbG1vc3QgbGlrZSBhIGxpbmtlZCBsaXN0KSB0byBhbHdheXMgaGF2ZSBzbWFsbFxuICAgIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAgIC8vIFRoaXMgbWVhbnMgaW5zdGVhZCBvZiB0cmFja2luZyB0aGUgaW5wdXQgYnl0ZXMgKEFBQUFCQ0QpIHRvIGtub3cgb3VyXG4gICAgLy8gY3VycmVudCBzdGF0ZSwgd2UgY2FuIHRyYWNrIHRoZSB0YWJsZSBlbnRyeSBmb3IgQUFBQUJDIChpdCBpcyBndWFyYW50ZWVkXG4gICAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gICAgLy8gVGhlcmVmb3IgdGhlIHR1cGxlIG9mICh0YWJsZV9lbnRyeSwgYnl0ZSkgaXMgZ3VhcmFudGVlZCB0byBhbHNvIGJlXG4gICAgLy8gdW5pcXVlLiAgVGhpcyBhbGxvd3MgdXMgdG8gY3JlYXRlIGEgc2ltcGxlIGxvb2t1cCBrZXkgZm9yIG1hcHBpbmcgaW5wdXRcbiAgICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAgIC8vIGFueSBvZiB0aGUgY29kZSBzZXF1ZW5jZXMuICBTbyBpZiAnQUFBQScgaGFzIGEgdGFibGUgZW50cnkgb2YgMTIsIHRoZVxuICAgIC8vIHR1cGxlIG9mICgnQUFBQScsIEspIGZvciBhbnkgaW5wdXQgYnl0ZSBLIHdpbGwgYmUgdW5pcXVlLCBhbmQgY2FuIGJlIG91clxuICAgIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAgIC8vIGZpdCBpbiBhbiBTTUkgdmFsdWUgYW5kIGJlIHVzZWQgYXMgYSBmYXN0IHNwYXJzZSBhcnJheSAvIG9iamVjdCBrZXkuXG5cbiAgICAvLyBPdXRwdXQgY29kZSBmb3IgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGluZGV4IGJ1ZmZlci5cbiAgICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgLy8gTG9hZCBmaXJzdCBpbnB1dCBpbmRleC5cbiAgICB2YXIgY29kZV90YWJsZSA9IHt9OyAvLyBLZXknZCBvbiBvdXIgMjAtYml0IFwidHVwbGVcIi5cblxuICAgIGVtaXRfY29kZShjbGVhcl9jb2RlKTsgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAgIC8vIEZpcnN0IGluZGV4IGFscmVhZHkgbG9hZGVkLCBwcm9jZXNzIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0uXG4gICAgZm9yICh2YXIgaSA9IDEsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgICAgdmFyIGN1cl9rZXkgPSBpYl9jb2RlIDw8IDggfCBrOyAvLyAocHJldiwgaykgdW5pcXVlIHR1cGxlLlxuICAgICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgLy8gYnVmZmVyICsgay5cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgY29kZSB0YWJsZSBlbnRyeS5cbiAgICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYnVmZmVyICsgay5cbiAgICAgICAgLy8gRW1pdCBpbmRleCBidWZmZXIgKHdpdGhvdXQgaykuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgICAgLy8gd3JpdGluZyByb3V0aW5lIG9mIHRoZSBjb21wcmVzc29yIChhbmQgVjggY2Fubm90IGlubGluZSBlbWl0X2NvZGVcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBhIGNsb3N1cmUgaGVyZSBpbiBhIGRpZmZlcmVudCBjb250ZXh0KS4gIEFkZGl0aW9uYWxseVxuICAgICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgICAgLy8gMzAtYml0cyAoZnJvbSBvdXIgMzEtYml0IHNpZ25lZCBTTUkpLCBhbmQgd2Uga25vdyBvdXIgY29kZXMgd2lsbCBvbmx5XG4gICAgICAgIC8vIGJlIDEyLWJpdHMsIHNvIGNhbiBzYWZlbHkgaGF2ZSAxOC1iaXRzIHRoZXJlIHdpdGhvdXQgb3ZlcmZsb3cuXG4gICAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgICAgY3VyIHw9IGliX2NvZGUgPDwgY3VyX3NoaWZ0O1xuICAgICAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgICAgIGN1ciA+Pj0gODtcbiAgICAgICAgICBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7XG4gICAgICAgICAgICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAyNTU7XG4gICAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5Nikge1xuICAgICAgICAgIC8vIFRhYmxlIGZ1bGwsIG5lZWQgYSBjbGVhci5cbiAgICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgICAgIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTtcbiAgICAgICAgICBjb2RlX3RhYmxlID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGFibGUgbm90IGZ1bGwsIGluc2VydCBhIG5ldyBlbnRyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBvdXIgdmFyaWFibGUgYml0IGNvZGUgc2l6ZXMgaWYgbmVjZXNzYXJ5LiAgVGhpcyBpcyBhIGJpdFxuICAgICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAgIC8vIGRlY29kZXIuICBGcm9tIHRoZSBlbmNvZGVycyBwZXJzcGVjdGl2ZSB0aGlzIHNob3VsZCBoYXBwZW4gYWZ0ZXJcbiAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGVtaXR0ZWQgdGhlIGluZGV4IGJ1ZmZlciBhbmQgYXJlIGFib3V0IHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgICAgaWYgKG5leHRfY29kZSA+PSAxIDw8IGN1cl9jb2RlX3NpemUpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgICBjb2RlX3RhYmxlW2N1cl9rZXldID0gbmV4dF9jb2RlKys7IC8vIEluc2VydCBpbnRvIGNvZGUgdGFibGUuXG4gICAgICAgIH1cblxuICAgICAgICBpYl9jb2RlID0gazsgLy8gSW5kZXggYnVmZmVyIHRvIHNpbmdsZSBpbnB1dCBrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWJfY29kZSA9IGN1cl9jb2RlOyAvLyBJbmRleCBidWZmZXIgdG8gc2VxdWVuY2UgaW4gY29kZSB0YWJsZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbWl0X2NvZGUoaWJfY29kZSk7IC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gICAgZW1pdF9jb2RlKGVvaV9jb2RlKTsgLy8gRW5kIE9mIEluZm9ybWF0aW9uLlxuXG4gICAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgICBlbWl0X2J5dGVzX3RvX2J1ZmZlcigxKTtcblxuICAgIC8vIEZpbmlzaCB0aGUgc3ViLWJsb2Nrcywgd3JpdGluZyBvdXQgYW55IHVuZmluaXNoZWQgbGVuZ3RocyBhbmRcbiAgICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAvLyBidXQgbm90IHlldCB1c2VkIGEgc3ViLWJsb2NrIGl0IGNhbiBqdXN0IGJlY29tZSB0aGUgdGVybWluYXRvci5cbiAgICBpZiAoY3VyX3N1YmJsb2NrICsgMSA9PT0gcCkge1xuICAgICAgLy8gU3RhcnRlZCBidXQgdW51c2VkLlxuICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGFydGVkIGFuZCB1c2VkLCB3cml0ZSBsZW5ndGggYW5kIGFkZGl0aW9uYWwgdGVybWluYXRvciBibG9jay5cbiAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gcCAtIGN1cl9zdWJibG9jayAtIDE7XG4gICAgICBidWZbcCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG59XG5cbi8qXG4gIGFuaW1hdGVkR0lGLmpzXG4gID09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4vLyBEZXBlbmRlbmNpZXNcbi8vIEhlbHBlcnNcbnZhciBub29wJDIgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBBbmltYXRlZEdJRiA9IGZ1bmN0aW9uIEFuaW1hdGVkR0lGKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5jdHggPSBudWxsO1xuICAgIHRoaXMucmVwZWF0ID0gMDtcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICAgIHRoaXMubnVtUmVuZGVyZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMub25SZW5kZXJDb21wbGV0ZUNhbGxiYWNrID0gbm9vcCQyO1xuICAgIHRoaXMub25SZW5kZXJQcm9ncmVzc0NhbGxiYWNrID0gbm9vcCQyO1xuICAgIHRoaXMud29ya2VycyA9IFtdO1xuICAgIHRoaXMuYXZhaWxhYmxlV29ya2VycyA9IFtdO1xuICAgIHRoaXMuZ2VuZXJhdGluZ0dJRiA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvLyBDb25zdHJ1Y3RzIGFuZCBpbml0aWFsaXplcyB0aGUgdGhlIHdlYiB3b3JrZXJzIGFwcHJvcHJpYXRlbHlcbiAgICB0aGlzLmluaXRpYWxpemVXZWJXb3JrZXJzKG9wdGlvbnMpO1xufTtcblxuQW5pbWF0ZWRHSUYucHJvdG90eXBlID0ge1xuICAgICd3b3JrZXJNZXRob2RzJzogd29ya2VyQ29kZSgpLFxuICAgICdpbml0aWFsaXplV2ViV29ya2Vycyc6IGZ1bmN0aW9uIGluaXRpYWxpemVXZWJXb3JrZXJzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvY2Vzc0ZyYW1lV29ya2VyQ29kZSA9IE5ldVF1YW50LnRvU3RyaW5nKCkgKyAnKCcgKyB3b3JrZXJDb2RlLnRvU3RyaW5nKCkgKyAnKCkpOyc7XG4gICAgICAgIHZhciB3ZWJXb3JrZXJPYmogPSB2b2lkIDA7XG4gICAgICAgIHZhciBvYmplY3RVcmwgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3ZWJXb3JrZXIgPSB2b2lkIDA7XG4gICAgICAgIHZhciBudW1Xb3JrZXJzID0gdm9pZCAwO1xuICAgICAgICB2YXIgeCA9IC0xO1xuICAgICAgICB2YXIgd29ya2VyRXJyb3IgPSAnJztcblxuICAgICAgICBudW1Xb3JrZXJzID0gb3B0aW9ucy5udW1Xb3JrZXJzO1xuXG4gICAgICAgIHdoaWxlICgrK3ggPCBudW1Xb3JrZXJzKSB7XG4gICAgICAgICAgICB3ZWJXb3JrZXJPYmogPSB1dGlscy5jcmVhdGVXZWJXb3JrZXIocHJvY2Vzc0ZyYW1lV29ya2VyQ29kZSk7XG5cbiAgICAgICAgICAgIGlmICh1dGlscy5pc09iamVjdCh3ZWJXb3JrZXJPYmopKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsID0gd2ViV29ya2VyT2JqLm9iamVjdFVybDtcbiAgICAgICAgICAgICAgICB3ZWJXb3JrZXIgPSB3ZWJXb3JrZXJPYmoud29ya2VyO1xuXG4gICAgICAgICAgICAgICAgc2VsZi53b3JrZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXI6IHdlYldvcmtlcixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0VXJsOiBvYmplY3RVcmxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNlbGYuYXZhaWxhYmxlV29ya2Vycy5wdXNoKHdlYldvcmtlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtlckVycm9yID0gd2ViV29ya2VyT2JqO1xuICAgICAgICAgICAgICAgIHV0aWxzLndlYldvcmtlckVycm9yID0gISF3ZWJXb3JrZXJPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndvcmtlckVycm9yID0gd29ya2VyRXJyb3I7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gb3B0aW9ucy5naWZXaWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5naWZIZWlnaHQ7XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgICB9LFxuICAgIC8vIFJldHVybiBhIHdvcmtlciBmb3IgcHJvY2Vzc2luZyBhIGZyYW1lXG4gICAgZ2V0V29ya2VyOiBmdW5jdGlvbiBnZXRXb3JrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVdvcmtlcnMucG9wKCk7XG4gICAgfSxcbiAgICAvLyBSZXN0b3JlcyBhIHdvcmtlciB0byB0aGUgcG9vbFxuICAgIGZyZWVXb3JrZXI6IGZ1bmN0aW9uIGZyZWVXb3JrZXIod29ya2VyKSB7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlV29ya2Vycy5wdXNoKHdvcmtlcik7XG4gICAgfSxcbiAgICBieXRlTWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBieXRlTWFwID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgYnl0ZU1hcFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnl0ZU1hcDtcbiAgICB9KCksXG4gICAgYnVmZmVyVG9TdHJpbmc6IGZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICAgICAgICB2YXIgbnVtYmVyVmFsdWVzID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICB2YXIgeCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK3ggPCBudW1iZXJWYWx1ZXMpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLmJ5dGVNYXBbYnVmZmVyW3hdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcbiAgICBvbkZyYW1lRmluaXNoZWQ6IGZ1bmN0aW9uIG9uRnJhbWVGaW5pc2hlZChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZSBHSUYgaXMgbm90IHdyaXR0ZW4gdW50aWwgd2UncmUgZG9uZSB3aXRoIGFsbCB0aGUgZnJhbWVzXG4gICAgICAgIC8vIGJlY2F1c2UgdGhleSBtaWdodCBub3QgYmUgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIG9yZGVyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGZyYW1lcyA9IHNlbGYuZnJhbWVzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgdmFyIGhhc0V4aXN0aW5nSW1hZ2VzID0gISEob3B0aW9ucy5pbWFnZXMgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgdmFyIGFsbERvbmUgPSBmcmFtZXMuZXZlcnkoZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gIWZyYW1lLmJlaW5nUHJvY2Vzc2VkICYmIGZyYW1lLmRvbmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYubnVtUmVuZGVyZWRGcmFtZXMrKztcblxuICAgICAgICBpZiAoaGFzRXhpc3RpbmdJbWFnZXMpIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soc2VsZi5udW1SZW5kZXJlZEZyYW1lcyAvIGZyYW1lcy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5vblJlbmRlclByb2dyZXNzQ2FsbGJhY2soc2VsZi5udW1SZW5kZXJlZEZyYW1lcyAqIDAuNzUgLyBmcmFtZXMubGVuZ3RoKTtcblxuICAgICAgICBpZiAoYWxsRG9uZSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmdlbmVyYXRpbmdHSUYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyYXRlR0lGKGZyYW1lcywgc2VsZi5vblJlbmRlckNvbXBsZXRlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbHMucmVxdWVzdFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJvY2Vzc05leHRGcmFtZSgpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByb2Nlc3NGcmFtZTogZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBBbmltYXRlZEdpZkNvbnRleHQgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIF9vcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IF9vcHRpb25zLnByb2dyZXNzQ2FsbGJhY2ssXG4gICAgICAgICAgICBzYW1wbGVJbnRlcnZhbCA9IF9vcHRpb25zLnNhbXBsZUludGVydmFsO1xuXG4gICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcbiAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgd29ya2VyID0gdm9pZCAwO1xuICAgICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2LmRhdGE7XG5cbiAgICAgICAgICAgIC8vIERlbGV0ZSBvcmlnaW5hbCBkYXRhLCBhbmQgZnJlZSBtZW1vcnlcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZS5kYXRhO1xuXG4gICAgICAgICAgICBmcmFtZS5waXhlbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLnBpeGVscyk7XG4gICAgICAgICAgICBmcmFtZS5wYWxldHRlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YS5wYWxldHRlKTtcbiAgICAgICAgICAgIGZyYW1lLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWUuYmVpbmdQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgQW5pbWF0ZWRHaWZDb250ZXh0LmZyZWVXb3JrZXIod29ya2VyKTtcblxuICAgICAgICAgICAgQW5pbWF0ZWRHaWZDb250ZXh0Lm9uRnJhbWVGaW5pc2hlZChwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmcmFtZSA9IGZyYW1lc1twb3NpdGlvbl07XG5cbiAgICAgICAgaWYgKGZyYW1lLmJlaW5nUHJvY2Vzc2VkIHx8IGZyYW1lLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMub25GcmFtZUZpbmlzaGVkKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lLnNhbXBsZUludGVydmFsID0gc2FtcGxlSW50ZXJ2YWw7XG4gICAgICAgIGZyYW1lLmJlaW5nUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgZnJhbWUuZ2lmc2hvdCA9IHRydWU7XG5cbiAgICAgICAgd29ya2VyID0gdGhpcy5nZXRXb3JrZXIoKTtcblxuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBmcmFtZSBpbiBhIHdlYiB3b3JrZXJcbiAgICAgICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBkb25lO1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKGZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGZyYW1lIGluIHRoZSBjdXJyZW50IHRocmVhZFxuICAgICAgICAgICAgZG9uZSh7XG4gICAgICAgICAgICAgICAgJ2RhdGEnOiBBbmltYXRlZEdpZkNvbnRleHQud29ya2VyTWV0aG9kcy5ydW4oZnJhbWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnRSZW5kZXJpbmc6IGZ1bmN0aW9uIHN0YXJ0UmVuZGVyaW5nKGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblJlbmRlckNvbXBsZXRlQ2FsbGJhY2sgPSBjb21wbGV0ZUNhbGxiYWNrO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLm51bVdvcmtlcnMgJiYgaSA8IHRoaXMuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGcmFtZShpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJvY2Vzc05leHRGcmFtZTogZnVuY3Rpb24gcHJvY2Vzc05leHRGcmFtZSgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghZnJhbWUuZG9uZSAmJiAhZnJhbWUuYmVpbmdQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRnJhbWUocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBUYWtlcyB0aGUgYWxyZWFkeSBwcm9jZXNzZWQgZGF0YSBpbiBmcmFtZXMgYW5kIGZlZWRzIGl0IHRvIGEgbmV3XG4gICAgLy8gR2lmV3JpdGVyIGluc3RhbmNlIGluIG9yZGVyIHRvIGdldCB0aGUgYmluYXJ5IEdJRiBmaWxlXG4gICAgZ2VuZXJhdGVHSUY6IGZ1bmN0aW9uIGdlbmVyYXRlR0lGKGZyYW1lcywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVE9ETzogV2VpcmQ6IHVzaW5nIGEgc2ltcGxlIEpTIGFycmF5IGluc3RlYWQgb2YgYSB0eXBlZCBhcnJheSxcbiAgICAgICAgLy8gdGhlIGZpbGVzIGFyZSBXQVkgc21hbGxlciBvX28uIFBhdGNoZXMvZXhwbGFuYXRpb25zIHdlbGNvbWUhXG4gICAgICAgIHZhciBidWZmZXIgPSBbXTsgLy8gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiBmcmFtZXMubGVuZ3RoICogNSk7XG4gICAgICAgIHZhciBnaWZPcHRpb25zID0ge1xuICAgICAgICAgICAgbG9vcDogdGhpcy5yZXBlYXRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG5cbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBvcHRpb25zLmZyYW1lRHVyYXRpb247XG4gICAgICAgIHZhciBleGlzdGluZ0ltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuICAgICAgICB2YXIgaGFzRXhpc3RpbmdJbWFnZXMgPSAhIWV4aXN0aW5nSW1hZ2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZ2lmSGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSBvcHRpb25zLmdpZldpZHRoO1xuICAgICAgICB2YXIgZ2lmV3JpdGVyJCQxID0gbmV3IGdpZldyaXRlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIGdpZk9wdGlvbnMpO1xuICAgICAgICB2YXIgb25SZW5kZXJQcm9ncmVzc0NhbGxiYWNrID0gdGhpcy5vblJlbmRlclByb2dyZXNzQ2FsbGJhY2s7XG4gICAgICAgIHZhciBkZWxheSA9IGhhc0V4aXN0aW5nSW1hZ2VzID8gaW50ZXJ2YWwgKiAxMDAgOiAwO1xuICAgICAgICB2YXIgYnVmZmVyVG9TdHJpbmcgPSB2b2lkIDA7XG4gICAgICAgIHZhciBnaWYgPSB2b2lkIDA7XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0aW5nR0lGID0gdHJ1ZTtcblxuICAgICAgICB1dGlscy5lYWNoKGZyYW1lcywgZnVuY3Rpb24gKGl0ZXJhdG9yLCBmcmFtZSkge1xuICAgICAgICAgICAgdmFyIGZyYW1lUGFsZXR0ZSA9IGZyYW1lLnBhbGV0dGU7XG5cbiAgICAgICAgICAgIG9uUmVuZGVyUHJvZ3Jlc3NDYWxsYmFjaygwLjc1ICsgMC4yNSAqIGZyYW1lLnBvc2l0aW9uICogMS4wIC8gZnJhbWVzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVEdXJhdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ2lmV3JpdGVyJCQxLmFkZEZyYW1lKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGZyYW1lLnBpeGVscywge1xuICAgICAgICAgICAgICAgICAgICBwYWxldHRlOiBmcmFtZVBhbGV0dGUsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBnaWZXcml0ZXIkJDEuZW5kKCk7XG5cbiAgICAgICAgb25SZW5kZXJQcm9ncmVzc0NhbGxiYWNrKDEuMCk7XG5cbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmdlbmVyYXRpbmdHSUYgPSBmYWxzZTtcblxuICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGJ1ZmZlclRvU3RyaW5nID0gdGhpcy5idWZmZXJUb1N0cmluZyhidWZmZXIpO1xuICAgICAgICAgICAgZ2lmID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwnICsgdXRpbHMuYnRvYShidWZmZXJUb1N0cmluZyk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGdpZik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEZyb20gR0lGOiAwID0gbG9vcCBmb3JldmVyLCBudWxsID0gbm90IGxvb3BpbmcsIG4gPiAwID0gbG9vcCBuIHRpbWVzIGFuZCBzdG9wXG4gICAgc2V0UmVwZWF0OiBmdW5jdGlvbiBzZXRSZXBlYXQocikge1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHI7XG4gICAgfSxcbiAgICBhZGRGcmFtZTogZnVuY3Rpb24gYWRkRnJhbWUoZWxlbWVudCwgZ2lmc2hvdE9wdGlvbnMpIHtcbiAgICAgICAgZ2lmc2hvdE9wdGlvbnMgPSB1dGlscy5pc09iamVjdChnaWZzaG90T3B0aW9ucykgPyBnaWZzaG90T3B0aW9ucyA6IHt9O1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGN0eCA9IHNlbGYuY3R4O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy5naWZXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZ2lmSGVpZ2h0O1xuICAgICAgICB2YXIgZm9udFNpemUgPSB1dGlscy5nZXRGb250U2l6ZShnaWZzaG90T3B0aW9ucyk7XG4gICAgICAgIHZhciBfZ2lmc2hvdE9wdGlvbnMgPSBnaWZzaG90T3B0aW9ucyxcbiAgICAgICAgICAgIGZpbHRlciA9IF9naWZzaG90T3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBmb250Q29sb3IgPSBfZ2lmc2hvdE9wdGlvbnMuZm9udENvbG9yLFxuICAgICAgICAgICAgZm9udEZhbWlseSA9IF9naWZzaG90T3B0aW9ucy5mb250RmFtaWx5LFxuICAgICAgICAgICAgZm9udFdlaWdodCA9IF9naWZzaG90T3B0aW9ucy5mb250V2VpZ2h0LFxuICAgICAgICAgICAgZ2lmSGVpZ2h0ID0gX2dpZnNob3RPcHRpb25zLmdpZkhlaWdodCxcbiAgICAgICAgICAgIGdpZldpZHRoID0gX2dpZnNob3RPcHRpb25zLmdpZldpZHRoLFxuICAgICAgICAgICAgdGV4dCA9IF9naWZzaG90T3B0aW9ucy50ZXh0LFxuICAgICAgICAgICAgdGV4dEFsaWduID0gX2dpZnNob3RPcHRpb25zLnRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9naWZzaG90T3B0aW9ucy50ZXh0QmFzZWxpbmU7XG5cbiAgICAgICAgdmFyIHRleHRYQ29vcmRpbmF0ZSA9IGdpZnNob3RPcHRpb25zLnRleHRYQ29vcmRpbmF0ZSA/IGdpZnNob3RPcHRpb25zLnRleHRYQ29vcmRpbmF0ZSA6IHRleHRBbGlnbiA9PT0gJ2xlZnQnID8gMSA6IHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHdpZHRoIDogd2lkdGggLyAyO1xuICAgICAgICB2YXIgdGV4dFlDb29yZGluYXRlID0gZ2lmc2hvdE9wdGlvbnMudGV4dFlDb29yZGluYXRlID8gZ2lmc2hvdE9wdGlvbnMudGV4dFlDb29yZGluYXRlIDogdGV4dEJhc2VsaW5lID09PSAndG9wJyA/IDEgOiB0ZXh0QmFzZWxpbmUgPT09ICdjZW50ZXInID8gaGVpZ2h0IC8gMiA6IGhlaWdodDtcbiAgICAgICAgdmFyIGZvbnQgPSBmb250V2VpZ2h0ICsgJyAnICsgZm9udFNpemUgKyAnICcgKyBmb250RmFtaWx5O1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gdm9pZCAwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguZmlsdGVyID0gZmlsdGVyO1xuXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGVsZW1lbnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgdGV4dFhDb29yZGluYXRlLCB0ZXh0WUNvb3JkaW5hdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICBzZWxmLmFkZEZyYW1lSW1hZ2VEYXRhKGltYWdlRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZEZyYW1lSW1hZ2VEYXRhOiBmdW5jdGlvbiBhZGRGcmFtZUltYWdlRGF0YSgpIHtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICB2YXIgaW1hZ2VEYXRhQXJyYXkgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICdkYXRhJzogaW1hZ2VEYXRhQXJyYXksXG4gICAgICAgICAgICAnd2lkdGgnOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgICAnaGVpZ2h0JzogaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICAgICdwYWxldHRlJzogbnVsbCxcbiAgICAgICAgICAgICdkaXRoZXJpbmcnOiBudWxsLFxuICAgICAgICAgICAgJ2RvbmUnOiBmYWxzZSxcbiAgICAgICAgICAgICdiZWluZ1Byb2Nlc3NlZCc6IGZhbHNlLFxuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogZnJhbWVzLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG9uUmVuZGVyUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUmVuZGVyUHJvZ3Jlc3MoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblJlbmRlclByb2dyZXNzQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9LFxuICAgIGlzUmVuZGVyaW5nOiBmdW5jdGlvbiBpc1JlbmRlcmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGluZ0dJRjtcbiAgICB9LFxuICAgIGdldEJhc2U2NEdJRjogZnVuY3Rpb24gZ2V0QmFzZTY0R0lGKGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb25SZW5kZXJDb21wbGV0ZSA9IGZ1bmN0aW9uIG9uUmVuZGVyQ29tcGxldGUoZ2lmKSB7XG4gICAgICAgICAgICBzZWxmLmRlc3Ryb3lXb3JrZXJzKCk7XG5cbiAgICAgICAgICAgIHV0aWxzLnJlcXVlc3RUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNhbGxiYWNrKGdpZik7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLnN0YXJ0UmVuZGVyaW5nKG9uUmVuZGVyQ29tcGxldGUpO1xuICAgIH0sXG4gICAgZGVzdHJveVdvcmtlcnM6IGZ1bmN0aW9uIGRlc3Ryb3lXb3JrZXJzKCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSB0aGlzLndvcmtlcnM7XG5cbiAgICAgICAgLy8gRXhwbGljaXRseSBhc2sgd2ViIHdvcmtlcnMgdG8gZGllIHNvIHRoZXkgYXJlIGV4cGxpY2l0bHkgR0MnZWRcbiAgICAgICAgdXRpbHMuZWFjaCh3b3JrZXJzLCBmdW5jdGlvbiAoaXRlcmF0b3IsIHdvcmtlck9iaikge1xuICAgICAgICAgICAgdmFyIHdvcmtlciA9IHdvcmtlck9iai53b3JrZXI7XG4gICAgICAgICAgICB2YXIgb2JqZWN0VXJsID0gd29ya2VyT2JqLm9iamVjdFVybDtcblxuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgdXRpbHMuVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKlxuICBnZXRCYXNlNjRHSUYuanNcbiAgPT09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG5mdW5jdGlvbiBnZXRCYXNlNjRHSUYoYW5pbWF0ZWRHaWZJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIGlzIGFzeW5jaHJvbm91cywgcmVuZGVyZWQgd2l0aCBXZWJXb3JrZXJzXG4gICAgYW5pbWF0ZWRHaWZJbnN0YW5jZS5nZXRCYXNlNjRHSUYoZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogJycsXG4gICAgICAgICAgICBlcnJvck1zZzogJycsXG4gICAgICAgICAgICBpbWFnZTogaW1hZ2VcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qXG4gIGV4aXN0aW5nSW1hZ2VzLmpzXG4gID09PT09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG5mdW5jdGlvbiBleGlzdGluZ0ltYWdlcygpIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FsbGJhY2sgPSBvYmouY2FsbGJhY2ssXG4gICAgICAgIGltYWdlcyA9IG9iai5pbWFnZXMsXG4gICAgICAgIG9wdGlvbnMgPSBvYmoub3B0aW9ucztcblxuICAgIHZhciBpbWFnZXNMZW5ndGggPSBvYmouaW1hZ2VzTGVuZ3RoO1xuICAgIHZhciBza2lwT2JqID0ge1xuICAgICAgICAnZ2V0VXNlck1lZGlhJzogdHJ1ZSxcbiAgICAgICAgJ3dpbmRvdy5VUkwnOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgZXJyb3JPYmogPSBlcnJvci52YWxpZGF0ZShza2lwT2JqKTtcbiAgICB2YXIgbG9hZGVkSW1hZ2VzID0gW107XG4gICAgdmFyIGxvYWRlZEltYWdlc0xlbmd0aCA9IDA7XG4gICAgdmFyIHRlbXBJbWFnZSA9IHZvaWQgMDtcbiAgICB2YXIgYWcgPSB2b2lkIDA7XG5cbiAgICBpZiAoZXJyb3JPYmouZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yT2JqKTtcbiAgICB9XG5cbiAgICAvLyBjaGFuZ2Ugd29ya2VyUGF0aCB0byBwb2ludCB0byB3aGVyZSBBbmltYXRlZF9HSUYud29ya2VyLmpzIGlzXG4gICAgYWcgPSBuZXcgQW5pbWF0ZWRHSUYob3B0aW9ucyk7XG5cbiAgICB1dGlscy5lYWNoKGltYWdlcywgZnVuY3Rpb24gKGluZGV4LCBpbWFnZSkge1xuICAgICAgICB2YXIgY3VycmVudEltYWdlID0gaW1hZ2U7XG5cbiAgICAgICAgaWYgKGltYWdlLnNyYykge1xuICAgICAgICAgICAgY3VycmVudEltYWdlID0gY3VycmVudEltYWdlLnNyYztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbHMuaXNFbGVtZW50KGN1cnJlbnRJbWFnZSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEltYWdlLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9hZGVkSW1hZ2VzW2luZGV4XSA9IGN1cnJlbnRJbWFnZTtcbiAgICAgICAgICAgIGxvYWRlZEltYWdlc0xlbmd0aCArPSAxO1xuXG4gICAgICAgICAgICBpZiAobG9hZGVkSW1hZ2VzTGVuZ3RoID09PSBpbWFnZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhZGRMb2FkZWRJbWFnZXNUb0dpZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyaW5nKGN1cnJlbnRJbWFnZSkpIHtcbiAgICAgICAgICAgIHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgICAgIHRlbXBJbWFnZS5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiAodGVtcEltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEltYWdlLnRleHQgPSBpbWFnZS50ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRlbXBJbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgICAgICAtLWltYWdlc0xlbmd0aDsgLy8gc2tpcHMgb3ZlciBpbWFnZXMgdGhhdCBlcnJvciBvdXRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VzTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5lcnJvciA9ICdOb25lIG9mIHRoZSByZXF1ZXN0ZWQgaW1hZ2VzIHdhcyBjYXBhYmxlIG9mIGJlaW5nIHJldHJpZXZlZCc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRlbXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkSW1hZ2VzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IHRlbXBJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZW1wSW1hZ2UudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZEltYWdlc1tpbmRleF0gPSB0ZW1wSW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRJbWFnZXNMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkSW1hZ2VzTGVuZ3RoID09PSBpbWFnZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExvYWRlZEltYWdlc1RvR2lmKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB1dGlscy5yZW1vdmVFbGVtZW50KHRlbXBJbWFnZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRlbXBJbWFnZS5zcmMgPSBjdXJyZW50SW1hZ2U7XG4gICAgICAgICAgICB9KSh0ZW1wSW1hZ2UpO1xuXG4gICAgICAgICAgICB1dGlscy5zZXRDU1NBdHRyKHRlbXBJbWFnZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEltYWdlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkTG9hZGVkSW1hZ2VzVG9HaWYoKSB7XG4gICAgICAgIHV0aWxzLmVhY2gobG9hZGVkSW1hZ2VzLCBmdW5jdGlvbiAoaW5kZXgsIGxvYWRlZEltYWdlKSB7XG4gICAgICAgICAgICBpZiAobG9hZGVkSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkSW1hZ2UudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhZy5hZGRGcmFtZShsb2FkZWRJbWFnZS5pbWcsIG9wdGlvbnMsIGxvYWRlZEltYWdlLnRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFnLmFkZEZyYW1lKGxvYWRlZEltYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdldEJhc2U2NEdJRihhZywgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLypcbiAgc2NyZWVuU2hvdC5qc1xuICA9PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4vLyBEZXBlbmRlbmNpZXNcbi8vIEhlbHBlcnNcbnZhciBub29wJDMgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBzY3JlZW5TaG90ID0ge1xuICAgIGdldEdJRjogZnVuY3Rpb24gZ2V0R0lGKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBjYWxsYmFjayA9IHV0aWxzLmlzRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiBub29wJDM7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGV4aXN0aW5nSW1hZ2VzID0gb3B0aW9ucy5pbWFnZXM7XG4gICAgICAgIHZhciBoYXNFeGlzdGluZ0ltYWdlcyA9ICEhZXhpc3RpbmdJbWFnZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY2FtZXJhU3RyZWFtID0gb3B0aW9ucy5jYW1lcmFTdHJlYW0sXG4gICAgICAgICAgICBjcm9wID0gb3B0aW9ucy5jcm9wLFxuICAgICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBmb250Q29sb3IgPSBvcHRpb25zLmZvbnRDb2xvcixcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBvcHRpb25zLmZvbnRGYW1pbHksXG4gICAgICAgICAgICBmb250V2VpZ2h0ID0gb3B0aW9ucy5mb250V2VpZ2h0LFxuICAgICAgICAgICAga2VlcENhbWVyYU9uID0gb3B0aW9ucy5rZWVwQ2FtZXJhT24sXG4gICAgICAgICAgICBudW1Xb3JrZXJzID0gb3B0aW9ucy5udW1Xb3JrZXJzLFxuICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjayxcbiAgICAgICAgICAgIHNhdmVSZW5kZXJpbmdDb250ZXh0cyA9IG9wdGlvbnMuc2F2ZVJlbmRlcmluZ0NvbnRleHRzLFxuICAgICAgICAgICAgc2F2ZWRSZW5kZXJpbmdDb250ZXh0cyA9IG9wdGlvbnMuc2F2ZWRSZW5kZXJpbmdDb250ZXh0cyxcbiAgICAgICAgICAgIHRleHQgPSBvcHRpb25zLnRleHQsXG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IG9wdGlvbnMudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gb3B0aW9ucy52aWRlb0VsZW1lbnQsXG4gICAgICAgICAgICB2aWRlb0hlaWdodCA9IG9wdGlvbnMudmlkZW9IZWlnaHQsXG4gICAgICAgICAgICB2aWRlb1dpZHRoID0gb3B0aW9ucy52aWRlb1dpZHRoLFxuICAgICAgICAgICAgd2ViY2FtVmlkZW9FbGVtZW50ID0gb3B0aW9ucy53ZWJjYW1WaWRlb0VsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGdpZldpZHRoID0gTnVtYmVyKG9wdGlvbnMuZ2lmV2lkdGgpO1xuICAgICAgICB2YXIgZ2lmSGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMuZ2lmSGVpZ2h0KTtcbiAgICAgICAgdmFyIGludGVydmFsID0gTnVtYmVyKG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICB2YXIgc2FtcGxlSW50ZXJ2YWwgPSBOdW1iZXIob3B0aW9ucy5zYW1wbGVJbnRlcnZhbCk7XG4gICAgICAgIHZhciB3YWl0QmV0d2VlbkZyYW1lcyA9IGhhc0V4aXN0aW5nSW1hZ2VzID8gMCA6IGludGVydmFsICogMTAwMDtcbiAgICAgICAgdmFyIHJlbmRlcmluZ0NvbnRleHRzVG9TYXZlID0gW107XG4gICAgICAgIHZhciBudW1GcmFtZXMgPSBzYXZlZFJlbmRlcmluZ0NvbnRleHRzLmxlbmd0aCA/IHNhdmVkUmVuZGVyaW5nQ29udGV4dHMubGVuZ3RoIDogb3B0aW9ucy5udW1GcmFtZXM7XG4gICAgICAgIHZhciBwZW5kaW5nRnJhbWVzID0gbnVtRnJhbWVzO1xuICAgICAgICB2YXIgYWcgPSBuZXcgQW5pbWF0ZWRHSUYob3B0aW9ucyk7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHV0aWxzLmdldEZvbnRTaXplKG9wdGlvbnMpO1xuICAgICAgICB2YXIgdGV4dFhDb29yZGluYXRlID0gb3B0aW9ucy50ZXh0WENvb3JkaW5hdGUgPyBvcHRpb25zLnRleHRYQ29vcmRpbmF0ZSA6IHRleHRBbGlnbiA9PT0gJ2xlZnQnID8gMSA6IHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IGdpZldpZHRoIDogZ2lmV2lkdGggLyAyO1xuICAgICAgICB2YXIgdGV4dFlDb29yZGluYXRlID0gb3B0aW9ucy50ZXh0WUNvb3JkaW5hdGUgPyBvcHRpb25zLnRleHRZQ29vcmRpbmF0ZSA6IHRleHRCYXNlbGluZSA9PT0gJ3RvcCcgPyAxIDogdGV4dEJhc2VsaW5lID09PSAnY2VudGVyJyA/IGdpZkhlaWdodCAvIDIgOiBnaWZIZWlnaHQ7XG4gICAgICAgIHZhciBmb250ID0gZm9udFdlaWdodCArICcgJyArIGZvbnRTaXplICsgJyAnICsgZm9udEZhbWlseTtcbiAgICAgICAgdmFyIHNvdXJjZVggPSBjcm9wID8gTWF0aC5mbG9vcihjcm9wLnNjYWxlZFdpZHRoIC8gMikgOiAwO1xuICAgICAgICB2YXIgc291cmNlV2lkdGggPSBjcm9wID8gdmlkZW9XaWR0aCAtIGNyb3Auc2NhbGVkV2lkdGggOiAwO1xuICAgICAgICB2YXIgc291cmNlWSA9IGNyb3AgPyBNYXRoLmZsb29yKGNyb3Auc2NhbGVkSGVpZ2h0IC8gMikgOiAwO1xuICAgICAgICB2YXIgc291cmNlSGVpZ2h0ID0gY3JvcCA/IHZpZGVvSGVpZ2h0IC0gY3JvcC5zY2FsZWRIZWlnaHQgOiAwO1xuICAgICAgICB2YXIgY2FwdHVyZUZyYW1lcyA9IGZ1bmN0aW9uIGNhcHR1cmVTaW5nbGVGcmFtZSgpIHtcbiAgICAgICAgICAgIHZhciBmcmFtZXNMZWZ0ID0gcGVuZGluZ0ZyYW1lcyAtIDE7XG5cbiAgICAgICAgICAgIGlmIChzYXZlZFJlbmRlcmluZ0NvbnRleHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKHNhdmVkUmVuZGVyaW5nQ29udGV4dHNbbnVtRnJhbWVzIC0gcGVuZGluZ0ZyYW1lc10sIDAsIDApO1xuXG4gICAgICAgICAgICAgICAgZmluaXNoQ2FwdHVyZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmF3VmlkZW8oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd1ZpZGVvKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2VzIHN1cmUgdGhlIGNhbnZhcyB2aWRlbyBoZWlnaHRzL3dpZHRocyBhcmUgaW4gYm91bmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VXaWR0aCA+IHZpZGVvV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVdpZHRoID0gdmlkZW9XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VIZWlnaHQgPiB2aWRlb0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlWCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsdGVyID0gZmlsdGVyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHZpZGVvRWxlbWVudCwgc291cmNlWCwgc291cmNlWSwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgMCwgMCwgZ2lmV2lkdGgsIGdpZkhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmluaXNoQ2FwdHVyZSgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBGaXJlZm94IGJ1ZyB0aGF0IHNvbWV0aW1lcyB0aHJvd3MgTlNfRVJST1JfTk9UX0FWQUlMQUJMRSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIEluZGV4U2l6ZUVycm9yIGVycm9ycyB3aGVuIGRyYXdpbmcgYSB2aWRlbyBlbGVtZW50IHRvIHRoZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05TX0VSUk9SX05PVF9BVkFJTEFCTEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IDEwMG1zIGJlZm9yZSB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnJlcXVlc3RUaW1lb3V0KGRyYXdWaWRlbywgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaENhcHR1cmUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICAgIGlmIChzYXZlUmVuZGVyaW5nQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyaW5nQ29udGV4dHNUb1NhdmUucHVzaChjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBnaWZXaWR0aCwgZ2lmSGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgdGV4dCB0byBkaXNwbGF5LCBtYWtlIHN1cmUgdG8gZGlzcGxheSBpdCBvbiB0aGUgY2FudmFzIGFmdGVyIHRoZSBpbWFnZSBpcyBkcmF3blxuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZm9udENvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgdGV4dFhDb29yZGluYXRlLCB0ZXh0WUNvb3JkaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGdpZldpZHRoLCBnaWZIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgYWcuYWRkRnJhbWVJbWFnZURhdGEoaW1hZ2VEYXRhKTtcblxuICAgICAgICAgICAgICAgIHBlbmRpbmdGcmFtZXMgPSBmcmFtZXNMZWZ0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBiYWNrIHdpdGggYW4gciB2YWx1ZSBpbmRpY2F0aW5nIGhvdyBmYXIgYWxvbmcgd2UgYXJlIGluIGNhcHR1cmVcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKChudW1GcmFtZXMgLSBwZW5kaW5nRnJhbWVzKSAvIG51bUZyYW1lcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdFxuICAgICAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0VGltZW91dChjYXB0dXJlU2luZ2xlRnJhbWUsIHdhaXRCZXR3ZWVuRnJhbWVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWcuZ2V0QmFzZTY0R0lGKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcic6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvckNvZGUnOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXJyb3JNc2cnOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW1hZ2UnOiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2FtZXJhU3RyZWFtJzogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2aWRlb0VsZW1lbnQnOiB2aWRlb0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dlYmNhbVZpZGVvRWxlbWVudCc6IHdlYmNhbVZpZGVvRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2F2ZWRSZW5kZXJpbmdDb250ZXh0cyc6IHJlbmRlcmluZ0NvbnRleHRzVG9TYXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdrZWVwQ2FtZXJhT24nOiBrZWVwQ2FtZXJhT25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbnVtRnJhbWVzID0gbnVtRnJhbWVzICE9PSB1bmRlZmluZWQgPyBudW1GcmFtZXMgOiAxMDtcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCAhPT0gdW5kZWZpbmVkID8gaW50ZXJ2YWwgOiAwLjE7IC8vIEluIHNlY29uZHNcblxuICAgICAgICBjYW52YXMud2lkdGggPSBnaWZXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGdpZkhlaWdodDtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIChmdW5jdGlvbiBjYXB0dXJlKCkge1xuICAgICAgICAgICAgaWYgKCFzYXZlZFJlbmRlcmluZ0NvbnRleHRzLmxlbmd0aCAmJiB2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB1dGlscy5yZXF1ZXN0VGltZW91dChjYXB0dXJlLCAxMDApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXB0dXJlRnJhbWVzKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfSxcbiAgICBnZXRDcm9wRGltZW5zaW9uczogZnVuY3Rpb24gZ2V0Q3JvcERpbWVuc2lvbnMoKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIHZhciB3aWR0aCA9IG9iai52aWRlb1dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb2JqLnZpZGVvSGVpZ2h0O1xuICAgICAgICB2YXIgZ2lmV2lkdGggPSBvYmouZ2lmV2lkdGg7XG4gICAgICAgIHZhciBnaWZIZWlnaHQgPSBvYmouZ2lmSGVpZ2h0O1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBzY2FsZWRXaWR0aDogMCxcbiAgICAgICAgICAgIHNjYWxlZEhlaWdodDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3aWR0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgcmVzdWx0LndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIChnaWZIZWlnaHQgLyBoZWlnaHQpKSAtIGdpZldpZHRoO1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlZFdpZHRoID0gTWF0aC5yb3VuZChyZXN1bHQud2lkdGggKiAoaGVpZ2h0IC8gZ2lmSGVpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiAoZ2lmV2lkdGggLyB3aWR0aCkpIC0gZ2lmSGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlZEhlaWdodCA9IE1hdGgucm91bmQocmVzdWx0LmhlaWdodCAqICh3aWR0aCAvIGdpZldpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qXG4gIHZpZGVvU3RyZWFtLmpzXG4gID09PT09PT09PT09PT09XG4qL1xuXG4vKiBDb3B5cmlnaHQgIDIwMTcgWWFob28gSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG4vLyBEZXBlbmRlbmNpZXNcbnZhciB2aWRlb1N0cmVhbSA9IHtcbiAgICBsb2FkZWREYXRhOiBmYWxzZSxcbiAgICBkZWZhdWx0VmlkZW9EaW1lbnNpb25zOiB7XG4gICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgIGhlaWdodDogNDgwXG4gICAgfSxcbiAgICBmaW5kVmlkZW9TaXplOiBmdW5jdGlvbiBmaW5kVmlkZW9TaXplTWV0aG9kKG9iaikge1xuICAgICAgICBmaW5kVmlkZW9TaXplTWV0aG9kLmF0dGVtcHRzID0gZmluZFZpZGVvU2l6ZU1ldGhvZC5hdHRlbXB0cyB8fCAwO1xuXG4gICAgICAgIHZhciBjYW1lcmFTdHJlYW0gPSBvYmouY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgY29tcGxldGVkQ2FsbGJhY2sgPSBvYmouY29tcGxldGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBvYmoudmlkZW9FbGVtZW50O1xuXG5cbiAgICAgICAgaWYgKCF2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCA+IDAgJiYgdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCB2aWRlb1N0cmVhbS5maW5kVmlkZW9TaXplKTtcblxuICAgICAgICAgICAgY29tcGxldGVkQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudDogdmlkZW9FbGVtZW50LFxuICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgIHZpZGVvV2lkdGg6IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgIHZpZGVvSGVpZ2h0OiB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbmRWaWRlb1NpemVNZXRob2QuYXR0ZW1wdHMgPCAxMCkge1xuICAgICAgICAgICAgICAgIGZpbmRWaWRlb1NpemVNZXRob2QuYXR0ZW1wdHMgKz0gMTtcblxuICAgICAgICAgICAgICAgIHV0aWxzLnJlcXVlc3RUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9TdHJlYW0uZmluZFZpZGVvU2l6ZShvYmopO1xuICAgICAgICAgICAgICAgIH0sIDQwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50OiB2aWRlb0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb1dpZHRoOiB2aWRlb1N0cmVhbS5kZWZhdWx0VmlkZW9EaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0hlaWdodDogdmlkZW9TdHJlYW0uZGVmYXVsdFZpZGVvRGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25TdHJlYW1pbmdUaW1lb3V0OiBmdW5jdGlvbiBvblN0cmVhbWluZ1RpbWVvdXQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlOiAnZ2V0VXNlck1lZGlhJyxcbiAgICAgICAgICAgICAgICBlcnJvck1zZzogJ1RoZXJlIHdhcyBhbiBpc3N1ZSB3aXRoIHRoZSBnZXRVc2VyTWVkaWEgQVBJIC0gVGltZWQgb3V0IHdoaWxlIHRyeWluZyB0byBzdGFydCBzdHJlYW1pbmcnLFxuICAgICAgICAgICAgICAgIGltYWdlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJlYW06IGZ1bmN0aW9uIHN0cmVhbShvYmopIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nVmlkZW8gPSB1dGlscy5pc0FycmF5KG9iai5leGlzdGluZ1ZpZGVvKSA/IG9iai5leGlzdGluZ1ZpZGVvWzBdIDogb2JqLmV4aXN0aW5nVmlkZW87XG4gICAgICAgIHZhciBjYW1lcmFTdHJlYW0gPSBvYmouY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgY29tcGxldGVkQ2FsbGJhY2sgPSBvYmouY29tcGxldGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBzdHJlYW1lZENhbGxiYWNrID0gb2JqLnN0cmVhbWVkQ2FsbGJhY2ssXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBvYmoudmlkZW9FbGVtZW50O1xuXG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oc3RyZWFtZWRDYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHN0cmVhbWVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGlzdGluZ1ZpZGVvKSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZXhpc3RpbmdWaWRlbykpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gZXhpc3RpbmdWaWRlbztcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuaW5uZXJIVE1MID0gJzxzb3VyY2Ugc3JjPVwiJyArIGV4aXN0aW5nVmlkZW8gKyAnXCIgdHlwZT1cInZpZGVvLycgKyB1dGlscy5nZXRFeHRlbnNpb24oZXhpc3RpbmdWaWRlbykgKyAnXCIgLz4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1ZpZGVvIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmMgPSB1dGlscy5VUkwuY3JlYXRlT2JqZWN0VVJMKGV4aXN0aW5nVmlkZW8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuaW5uZXJIVE1MID0gJzxzb3VyY2Ugc3JjPVwiJyArIGV4aXN0aW5nVmlkZW8gKyAnXCIgdHlwZT1cIicgKyBleGlzdGluZ1ZpZGVvLnR5cGUgKyAnXCIgLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZGVvRWxlbWVudC5tb3pTcmNPYmplY3QpIHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5tb3pTcmNPYmplY3QgPSBjYW1lcmFTdHJlYW07XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuVVJMKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBjYW1lcmFTdHJlYW07XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyYyA9IHV0aWxzLlVSTC5jcmVhdGVPYmplY3RVUkwoY2FtZXJhU3RyZWFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gY2FtZXJhU3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKTtcblxuICAgICAgICB1dGlscy5yZXF1ZXN0VGltZW91dChmdW5jdGlvbiBjaGVja0xvYWRlZERhdGEoKSB7XG4gICAgICAgICAgICBjaGVja0xvYWRlZERhdGEuY291bnQgPSBjaGVja0xvYWRlZERhdGEuY291bnQgfHwgMDtcblxuICAgICAgICAgICAgaWYgKHZpZGVvU3RyZWFtLmxvYWRlZERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2aWRlb1N0cmVhbS5maW5kVmlkZW9TaXplKHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50OiB2aWRlb0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRDYWxsYmFjazogY29tcGxldGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZpZGVvU3RyZWFtLmxvYWRlZERhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWREYXRhLmNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tMb2FkZWREYXRhLmNvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9TdHJlYW0uZmluZFZpZGVvU2l6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQ6IHZpZGVvRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkQ2FsbGJhY2s6IGNvbXBsZXRlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTG9hZGVkRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICBzdGFydFN0cmVhbWluZzogZnVuY3Rpb24gc3RhcnRTdHJlYW1pbmcob2JqKSB7XG4gICAgICAgIHZhciBlcnJvckNhbGxiYWNrID0gdXRpbHMuaXNGdW5jdGlvbihvYmouZXJyb3IpID8gb2JqLmVycm9yIDogdXRpbHMubm9vcDtcbiAgICAgICAgdmFyIHN0cmVhbWVkQ2FsbGJhY2sgPSB1dGlscy5pc0Z1bmN0aW9uKG9iai5zdHJlYW1lZCkgPyBvYmouc3RyZWFtZWQgOiB1dGlscy5ub29wO1xuICAgICAgICB2YXIgY29tcGxldGVkQ2FsbGJhY2sgPSB1dGlscy5pc0Z1bmN0aW9uKG9iai5jb21wbGV0ZWQpID8gb2JqLmNvbXBsZXRlZCA6IHV0aWxzLm5vb3A7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IG9iai5jcm9zc09yaWdpbixcbiAgICAgICAgICAgIGV4aXN0aW5nVmlkZW8gPSBvYmouZXhpc3RpbmdWaWRlbyxcbiAgICAgICAgICAgIGxhc3RDYW1lcmFTdHJlYW0gPSBvYmoubGFzdENhbWVyYVN0cmVhbSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvYmoub3B0aW9ucyxcbiAgICAgICAgICAgIHdlYmNhbVZpZGVvRWxlbWVudCA9IG9iai53ZWJjYW1WaWRlb0VsZW1lbnQ7XG5cbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IHV0aWxzLmlzRWxlbWVudChleGlzdGluZ1ZpZGVvKSA/IGV4aXN0aW5nVmlkZW8gOiB3ZWJjYW1WaWRlb0VsZW1lbnQgPyB3ZWJjYW1WaWRlb0VsZW1lbnQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB2YXIgY2FtZXJhU3RyZWFtID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZGVvRWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIHZpZGVvRWxlbWVudC5sb29wID0gdHJ1ZTtcbiAgICAgICAgdmlkZW9FbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZpZGVvU3RyZWFtLmxvYWRlZERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChleGlzdGluZ1ZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlb1N0cmVhbS5zdHJlYW0oe1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudDogdmlkZW9FbGVtZW50LFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmlkZW86IGV4aXN0aW5nVmlkZW8sXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQ2FsbGJhY2s6IGNvbXBsZXRlZENhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2FtZXJhU3RyZWFtKSB7XG4gICAgICAgICAgICB2aWRlb1N0cmVhbS5zdHJlYW0oe1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudDogdmlkZW9FbGVtZW50LFxuICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogbGFzdENhbWVyYVN0cmVhbSxcbiAgICAgICAgICAgICAgICBzdHJlYW1lZENhbGxiYWNrOiBzdHJlYW1lZENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENhbGxiYWNrOiBjb21wbGV0ZWRDYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlscy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9TdHJlYW0uc3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50OiB2aWRlb0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZENhbGxiYWNrOiBzdHJlYW1lZENhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRDYWxsYmFjazogY29tcGxldGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdGFydFZpZGVvU3RyZWFtaW5nOiBmdW5jdGlvbiBzdGFydFZpZGVvU3RyZWFtaW5nKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICB2YXIgdGltZW91dExlbmd0aCA9IG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lb3V0IDogMDtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgICAgICB2YXIgd2ViY2FtVmlkZW9FbGVtZW50ID0gb3B0aW9ucy53ZWJjYW1WaWRlb0VsZW1lbnQ7XG4gICAgICAgIHZhciBub0dldFVzZXJNZWRpYVN1cHBvcnRUaW1lb3V0ID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBoYXZlIHN1cHBvcnQgZm9yIHZpZGVvIHN0cmVhbWluZyBiZWNhdXNlIG9mIHRoZVxuICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGUgZ2V0VXNlck1lZGlhIGZ1bmN0aW9uLCBidXQgdGhlbiBkbyBub3QgYW5zd2VyIG91clxuICAgICAgICAvLyBjYWxscyBmb3Igc3RyZWFtaW5nLlxuICAgICAgICAvLyBTbyB3ZSdsbCBzZXQgdXAgdGhpcyB0aW1lb3V0IGFuZCBpZiBub3RoaW5nIGhhcHBlbnMgYWZ0ZXIgYSB3aGlsZSwgd2UnbGxcbiAgICAgICAgLy8gY29uY2x1ZGUgdGhhdCB0aGVyZSdzIG5vIGFjdHVhbCBnZXRVc2VyTWVkaWEgc3VwcG9ydC5cbiAgICAgICAgaWYgKHRpbWVvdXRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub0dldFVzZXJNZWRpYVN1cHBvcnRUaW1lb3V0ID0gdXRpbHMucmVxdWVzdFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZpZGVvU3RyZWFtLm9uU3RyZWFtaW5nVGltZW91dChvcmlnaW5hbENhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZGVvU3RyZWFtLnN0YXJ0U3RyZWFtaW5nKHtcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZTogJ2dldFVzZXJNZWRpYScsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnOiAnVGhlcmUgd2FzIGFuIGlzc3VlIHdpdGggdGhlIGdldFVzZXJNZWRpYSBBUEkgLSB0aGUgdXNlciBwcm9iYWJseSBkZW5pZWQgcGVybWlzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjYW1lcmFTdHJlYW06IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyZWFtZWQ6IGZ1bmN0aW9uIHN0cmVhbWVkKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzdHJlYW1pbmcgc3RhcnRlZCBzb21laG93LCBzbyB3ZSBjYW4gYXNzdW1lIHRoZXJlIGlzIGdldFVzZXJNZWRpYSBzdXBwb3J0XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG5vR2V0VXNlck1lZGlhU3VwcG9ydFRpbWVvdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlZDogZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciBjYW1lcmFTdHJlYW0gPSBvYmouY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBvYmoudmlkZW9FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0hlaWdodCA9IG9iai52aWRlb0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9XaWR0aCA9IG9iai52aWRlb1dpZHRoO1xuXG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0cmVhbTogY2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQ6IHZpZGVvRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9IZWlnaHQ6IHZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB2aWRlb1dpZHRoOiB2aWRlb1dpZHRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdENhbWVyYVN0cmVhbTogb3B0aW9ucy5sYXN0Q2FtZXJhU3RyZWFtLFxuICAgICAgICAgICAgd2ViY2FtVmlkZW9FbGVtZW50OiB3ZWJjYW1WaWRlb0VsZW1lbnQsXG4gICAgICAgICAgICBjcm9zc09yaWdpbjogb3B0aW9ucy5jcm9zc09yaWdpbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzdG9wVmlkZW9TdHJlYW1pbmc6IGZ1bmN0aW9uIHN0b3BWaWRlb1N0cmVhbWluZyhvYmopIHtcbiAgICAgICAgb2JqID0gdXRpbHMuaXNPYmplY3Qob2JqKSA/IG9iaiA6IHt9O1xuXG4gICAgICAgIHZhciBfb2JqID0gb2JqLFxuICAgICAgICAgICAga2VlcENhbWVyYU9uID0gX29iai5rZWVwQ2FtZXJhT24sXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBfb2JqLnZpZGVvRWxlbWVudCxcbiAgICAgICAgICAgIHdlYmNhbVZpZGVvRWxlbWVudCA9IF9vYmoud2ViY2FtVmlkZW9FbGVtZW50O1xuXG4gICAgICAgIHZhciBjYW1lcmFTdHJlYW0gPSBvYmouY2FtZXJhU3RyZWFtIHx8IHt9O1xuICAgICAgICB2YXIgY2FtZXJhU3RyZWFtVHJhY2tzID0gY2FtZXJhU3RyZWFtLmdldFRyYWNrcyA/IGNhbWVyYVN0cmVhbS5nZXRUcmFja3MoKSB8fCBbXSA6IFtdO1xuICAgICAgICB2YXIgaGFzQ2FtZXJhU3RyZWFtVHJhY2tzID0gISFjYW1lcmFTdHJlYW1UcmFja3MubGVuZ3RoO1xuICAgICAgICB2YXIgZmlyc3RDYW1lcmFTdHJlYW1UcmFjayA9IGNhbWVyYVN0cmVhbVRyYWNrc1swXTtcblxuICAgICAgICBpZiAoIWtlZXBDYW1lcmFPbiAmJiBoYXNDYW1lcmFTdHJlYW1UcmFja3MpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpcnN0Q2FtZXJhU3RyZWFtVHJhY2suc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9wcyB0aGUgY2FtZXJhIHN0cmVhbVxuICAgICAgICAgICAgICAgIGZpcnN0Q2FtZXJhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRWxlbWVudCh2aWRlb0VsZW1lbnQpICYmICF3ZWJjYW1WaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFBhdXNlcyB0aGUgdmlkZW8sIHJldm9rZXMgdGhlIG9iamVjdCBVUkwgKGZyZWVpbmcgdXAgbWVtb3J5KSwgYW5kIHJlbW92ZSB0aGUgdmlkZW8gZWxlbWVudFxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBhdXNlKCk7XG5cbiAgICAgICAgICAgIC8vIERlc3Ryb3lzIHRoZSBvYmplY3QgdXJsXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih1dGlscy5VUkwucmV2b2tlT2JqZWN0VVJMKSAmJiAhdXRpbHMud2ViV29ya2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyYykge1xuICAgICAgICAgICAgICAgICAgICB1dGlscy5VUkwucmV2b2tlT2JqZWN0VVJMKHZpZGVvRWxlbWVudC5zcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgdmlkZW8gZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgICAgICAgIHV0aWxzLnJlbW92ZUVsZW1lbnQodmlkZW9FbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gIHN0b3BWaWRlb1N0cmVhbWluZy5qc1xuICA9PT09PT09PT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbmZ1bmN0aW9uIHN0b3BWaWRlb1N0cmVhbWluZyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB1dGlscy5pc09iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTtcblxuICB2aWRlb1N0cmVhbS5zdG9wVmlkZW9TdHJlYW1pbmcob3B0aW9ucyk7XG59XG5cbi8qXG4gIGNyZWF0ZUFuZEdldEdJRi5qc1xuICA9PT09PT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xuZnVuY3Rpb24gY3JlYXRlQW5kR2V0R0lGKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9iai5vcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzLFxuICAgICAgICB2aWRlbyA9IG9wdGlvbnMudmlkZW87XG5cbiAgICB2YXIgZ2lmV2lkdGggPSBOdW1iZXIob3B0aW9ucy5naWZXaWR0aCk7XG4gICAgdmFyIGdpZkhlaWdodCA9IE51bWJlcihvcHRpb25zLmdpZkhlaWdodCk7XG4gICAgdmFyIG51bUZyYW1lcyA9IE51bWJlcihvcHRpb25zLm51bUZyYW1lcyk7XG4gICAgdmFyIGNhbWVyYVN0cmVhbSA9IG9iai5jYW1lcmFTdHJlYW0sXG4gICAgICAgIHZpZGVvRWxlbWVudCA9IG9iai52aWRlb0VsZW1lbnQsXG4gICAgICAgIHZpZGVvV2lkdGggPSBvYmoudmlkZW9XaWR0aCxcbiAgICAgICAgdmlkZW9IZWlnaHQgPSBvYmoudmlkZW9IZWlnaHQ7XG5cbiAgICB2YXIgY3JvcERpbWVuc2lvbnMgPSBzY3JlZW5TaG90LmdldENyb3BEaW1lbnNpb25zKHtcbiAgICAgICAgdmlkZW9XaWR0aDogdmlkZW9XaWR0aCxcbiAgICAgICAgdmlkZW9IZWlnaHQ6IHZpZGVvSGVpZ2h0LFxuICAgICAgICBnaWZIZWlnaHQ6IGdpZkhlaWdodCxcbiAgICAgICAgZ2lmV2lkdGg6IGdpZldpZHRoXG4gICAgfSk7XG4gICAgdmFyIGNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY3JvcCA9IGNyb3BEaW1lbnNpb25zO1xuICAgIG9wdGlvbnMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50O1xuICAgIG9wdGlvbnMudmlkZW9XaWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgb3B0aW9ucy52aWRlb0hlaWdodCA9IHZpZGVvSGVpZ2h0O1xuICAgIG9wdGlvbnMuY2FtZXJhU3RyZWFtID0gY2FtZXJhU3RyZWFtO1xuXG4gICAgaWYgKCF1dGlscy5pc0VsZW1lbnQodmlkZW9FbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmlkZW9FbGVtZW50LndpZHRoID0gZ2lmV2lkdGggKyBjcm9wRGltZW5zaW9ucy53aWR0aDtcbiAgICB2aWRlb0VsZW1lbnQuaGVpZ2h0ID0gZ2lmSGVpZ2h0ICsgY3JvcERpbWVuc2lvbnMuaGVpZ2h0O1xuXG4gICAgaWYgKCFvcHRpb25zLndlYmNhbVZpZGVvRWxlbWVudCkge1xuICAgICAgICB1dGlscy5zZXRDU1NBdHRyKHZpZGVvRWxlbWVudCwge1xuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzZWVtIHRvIG9iZXkgYXV0b3BsYXkgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGluIHRoZSBET00gd2hlbiB0aGUgY29udGVudFxuICAgIC8vIGlzIGxvYWRlZCwgc28gd2UgbXVzdCBtYW51YWxseSB0cmlnZ2VyIHBsYXkgYWZ0ZXIgYWRkaW5nIGl0LCBvciB0aGUgdmlkZW8gd2lsbCBiZSBmcm96ZW5cbiAgICB2aWRlb0VsZW1lbnQucGxheSgpO1xuXG4gICAgc2NyZWVuU2hvdC5nZXRHSUYob3B0aW9ucywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoKCFpbWFnZXMgfHwgIWltYWdlcy5sZW5ndGgpICYmICghdmlkZW8gfHwgIXZpZGVvLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHN0b3BWaWRlb1N0cmVhbWluZyhvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGVDYWxsYmFjayhvYmopO1xuICAgIH0pO1xufVxuXG4vKlxuICBleGlzdGluZ1ZpZGVvLmpzXG4gID09PT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xuZnVuY3Rpb24gZXhpc3RpbmdWaWRlbygpIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvYmouY2FsbGJhY2ssXG4gICAgICAgIGV4aXN0aW5nVmlkZW8gPSBvYmouZXhpc3RpbmdWaWRlbyxcbiAgICAgICAgb3B0aW9ucyA9IG9iai5vcHRpb25zO1xuXG4gICAgdmFyIHNraXBPYmogPSB7XG4gICAgICAgIGdldFVzZXJNZWRpYTogdHJ1ZSxcbiAgICAgICAgJ3dpbmRvdy5VUkwnOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgZXJyb3JPYmogPSBlcnJvci52YWxpZGF0ZShza2lwT2JqKTtcbiAgICB2YXIgbG9hZGVkSW1hZ2VzID0gMDtcbiAgICB2YXIgdmlkZW9UeXBlID0gdm9pZCAwO1xuICAgIHZhciB2aWRlb1NyYyA9IHZvaWQgMDtcbiAgICB2YXIgdGVtcEltYWdlID0gdm9pZCAwO1xuICAgIHZhciBhZyA9IHZvaWQgMDtcblxuICAgIGlmIChlcnJvck9iai5lcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JPYmopO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0VsZW1lbnQoZXhpc3RpbmdWaWRlbykgJiYgZXhpc3RpbmdWaWRlby5zcmMpIHtcbiAgICAgICAgdmlkZW9TcmMgPSBleGlzdGluZ1ZpZGVvLnNyYztcbiAgICAgICAgdmlkZW9UeXBlID0gdXRpbHMuZ2V0RXh0ZW5zaW9uKHZpZGVvU3JjKTtcblxuICAgICAgICBpZiAoIXV0aWxzLmlzU3VwcG9ydGVkLnZpZGVvQ29kZWNzW3ZpZGVvVHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvci5tZXNzYWdlcy52aWRlb0NvZGVjcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoZXhpc3RpbmdWaWRlbykpIHtcbiAgICAgICAgdXRpbHMuZWFjaChleGlzdGluZ1ZpZGVvLCBmdW5jdGlvbiAoaXRlcmF0b3IsIHZpZGVvU3JjKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9TcmMgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9UeXBlID0gdmlkZW9TcmMudHlwZS5zdWJzdHIodmlkZW9TcmMudHlwZS5sYXN0SW5kZXhPZignLycpICsgMSwgdmlkZW9TcmMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW9UeXBlID0gdmlkZW9TcmMuc3Vic3RyKHZpZGVvU3JjLmxhc3RJbmRleE9mKCcuJykgKyAxLCB2aWRlb1NyYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdXBwb3J0ZWQudmlkZW9Db2RlY3NbdmlkZW9UeXBlXSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmlkZW8gPSB2aWRlb1NyYztcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmlkZW9TdHJlYW0uc3RhcnRTdHJlYW1pbmcoe1xuICAgICAgICBjb21wbGV0ZWQ6IGZ1bmN0aW9uIGNvbXBsZXRlZChvYmopIHtcbiAgICAgICAgICAgIG9iai5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgY3JlYXRlQW5kR2V0R0lGKG9iaiwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBleGlzdGluZ1ZpZGVvOiBleGlzdGluZ1ZpZGVvLFxuICAgICAgICBjcm9zc09yaWdpbjogb3B0aW9ucy5jcm9zc09yaWdpbixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuXG4vKlxuICBleGlzdGluZ1dlYmNhbS5qc1xuICA9PT09PT09PT09PT09PT09PVxuKi9cblxuLyogQ29weXJpZ2h0ICAyMDE3IFlhaG9vIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuLy8gRGVwZW5kZW5jaWVzXG5mdW5jdGlvbiBleGlzdGluZ1dlYmNhbSgpIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvYmouY2FsbGJhY2ssXG4gICAgICAgIGxhc3RDYW1lcmFTdHJlYW0gPSBvYmoubGFzdENhbWVyYVN0cmVhbSxcbiAgICAgICAgb3B0aW9ucyA9IG9iai5vcHRpb25zLFxuICAgICAgICB3ZWJjYW1WaWRlb0VsZW1lbnQgPSBvYmoud2ViY2FtVmlkZW9FbGVtZW50O1xuXG5cbiAgICBpZiAoIWlzV2ViQ2FtR0lGU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLnZhbGlkYXRlKCkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNhdmVkUmVuZGVyaW5nQ29udGV4dHMubGVuZ3RoKSB7XG4gICAgICAgIHNjcmVlblNob3QuZ2V0R0lGKG9wdGlvbnMsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9iaik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2aWRlb1N0cmVhbS5zdGFydFZpZGVvU3RyZWFtaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgb2JqLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGNyZWF0ZUFuZEdldEdJRihvYmosIGNhbGxiYWNrKTtcbiAgICB9LCB7XG4gICAgICAgIGxhc3RDYW1lcmFTdHJlYW06IGxhc3RDYW1lcmFTdHJlYW0sXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgd2ViY2FtVmlkZW9FbGVtZW50OiB3ZWJjYW1WaWRlb0VsZW1lbnQsXG4gICAgICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luXG4gICAgfSk7XG59XG5cbi8qXG4gIGNyZWF0ZUdJRi5qc1xuICA9PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xuZnVuY3Rpb24gY3JlYXRlR0lGKHVzZXJPcHRpb25zLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IHV0aWxzLmlzRnVuY3Rpb24odXNlck9wdGlvbnMpID8gdXNlck9wdGlvbnMgOiBjYWxsYmFjaztcbiAgdXNlck9wdGlvbnMgPSB1dGlscy5pc09iamVjdCh1c2VyT3B0aW9ucykgPyB1c2VyT3B0aW9ucyA6IHt9O1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHV0aWxzLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpIHx8IHt9O1xuICB2YXIgbGFzdENhbWVyYVN0cmVhbSA9IHVzZXJPcHRpb25zLmNhbWVyYVN0cmVhbTtcbiAgdmFyIGltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuICB2YXIgaW1hZ2VzTGVuZ3RoID0gaW1hZ2VzID8gaW1hZ2VzLmxlbmd0aCA6IDA7XG4gIHZhciB2aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gIHZhciB3ZWJjYW1WaWRlb0VsZW1lbnQgPSBvcHRpb25zLndlYmNhbVZpZGVvRWxlbWVudDtcblxuICBvcHRpb25zID0gdXRpbHMubWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAnZ2lmV2lkdGgnOiBNYXRoLmZsb29yKG9wdGlvbnMuZ2lmV2lkdGgpLFxuICAgICdnaWZIZWlnaHQnOiBNYXRoLmZsb29yKG9wdGlvbnMuZ2lmSGVpZ2h0KVxuICB9KTtcblxuICAvLyBJZiB0aGUgdXNlciB3b3VsZCBsaWtlIHRvIGNyZWF0ZSBhIEdJRiBmcm9tIGFuIGV4aXN0aW5nIGltYWdlKHMpXG4gIGlmIChpbWFnZXNMZW5ndGgpIHtcbiAgICBleGlzdGluZ0ltYWdlcyh7XG4gICAgICAnaW1hZ2VzJzogaW1hZ2VzLFxuICAgICAgJ2ltYWdlc0xlbmd0aCc6IGltYWdlc0xlbmd0aCxcbiAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrLFxuICAgICAgJ29wdGlvbnMnOiBvcHRpb25zXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmlkZW8pIHtcbiAgICAvLyBJZiB0aGUgdXNlciB3b3VsZCBsaWtlIHRvIGNyZWF0ZSBhIEdJRiBmcm9tIGFuIGV4aXN0aW5nIEhUTUw1IHZpZGVvXG4gICAgZXhpc3RpbmdWaWRlbyh7XG4gICAgICAnZXhpc3RpbmdWaWRlbyc6IHZpZGVvLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSB1c2VyIHdvdWxkIGxpa2UgdG8gY3JlYXRlIGEgR0lGIGZyb20gYSB3ZWJjYW0gc3RyZWFtXG4gICAgZXhpc3RpbmdXZWJjYW0oe1xuICAgICAgbGFzdENhbWVyYVN0cmVhbTogbGFzdENhbWVyYVN0cmVhbSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIHdlYmNhbVZpZGVvRWxlbWVudDogd2ViY2FtVmlkZW9FbGVtZW50LFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG59XG5cbi8qXG4gIHRha2VTbmFwU2hvdC5qc1xuICA9PT09PT09PT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbmZ1bmN0aW9uIHRha2VTbmFwU2hvdCh1c2VyT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IHV0aWxzLmlzRnVuY3Rpb24odXNlck9wdGlvbnMpID8gdXNlck9wdGlvbnMgOiBjYWxsYmFjaztcbiAgICB1c2VyT3B0aW9ucyA9IHV0aWxzLmlzT2JqZWN0KHVzZXJPcHRpb25zKSA/IHVzZXJPcHRpb25zIDoge307XG5cbiAgICBpZiAoIXV0aWxzLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IHV0aWxzLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgIHZhciBvcHRpb25zID0gdXRpbHMubWVyZ2VPcHRpb25zKG1lcmdlZE9wdGlvbnMsIHtcbiAgICAgICAgJ2ludGVydmFsJzogLjEsXG4gICAgICAgICdudW1GcmFtZXMnOiAxLFxuICAgICAgICAnZ2lmV2lkdGgnOiBNYXRoLmZsb29yKG1lcmdlZE9wdGlvbnMuZ2lmV2lkdGgpLFxuICAgICAgICAnZ2lmSGVpZ2h0JzogTWF0aC5mbG9vcihtZXJnZWRPcHRpb25zLmdpZkhlaWdodClcbiAgICB9KTtcblxuICAgIGNyZWF0ZUdJRihvcHRpb25zLCBjYWxsYmFjayk7XG59XG5cbi8qXG4gIEFQSS5qc1xuICA9PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiovXG5cbi8vIERlcGVuZGVuY2llc1xudmFyIEFQSSA9IHtcbiAgJ3V0aWxzJzogdXRpbHMkMixcbiAgJ2Vycm9yJzogZXJyb3IkMixcbiAgJ2RlZmF1bHRPcHRpb25zJzogZGVmYXVsdE9wdGlvbnMkMixcbiAgJ2NyZWF0ZUdJRic6IGNyZWF0ZUdJRixcbiAgJ3Rha2VTbmFwU2hvdCc6IHRha2VTbmFwU2hvdCxcbiAgJ3N0b3BWaWRlb1N0cmVhbWluZyc6IHN0b3BWaWRlb1N0cmVhbWluZyxcbiAgJ2lzU3VwcG9ydGVkJzogaXNTdXBwb3J0ZWQsXG4gICdpc1dlYkNhbUdJRlN1cHBvcnRlZCc6IGlzV2ViQ2FtR0lGU3VwcG9ydGVkLFxuICAnaXNFeGlzdGluZ1ZpZGVvR0lGU3VwcG9ydGVkJzogaXNFeGlzdGluZ1ZpZGVvR0lGU3VwcG9ydGVkLFxuICAnaXNFeGlzdGluZ0ltYWdlc0dJRlN1cHBvcnRlZCc6IGlzU3VwcG9ydGVkJDEsXG4gICdWRVJTSU9OJzogJzAuNC41J1xufTtcblxuLypcbiAgaW5kZXguanNcbiAgPT09PT09PT1cbiovXG5cbi8qIENvcHlyaWdodCAgMjAxNyBZYWhvbyBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuXG4vLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIGFuZCBwbGFpbiBicm93c2VyIGxvYWRpbmdcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFQSTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBUEk7XG59IGVsc2Uge1xuICAgIHdpbmRvdy5naWZzaG90ID0gQVBJO1xufVxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30sIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogeyBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHt9IH0sIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cubmF2aWdhdG9yIDoge30pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsU0FJQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("var api = __webpack_require__(3);\n            var content = __webpack_require__(4);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zY3JlZW5zL2luZGV4LmNzcz82MmZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(5);\nvar ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(6);\nvar ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(7);\nvar ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(8);\nvar ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(9);\nvar ___CSS_LOADER_URL_IMPORT_3___ = __webpack_require__(10);\nvar ___CSS_LOADER_URL_IMPORT_4___ = __webpack_require__(11);\nvar ___CSS_LOADER_URL_IMPORT_5___ = __webpack_require__(12);\nvar ___CSS_LOADER_URL_IMPORT_6___ = __webpack_require__(13);\nvar ___CSS_LOADER_URL_IMPORT_7___ = __webpack_require__(14);\nvar ___CSS_LOADER_URL_IMPORT_8___ = __webpack_require__(15);\nexports = ___CSS_LOADER_API_IMPORT___(false);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\nvar ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_5___);\nvar ___CSS_LOADER_URL_REPLACEMENT_6___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_6___);\nvar ___CSS_LOADER_URL_REPLACEMENT_7___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_7___);\nvar ___CSS_LOADER_URL_REPLACEMENT_8___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_8___);\n// Module\nexports.push([module.i, "/* @font-face {\\n  font-family: \'NIMBSTB\';\\n  src: url(\'../../fonts/NIMBSTB.ttf\');\\n } */\\n\\n* {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nbody {\\n  width: 90%;\\n  height: 100%;\\n  background-color: black;\\n  display: flex;\\n  justify-content: center;\\n  font-family: Helvetica;\\n  font-weight: 700;\\n  flex-wrap: wrap;\\n}\\n\\n.body-landing {\\n  flex-direction: column;\\n  justify-content: center;\\n  width: 100%;\\n}\\n\\n.main {\\n  width: 90%;\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: flex-start;\\n  padding-top: 50px;\\n}\\n\\n.tools-container {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.resize-set {\\n  display: flex;\\n  justify-content: space-around;\\n  width: 108px;\\n}\\n\\n.size {\\n  height: 20px;\\n  width: 20px;\\n  border: 2px solid #183326;\\n  background-color:#192300;\\n  color: white;\\n  font-size: 15px;\\n  text-align: center;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n}\\n\\n.size:hover {\\n  border: 2px solid white;\\n}\\n\\n.tools-set {\\n  display: flex;\\n  flex-wrap: wrap;\\n  height: auto;\\n  width: 108px;\\n  margin: 10px 0;\\n}\\n\\n.tool {\\n  height: 50px;\\n  width: 50px;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  background-position: center;\\n  background-size: cover;\\n}\\n\\n.tool:hover {\\n  border: 2px solid white;\\n}\\n\\n.page-sizes {\\n  display: flex;\\n  flex-wrap: wrap;\\n  height: auto;\\n  width: 108px;\\n  justify-content: space-around;\\n  margin-bottom: 10px;\\n}\\n\\n.page-s {\\n  height: 50px;\\n  width: 50px;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  color: white;\\n  text-align: center;\\n  line-height: 50px;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n}\\n\\n.page-s:hover, .colors-button:hover {\\n  border: 2px solid white;\\n}\\n\\n.colors-button {\\n  height: 50px;\\n  width: 50px;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  margin-bottom: 10px;\\n}\\n\\n.eraser {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\\n}\\n\\n.pen {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ");\\n}\\n\\n.stroke {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");\\n}\\n\\n.picker {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");\\n}\\n\\n.onecolor {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ");\\n}\\n\\n.bucket {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ");\\n}\\n\\n.frames-container {\\n  display: flex;\\n  flex-direction: column;\\n  width: auto;\\n}\\n\\n.add-frame {\\n  width: 110px;\\n  height: 50px;\\n  color: white;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  border-radius: 2px;\\n  text-align: center;\\n  line-height: 25px;\\n  margin-top: 10px;\\n}\\n\\n.add-frame:hover {\\n  border: 2px solid white;\\n}\\n\\n.frame {\\n  display: flex;\\n  height: auto;\\n  flex-direction: column;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n    margin-bottom: 10px;\\n}\\n\\n\\n.frame-pic {\\n  background-color: white;\\n  width: 110px;\\n  height: 110px;\\n}\\n\\n.frame-but-container {\\n  display: flex;\\n  justify-content: start;\\n  width: 110px;\\n}\\n\\n.frame-number, .copy-frame, .delete-frame {\\n  width: 25px;\\n  height: 25px;\\n  background-color: #192300;\\n  border: 1px solid #183326;\\n}\\n\\n.copy-frame:hover, .delete-frame:hover {\\n  border: 1px solid white;\\n}\\n\\n.frame-number {\\n  color: white;\\n  line-height: 25px;\\n  text-align: center;\\n}\\n\\n.copy-frame {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ");\\n  background-size: contain;\\n}\\n\\n.delete-frame {\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ");\\n  background-size: contain;\\n}\\n\\n.canvas-container {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.canvas {\\n  background-color: white;\\n}\\n\\n.prewiew-block {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  height: auto;\\n  width: auto;\\n}\\n\\n.preview-image {\\n  height: 200px;\\n  width: 200px;\\n  background-color: white;\\n}\\n\\n.preview-image:not(:root):fullscreen {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.preview-image img {\\n  display: block;\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n.preview-image:not(:root):fullscreen img {\\n  width: 100vh;\\n  height: 100vh;\\n  max-width: 100vw;\\n  max-height: 100vw;\\n}\\n\\n.fps-block {\\n  display: flex;\\n  justify-content: space-between;\\n  height: auto;\\n  margin-top: 10px;\\n}\\n\\n\\n.fps-button {\\n  height: 50px;\\n  width: 50px;\\n  border: 2px solid #183326;\\n  background-color: #192300;\\n  color: white;\\n  font-size: 30px;\\n  line-height: 50px;\\n  text-align: center;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n}\\n\\n.fps-button:hover {\\n  border: 2px solid white;\\n}\\n\\n.shortcuts {\\n  height: 50px;\\n  width: 50px;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  background-position: center;\\n  background-size: contain;\\n  background-repeat: no-repeat;\\n  background-image: url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + ");\\n}\\n\\n.shortcuts:hover {\\n  border: 2px solid white;\\n}\\n\\n.keys-instructions {\\n  visibility: hidden;\\n  height: 100vh;\\n  width: 100vw;\\n  background-color: rgba(0, 0, 0, 0.5);\\n  position: fixed;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.keys-box {\\n  height: 80%;\\n  width: 80%;\\n  background-color: black;\\n  border: 8px solid rgb(238, 238, 30);\\n  display: flex;\\n  flex-direction: column;\\n  flex-wrap: wrap;\\n  align-items: baseline;\\n  justify-content: center;\\n}\\n\\n.shortcut-line {\\n  display: flex;\\n  width: auto;\\n  height: auto;\\n  margin: 20px;\\n  align-items: center;\\n}\\n\\n.shortcut-button {\\n  height: 50px;\\n  width: 50px;\\n  background-color: #192300;\\n  border: 2px solid rgb(238, 238, 30);\\n  border-radius: 3px;\\n  color: rgb(238, 238, 30);\\n  text-align: center;\\n  line-height: 50px;\\n  margin: 0 20px 0 20px;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  cursor: pointer;\\n  text-decoration: uppercase;\\n}\\n\\n.shortcut-button:hover {\\n  border: 2px solid white;\\n  border-radius: 5px;\\n  color: white;\\n}\\n\\n\\n.shortcut-description {\\n  color: rgb(238, 238, 30);\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n}\\n\\n.btt {\\n  margin-top: 10px;\\n  height: 50px;\\n  width: 100%;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  color: white;\\n  text-align: center;\\n  line-height: 50px;\\n  font-size: 25px;\\n  font-family: Arial, Helvetica, sans-serif;\\n}\\n\\n.btt:hover, .gif-button:hover, .apng-button:hover {\\n  border: 2px solid white;\\n}\\n\\n.gif-button, .apng-button {\\n  margin-top: 10px;\\n  height: 50px;\\n  width: 100%;\\n  background-color: #192300;\\n  border: 2px solid #183326;\\n  color: white;\\n  text-align: center;\\n  line-height: 50px;\\n  font-size: 25px;\\n  font-family: Arial, Helvetica, sans-serif;\\n}\\n\\n.landing-header {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  width: 100%;\\n  height: 50px;\\n}\\n\\n.header-button {\\n  padding: 0;\\n  margin: 0 10px;\\n  background: initial;\\n  border: 0;\\n  display: flex;\\n  justify-content: center;\\n  background-color: gold;\\n  border-radius: 5px;\\n  height: 25px;\\n}\\n\\n.header-button:hover {\\n  background-color: white;\\n}\\n\\n.create-link {\\n  padding: 5px;\\n  text-decoration: none;\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: black;\\n  font-size: 15px;\\n  font-weight: 700;\\n}\\n\\n.landing-main {\\n  display: flex;\\n  justify-content: space-between;\\n  width: 90%;\\n  margin: 0 50px;\\n  flex-wrap: wrap;\\n}\\n\\n.description-block {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  width: 100%;\\n  margin-top: 30px;\\n  margin-bottom: 30px;\\n}\\n\\n.screenshot {\\n  width: 50%;\\n  height: auto;\\n  padding: 3px;\\n  border: 2px solid grey;\\n}\\n\\n.text-block {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: flex-start;\\n  width: 40%;\\n  margin-top: 40px;\\n}\\n\\n.description-name {\\n  font-size: 35px;\\n  font-weight: 700;\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: white;\\n}\\n\\n.description-text {\\n  font-size: 25px;\\n  font-weight: 400;\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: white;\\n}\\n\\n.example-block {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: flex-start;\\n  width: 70%;\\n  margin: 30px auto;\\n}\\n\\n.example-block-name {\\n  font-size: 25px;\\n  font-weight: 700;\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: white;\\n}\\n\\n.example-block-description {\\n  font-size: 20px;\\n  font-weight: 400;\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: white;\\n}\\n\\n.examples-img-block {\\n  margin-top: 30px;\\n  display: flex;\\n  justify-content: space-around;\\n}\\n\\n.functionality-block {\\n  display: flex;\\n  justify-content: space-around;\\n  width: 100%;\\n  margin-top: 50px;\\n}\\n\\n.first-functionality-block, .second-functionality-block {\\n  display: flex;\\n  flex-direction: column;\\n  width: 40%;\\n}\\n\\n.first-functionality-block {\\n  justify-content: flex-end;\\n}\\n\\n.second-functionality-block {\\n  justify-content: flex-start;\\n}\\n\\n.block1 {\\n  display: flex;\\n  margin: 20px 0;\\n}\\n\\n.block1 img {\\n  border: 3px solid grey;\\n  margin: 0 10px;\\n  padding: 5px;\\n}\\n\\n.functionality-description {\\n  color: white;\\n  width: 80%;\\n  font-family: Arial, Helvetica, sans-serif;\\n}\\n\\n.key {\\n  background-color: white;\\n}\\n\\n.about-section {\\n  width: 100%;\\n  background-color: white;\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: center;\\n  margin-top: 40px;\\n}\\n\\n.about-text {\\n  font-size: 25px;\\n  font-weight: 700;\\n  font-family: Arial, Helvetica, sans-serif;\\n}\\n\\n.vk-login {\\n  margin-top: 60px;\\n  position: relative;\\n  left: -38%;\\n  background-color: white;\\n}", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zY3JlZW5zL2luZGV4LmNzcz9kOTVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSByZXF1aXJlKFwiLi4vaW1nL3Rvb2wtZXJhc2VyLnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IHJlcXVpcmUoXCIuLi9pbWcvdG9vbC1wZW4ucG5nXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8yX19fID0gcmVxdWlyZShcIi4uL2ltZy90b29sLXN0cm9rZS5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzNfX18gPSByZXF1aXJlKFwiLi4vaW1nL3Rvb2wtY29sb3JwaWNrZXIucG5nXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF80X19fID0gcmVxdWlyZShcIi4uL2ltZy90b29sLWNvbG9yc3dhcC5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzVfX18gPSByZXF1aXJlKFwiLi4vaW1nL3Rvb2wtcGFpbnQtYnVja2V0LnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNl9fXyA9IHJlcXVpcmUoXCIuLi9pbWcvZnJhbWUtZHVwbGljYXRlLnBuZ1wiKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfN19fXyA9IHJlcXVpcmUoXCIuLi9pbWcvZnJhbWUtcmVjeWNsZWJpbi5wbmdcIik7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzhfX18gPSByZXF1aXJlKFwiLi4vaW1nL2NvbW1vbi1rZXlib2FyZC1nb2xkLnBuZ1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzNfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8zX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF80X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfNV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzVfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzZfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF82X19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF83X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfN19fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfOF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzhfX18pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBAZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnTklNQlNUQic7XFxuICBzcmM6IHVybCgnLi4vLi4vZm9udHMvTklNQlNUQi50dGYnKTtcXG4gfSAqL1xcblxcbioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuYm9keSB7XFxuICB3aWR0aDogOTAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBmb250LWZhbWlseTogSGVsdmV0aWNhO1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuXFxuLmJvZHktbGFuZGluZyB7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLm1haW4ge1xcbiAgd2lkdGg6IDkwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gIHBhZGRpbmctdG9wOiA1MHB4O1xcbn1cXG5cXG4udG9vbHMtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4ucmVzaXplLXNldCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB3aWR0aDogMTA4cHg7XFxufVxcblxcbi5zaXplIHtcXG4gIGhlaWdodDogMjBweDtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgYm9yZGVyOiAycHggc29saWQgIzE4MzMyNjtcXG4gIGJhY2tncm91bmQtY29sb3I6IzE5MjMwMDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4uc2l6ZTpob3ZlciB7XFxuICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLnRvb2xzLXNldCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgd2lkdGg6IDEwOHB4O1xcbiAgbWFyZ2luOiAxMHB4IDA7XFxufVxcblxcbi50b29sIHtcXG4gIGhlaWdodDogNTBweDtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzE5MjMwMDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxODMzMjY7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbn1cXG5cXG4udG9vbDpob3ZlciB7XFxuICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLnBhZ2Utc2l6ZXMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG4gIGhlaWdodDogYXV0bztcXG4gIHdpZHRoOiAxMDhweDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG59XFxuXFxuLnBhZ2UtcyB7XFxuICBoZWlnaHQ6IDUwcHg7XFxuICB3aWR0aDogNTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxOTIzMDA7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjMTgzMzI2O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbGluZS1oZWlnaHQ6IDUwcHg7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnBhZ2Utczpob3ZlciwgLmNvbG9ycy1idXR0b246aG92ZXIge1xcbiAgYm9yZGVyOiAycHggc29saWQgd2hpdGU7XFxufVxcblxcbi5jb2xvcnMtYnV0dG9uIHtcXG4gIGhlaWdodDogNTBweDtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzE5MjMwMDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxODMzMjY7XFxuICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbn1cXG5cXG4uZXJhc2VyIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gKyBcIik7XFxufVxcblxcbi5wZW4ge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fXyArIFwiKTtcXG59XFxuXFxuLnN0cm9rZSB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fICsgXCIpO1xcbn1cXG5cXG4ucGlja2VyIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzNfX18gKyBcIik7XFxufVxcblxcbi5vbmVjb2xvciB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF80X19fICsgXCIpO1xcbn1cXG5cXG4uYnVja2V0IHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzVfX18gKyBcIik7XFxufVxcblxcbi5mcmFtZXMtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgd2lkdGg6IGF1dG87XFxufVxcblxcbi5hZGQtZnJhbWUge1xcbiAgd2lkdGg6IDExMHB4O1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzE5MjMwMDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxODMzMjY7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xcbiAgbWFyZ2luLXRvcDogMTBweDtcXG59XFxuXFxuLmFkZC1mcmFtZTpob3ZlciB7XFxuICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLmZyYW1lIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IGF1dG87XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxufVxcblxcblxcbi5mcmFtZS1waWMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICB3aWR0aDogMTEwcHg7XFxuICBoZWlnaHQ6IDExMHB4O1xcbn1cXG5cXG4uZnJhbWUtYnV0LWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzdGFydDtcXG4gIHdpZHRoOiAxMTBweDtcXG59XFxuXFxuLmZyYW1lLW51bWJlciwgLmNvcHktZnJhbWUsIC5kZWxldGUtZnJhbWUge1xcbiAgd2lkdGg6IDI1cHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTkyMzAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzE4MzMyNjtcXG59XFxuXFxuLmNvcHktZnJhbWU6aG92ZXIsIC5kZWxldGUtZnJhbWU6aG92ZXIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgd2hpdGU7XFxufVxcblxcbi5mcmFtZS1udW1iZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5jb3B5LWZyYW1lIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzZfX18gKyBcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxufVxcblxcbi5kZWxldGUtZnJhbWUge1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfN19fXyArIFwiKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG59XFxuXFxuLmNhbnZhcy1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmNhbnZhcyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLnByZXdpZXctYmxvY2sge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGhlaWdodDogYXV0bztcXG4gIHdpZHRoOiBhdXRvO1xcbn1cXG5cXG4ucHJldmlldy1pbWFnZSB7XFxuICBoZWlnaHQ6IDIwMHB4O1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcblxcbi5wcmV2aWV3LWltYWdlOm5vdCg6cm9vdCk6ZnVsbHNjcmVlbiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4ucHJldmlldy1pbWFnZSBpbWcge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnByZXZpZXctaW1hZ2U6bm90KDpyb290KTpmdWxsc2NyZWVuIGltZyB7XFxuICB3aWR0aDogMTAwdmg7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG4gIG1heC1oZWlnaHQ6IDEwMHZ3O1xcbn1cXG5cXG4uZnBzLWJsb2NrIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBoZWlnaHQ6IGF1dG87XFxuICBtYXJnaW4tdG9wOiAxMHB4O1xcbn1cXG5cXG5cXG4uZnBzLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IDUwcHg7XFxuICB3aWR0aDogNTBweDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMxODMzMjY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTkyMzAwO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDUwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLmZwcy1idXR0b246aG92ZXIge1xcbiAgYm9yZGVyOiAycHggc29saWQgd2hpdGU7XFxufVxcblxcbi5zaG9ydGN1dHMge1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgd2lkdGg6IDUwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTkyMzAwO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzE4MzMyNjtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF84X19fICsgXCIpO1xcbn1cXG5cXG4uc2hvcnRjdXRzOmhvdmVyIHtcXG4gIGJvcmRlcjogMnB4IHNvbGlkIHdoaXRlO1xcbn1cXG5cXG4ua2V5cy1pbnN0cnVjdGlvbnMge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG4gIHdpZHRoOiAxMDB2dztcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5rZXlzLWJveCB7XFxuICBoZWlnaHQ6IDgwJTtcXG4gIHdpZHRoOiA4MCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gIGJvcmRlcjogOHB4IHNvbGlkIHJnYigyMzgsIDIzOCwgMzApO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuLnNob3J0Y3V0LWxpbmUge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbWFyZ2luOiAyMHB4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnNob3J0Y3V0LWJ1dHRvbiB7XFxuICBoZWlnaHQ6IDUwcHg7XFxuICB3aWR0aDogNTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxOTIzMDA7XFxuICBib3JkZXI6IDJweCBzb2xpZCByZ2IoMjM4LCAyMzgsIDMwKTtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGNvbG9yOiByZ2IoMjM4LCAyMzgsIDMwKTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiA1MHB4O1xcbiAgbWFyZ2luOiAwIDIwcHggMCAyMHB4O1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0ZXh0LWRlY29yYXRpb246IHVwcGVyY2FzZTtcXG59XFxuXFxuLnNob3J0Y3V0LWJ1dHRvbjpob3ZlciB7XFxuICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuXFxuLnNob3J0Y3V0LWRlc2NyaXB0aW9uIHtcXG4gIGNvbG9yOiByZ2IoMjM4LCAyMzgsIDMwKTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4uYnR0IHtcXG4gIG1hcmdpbi10b3A6IDEwcHg7XFxuICBoZWlnaHQ6IDUwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxOTIzMDA7XFxuICBib3JkZXI6IDJweCBzb2xpZCAjMTgzMzI2O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbGluZS1oZWlnaHQ6IDUwcHg7XFxuICBmb250LXNpemU6IDI1cHg7XFxuICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXG59XFxuXFxuLmJ0dDpob3ZlciwgLmdpZi1idXR0b246aG92ZXIsIC5hcG5nLWJ1dHRvbjpob3ZlciB7XFxuICBib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcXG59XFxuXFxuLmdpZi1idXR0b24sIC5hcG5nLWJ1dHRvbiB7XFxuICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTkyMzAwO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzE4MzMyNjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGxpbmUtaGVpZ2h0OiA1MHB4O1xcbiAgZm9udC1zaXplOiAyNXB4O1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxufVxcblxcbi5sYW5kaW5nLWhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogNTBweDtcXG59XFxuXFxuLmhlYWRlci1idXR0b24ge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMCAxMHB4O1xcbiAgYmFja2dyb3VuZDogaW5pdGlhbDtcXG4gIGJvcmRlcjogMDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6IGdvbGQ7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBoZWlnaHQ6IDI1cHg7XFxufVxcblxcbi5oZWFkZXItYnV0dG9uOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4uY3JlYXRlLWxpbmsge1xcbiAgcGFkZGluZzogNXB4O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBjb2xvcjogYmxhY2s7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4ubGFuZGluZy1tYWluIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB3aWR0aDogOTAlO1xcbiAgbWFyZ2luOiAwIDUwcHg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxufVxcblxcbi5kZXNjcmlwdGlvbi1ibG9jayB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLXRvcDogMzBweDtcXG4gIG1hcmdpbi1ib3R0b206IDMwcHg7XFxufVxcblxcbi5zY3JlZW5zaG90IHtcXG4gIHdpZHRoOiA1MCU7XFxuICBoZWlnaHQ6IGF1dG87XFxuICBwYWRkaW5nOiAzcHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCBncmV5O1xcbn1cXG5cXG4udGV4dC1ibG9jayB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIHdpZHRoOiA0MCU7XFxuICBtYXJnaW4tdG9wOiA0MHB4O1xcbn1cXG5cXG4uZGVzY3JpcHRpb24tbmFtZSB7XFxuICBmb250LXNpemU6IDM1cHg7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5kZXNjcmlwdGlvbi10ZXh0IHtcXG4gIGZvbnQtc2l6ZTogMjVweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLmV4YW1wbGUtYmxvY2sge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB3aWR0aDogNzAlO1xcbiAgbWFyZ2luOiAzMHB4IGF1dG87XFxufVxcblxcbi5leGFtcGxlLWJsb2NrLW5hbWUge1xcbiAgZm9udC1zaXplOiAyNXB4O1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4uZXhhbXBsZS1ibG9jay1kZXNjcmlwdGlvbiB7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5leGFtcGxlcy1pbWctYmxvY2sge1xcbiAgbWFyZ2luLXRvcDogMzBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG59XFxuXFxuLmZ1bmN0aW9uYWxpdHktYmxvY2sge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tdG9wOiA1MHB4O1xcbn1cXG5cXG4uZmlyc3QtZnVuY3Rpb25hbGl0eS1ibG9jaywgLnNlY29uZC1mdW5jdGlvbmFsaXR5LWJsb2NrIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgd2lkdGg6IDQwJTtcXG59XFxuXFxuLmZpcnN0LWZ1bmN0aW9uYWxpdHktYmxvY2sge1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG59XFxuXFxuLnNlY29uZC1mdW5jdGlvbmFsaXR5LWJsb2NrIHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG59XFxuXFxuLmJsb2NrMSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWFyZ2luOiAyMHB4IDA7XFxufVxcblxcbi5ibG9jazEgaW1nIHtcXG4gIGJvcmRlcjogM3B4IHNvbGlkIGdyZXk7XFxuICBtYXJnaW46IDAgMTBweDtcXG4gIHBhZGRpbmc6IDVweDtcXG59XFxuXFxuLmZ1bmN0aW9uYWxpdHktZGVzY3JpcHRpb24ge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgd2lkdGg6IDgwJTtcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4ua2V5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4uYWJvdXQtc2VjdGlvbiB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogNDBweDtcXG59XFxuXFxuLmFib3V0LXRleHQge1xcbiAgZm9udC1zaXplOiAyNXB4O1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGZvbnQtZmFtaWx5OiBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4udmstbG9naW4ge1xcbiAgbWFyZ2luLXRvcDogNjBweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC0zOCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || \'\').concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, \'\\\\n\'), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanM/MWRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXBhcmFtLXJlYXNzaWduXG5cblxuICB1cmwgPSB1cmwgJiYgdXJsLl9fZXNNb2R1bGUgPyB1cmwuZGVmYXVsdCA6IHVybDtcblxuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuXG5cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBvcHRpb25zLm5lZWRRdW90ZXMpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLCBcIlxcXCJcIik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGJSURBVGiB7di7SsRAGIbhL1ZZRZStrKw8XYi9iKWFt7Bg4wUIq65i5QV4Fx5vQTstbF0FCxUEFRVeCxNcImQzh0wQ5oOBkMP8T36GECYB9B8z0jTANhEeOhEeOhEeOhEeOhE+JKmkxOeEdcNTST1J95KuJK16mxmoa6TAEX/T8TF/aLQ3fF3o4xK0F3xTaGe8b/SJAdoJ3zTaGu8D3XJEW+F9oE+zwi8e8Gsh4IPoW2AG2HKE3wBJnfAWcJYV6wOzA9e2HeBvwHhd8DJ0PnYs4YdVHTbo86zIHTBXcm/PEH0BtOuAjxbQ8xWe2a0DbQo/yIo8AQsGz+35RpvAx/j93G2aFinBW6GByv/j75Kes+O2xd/zuqT9wrlLSYuSHi3mM1oqnaxLn8CKRZem+FlmTp02XSr56GaFP4BlQ/S1L7QNvIhfagINKAGr/fGupA1JX5L6Q+6dlDQh1zVdjMNb552vEm+ddu14nmlV2yl4kPTqUqgYV3hjiTtZoRPhoRPhoRPhoRPhofMN2dkzTVxoIWcAAAAASUVORK5CYII=");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbWcvdG9vbC1lcmFzZXIucG5nPzcwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUM0QUFBQXVDQVlBQUFCWHVTczNBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFHSlNVUkJWR2lCN2RpN1NzUkFHSWJoTDFaWlJaU3RyS3c4WFlpOWlLV0Z0N0JnNHdVSXE2NWk1UVY0Rng1dlFUc3RiRjBGQ3hVRUZSVmVDeE5jSW1Remgwd1E1b09Ca01QOFQzNkdFQ1lCOUI4ejBqVEFOaEVlT2hFZU9oRWVPaEVlT2hFK0pLbWt4T2VFZGNOVFNUMUo5NUt1SksxNm14bW9hNlRBRVgvVDhURi9hTFEzZkYzbzR4SzBGM3hUYUdlOGIvU0pBZG9KM3pUYUd1OEQzWEpFVytGOW9FK3p3aThlOEdzaDRJUG9XMkFHMkhLRTN3QkpuZkFXY0pZVjZ3T3pBOWUySGVCdndIaGQ4REowUG5ZczRZZFZIVGJvODZ6SUhUQlhjbS9QRUgwQnRPdUFqeGJROHhXZTJhMERiUW8veUlvOEFRc0d6KzM1UnB2QXgvajkzRzJhRmluQlc2R0J5di9qNzVLZXMrTzJ4ZC96dXFUOXdybExTWXVTSGkzbU0xb3FuYXhMbjhDS1JaZW0rRmxtVHAwMlhTcjU2R2FGUDRCbFEvUzFMN1FOdkloZmFnSU5LQUdyL2ZHdXBBMUpYNUw2USs2ZGxEUWgxelZkak1OYjU1MnZFbStkZHUxNG5tbFYyeWw0a1BUcVVxZ1lWM2hqaVR0Wm9SUGhvUlBob1JQaG9SUGhvZk1OMmRrelRWeG9JV2NBQUFBQVNVVk9SSzVDWUlJPVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIbSURBVGiB7ZlBSFVBFIb/ZxaFSJAQKUFGWCFYiLkpELdFoC2K1uKyhes2EbRrJbgpKIiKWgS5cFHhQmnVQgneokAxwlAQo3BRaeXXYgZ6zm7m3pn3hPlhmHvnZ879OJw7M9xbAbQb1VRvgFBl8NTK4KmVwVMrg6dWBg9Ue+jEeoH3S5qWtCJpWdIV7whA6nYR+GHbH/7rsk+c1NDXgC1gBjgGtAOTFny+UcGHbIbfAPtrxi9Y8E8+8VLV+KCk55LeShqS9KvG67b9Ha+ICTLdB2wAc0Cr450FvgEvgKZGKpVTwBqwABx2vHPAV+A1sM83dkzoo8BnYAU47ngDwHdgFmgJiR8LugP4aOHOON4w8BN4BRwIfUasTC9Y6POON4pZWV4SUB4xwTuBJUxd9zreTYyeAs1Fn1Um9AlMTS8Dpx3vroW+j+fqERv8JPAFWLRZr/VuWejxEpNUCng3sApUgSOON2ahJ8qELgO8B1PPVeCQ440A28A9oNJI4L3AOuaM0eF4VzGrx8MY0EXA+zFb9RrQ5XiXMCfAx5T0IpYJ/gRz/uhzxq9b6GfAnljQRcDfY3a/gzVjN4C/mANT4XU6BngnsInRB8xOedveTwJ7Y0OHgo+zU9u2n6LgNu7TKuD9YX9dUpu9rkqatf0jSZu+wULVHDDnnaTfkh5ImpJUl18aIRlvCNX7g1CwMnhqZfDUyuCplcFTa9eC/wNc8p+RvgV2qQAAAABJRU5ErkJggg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbWcvdG9vbC1wZW4ucG5nP2FlNTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUM0QUFBQXVDQVlBQUFCWHVTczNBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFJYlNVUkJWR2lCN1psQlNGVkJGSWIvWnhhRlNKQVFLVUZHV0NGWWlMa3BFTGRGb0MySzF1S3loZXMyRWJSckpiZ3BLSWlLV2dTNWNGSGhRbW5WUWduZW9rQXh3bEFRbzNCUmFlWFhZZ1o2em03bTNwbjNoUGxobUh2blo4NzlPSnc3TTl4YkFiUWIxVlJ2Z0ZCbDhOVEs0S21Wd1ZNcmc2ZFdCZzlVZStqRWVvSDNTNXFXdENKcFdkSVY3d2hBNm5ZUitHSGJILzdyc2srYzFORFhnQzFnQmpnR3RBT1RGbnkrVWNHSGJJYmZBUHRyeGk5WThFOCs4VkxWK0tDazU1TGVTaHFTOUt2RzY3YjlIYStJQ1RMZEIyd0FjMENyNDUwRnZnRXZnS1pHS3BWVHdCcXdBQngydkhQQVYrQTFzTTgzZGt6b284Qm5ZQVU0N25nRHdIZGdGbWdKaVI4THVnUDRhT0hPT040dzhCTjRCUndJZlVhc1RDOVk2UE9PTjRwWldWNFNVQjR4d1R1QkpVeGQ5enJlVFl5ZUFzMUZuMVVtOUFsTVRTOERweDN2cm9XK2orZnFFUnY4SlBBRldMUlpyL1Z1V2VqeEVwTlVDbmczc0FwVWdTT09OMmFoSjhxRUxnTzhCMVBQVmVDUTQ0MEEyOEE5b05KSTRMM0FPdWFNMGVGNFZ6R3J4OE1ZMEVYQSt6RmI5UnJRNVhpWE1DZkF4NVQwSXBZSi9nUnovdWh6eHE5YjZHZkFubGpRUmNEZlkzYS9nelZqTjRDL21BTlQ0WFU2Qm5nbnNJblJCOHhPZWR2ZVR3SjdZME9IZ28relU5dTJuNkxnTnU3VEt1RDlZWDlkVXB1OXJrcWF0ZjBqU1p1K3dVTFZIRERubmFUZmtoNUltcEpVbDE4YUlSbHZDTlg3ZzFDd01uaHFaZkRVeXVDcGxjRlRhOWVDL3dOYzhwK1J2Z1YycVFBQUFBQkpSVTVFcmtKZ2dnPT1cIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKfSURBVGiB7ZhNiE5RGMd/72B8hlAWjI0sWGAokRJCycL3irGRzexkbysWVizIikJCYqFEPtLka0HCxsdCYjNCBmPwszhHrmsM9773vWPq/ut2bs//fZ/ze5/z3Ld7Tk1lIKqpvwHyqgIvWxV42arAy1YFXrb6A7wJaAP2ApNyZ1HLvCaqt/ypT+rOPLlqJb6rTAYuAdOAXcBEYBMwJMaeZcpWUqUnq09jhTcm4gdj5fdkzTm44Kr2pvHABWAMsAy4nvAexPFK5qwNrvQo9ab6Vm1NeS1qp3omT+5GQjerF9SP6uKUN0V9ol5Vh/9P4E3qCfWLuiblTVWfqXfU0XnnaAR0TT1g0NaU16q+UjvUsfXM04hKH4rQO1LeEkOvXzb0fl1zFQk9SD2sflPbU94Gw1/heXP2dKPAB6vHDD29JeVtU7+qpw0PbCFzFpFkiHpK7VbXpbzNcQWOxh9X2ArXm6BZPat2qStS3hq1Rz1uaKPCoOsFH2bo2Q/qopS33NDTJ4uudL3gI9SLsaKrUt7CuAJnDG1UOHRe8JHqFUPvtqW8ueob9ZwFPohFgS81aHsqvkR9Z2ifoY2EVnPtgMbF8WUith44D9wA1gLdOfJmUp7X2vY47ga+ABOA/cBVYDXwKUfOUcBMYFa8ZgPz+/pC1h3QPOBmL/FrwErgwz/kaIlgScipQC36XcB9YEFfSbJWfE7i/jawj9AyHfwO3QzMSMD9AB2X+MwL4C5wIo73gMfAt7+BZK34ImBunORyIj6BXys4C5hO2E8C9ACPEnA/xs4sk9cD3kTY2KYhk8cMr1Nw94CHwOe8kL0pK3gXMCLeS1jWNOTzIgH/pKw9foSfkPeB94UT/aPKPFcpVNXZYdmqwMtWBV62KvCyNWDBvwN7GpxnJ3i6bwAAAABJRU5ErkJggg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbWcvdG9vbC1zdHJva2UucG5nP2RkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUM0QUFBQXVDQVlBQUFCWHVTczNBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFLZlNVUkJWR2lCN1poTmlFNVJHTWQvNzJCOGhsQVdqSTBzV0dBb2tSSkN5Y0wzaXJHUnpleGtieXNXVml6SWlrSkNZcUZFUHRMa2EwSEN4c2RDWWpOQ0JtUHdzemhIcm1zTTk3NzN2V1BxL3V0MmJzLy9mWi96ZTUvejNMZDdUazFsSUtxcHZ3SHlxZ0l2V3hWNDJhckF5MVlGWHJiNkE3d0phQVAyQXBOeVoxSEx2Q2FxdC95cFQrck9QTGxxSmI2clRBWXVBZE9BWGNCRVlCTXdKTWFlWmNwV1VxVW5xMDlqaFRjbTRnZGo1ZmRrelRtNDRLcjJwdkhBQldBTXNBeTRudkFleFBGSzVxd05ydlFvOWFiNlZtMU5lUzFxcDNvbVQrNUdRamVyRjlTUDZ1S1VOMFY5b2w1VmgvOVA0RTNxQ2ZXTHVpYmxUVldmcVhmVTBYbm5hQVIwVFQxZzBOYVUxNnErVWp2VXNmWE0wNGhLSDRyUU8xTGVFa092WHpiMGZsMXpGUWs5U0Qyc2ZsUGJVOTRHdzEvaGVYUDJkS1BBQjZ2SEREMjlKZVZ0VTcrcXB3MFBiQ0Z6RnBGa2lIcEs3VmJYcGJ6TmNRV094aDlYMkFyWG02QlpQYXQycVN0UzNocTFSejF1YUtQQ29Pc0ZIMmJvMlEvcW9wUzMzTkRUSjR1dWRMM2dJOVNMc2FLclV0N0N1QUpuREcxVU9IUmU4SkhxRlVQdnRxVzh1ZW9iOVp3RlBvaEZnUzgxYUhzcXZrUjlaMmlmb1kyRVZuUHRnTWJGOFdVaXRoNDREOXdBMWdMZE9mSm1VcDdYMnZZNDdnYStBQk9BL2NCVllEWHdLVWZPVWNCTVlGYThaZ1B6Ky9wQzFoM1FQT0JtTC9GcndFcmd3ei9rYUlsZ1NjaXBRQzM2WGNCOVlFRmZTYkpXZkU3aS9qYXdqOUF5SGZ3TzNRek1TTUQ5QUIyWCtNd0w0QzV3SW83M2dNZkF0NytCWkszNEltQnVuT1J5SWo2Qlh5czRDNWhPMkU4QzlBQ1BFbkEveHM0c2s5Y0Qza1RZMktZaGs4Y01yMU53OTRDSHdPZThrTDBwSzNnWE1DTGVTMWpXTk9UeklnSC9wS3c5Zm9TZmtQZUI5NFVUL2FQS1BGY3BWTlhaWWRtcXdNdFdCVjYyS3ZDeU5XREJ2d043R3B4bkozaTZid0FBQUFCSlJVNUVya0pnZ2c9PVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGwSURBVGiB7dg/S8NAHMbxp7aog3USB0fpJvYluIgggpvg7OLoK3DwBbjq6OZfcNFWRTdddXISRAdRQXdFEb8OSTFNbZNLvUsLeeAI5covn/44jt7lAHVjetIGJE0Gd50M7joZ3HUyuOt0LbyQ0ntHJU1LGpZ0Jakiyey/B+B6LAHv1OcCGDKp4xq9QvPsmdSyvcZnJS0r3pKck1SMXdlid2eAr0A3CzG6Pha3vk34Ygi1G4H/AHo7AS5gLYTbAfJN8KsmtW2iB/B2i3D+wl8A/Z0AD6KfaNz+tgP4Bf/7Ru+wjX4ASkARuA/htwJ44+ECXZsr05hNIJc2vBW6Fzjw595C+HKa8LjoFx9a22020ux4FPowgB4PzJWSov8DHoWuNEG3PWyh+2yi24FHoas20e3A91ugj2yjk8IHgU/gm/qtzBk6KXzex52G0Meu0JDsIDHlP0/854SkM3lnyFdJk5KuE9Q1S4Jfe+539hJ45jdOOl0bOTC+2H+UNBL4fCfvlL4u6eaf+hkZ0+uJvKSqPOytvCXhDBtMko53RLr2JiuDu04Gd50M7joZ3HW6Fv4D1KDRnPFuQfoAAAAASUVORK5CYII=");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3Rvb2wtY29sb3JwaWNrZXIucG5nPzE3MjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUM0QUFBQXVDQVlBQUFCWHVTczNBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFHd1NVUkJWR2lCN2RnL1M4TkFITWJ4cDdhb2czVVNCMGZwSnZZbHVJZ2dncHZnN09Mb0szRHdCYmpxNk9aZmNORldSVGRkZFhJU1JBZFJRWGRGRWI4T1NURk5iWk5MdlVzTGVlQUk1Y292bi80NGp0N2xBSFZqZXRJR0pFMEdkNTBNN2pvWjNIVXl1T3QwTGJ5UTBudEhKVTFMR3BaMEpha2l5ZXkvQitCNkxBSHYxT2NDR0RLcDR4cTlRdlBzbWRTeXZjWm5KUzByM3BLY2sxU01YZGxpZDJlQXIwQTNDekc2UGhhM3ZrMzRZZ2kxRzRIL0FIbzdBUzVnTFlUYkFmSk44S3NtdFcyaUIvQjJpM0Qrd2w4QS9aMEFENktmYU56K3RnUDRCZi83UnUrd2pYNEFTa0FSdUEvaHR3SjQ0K0VDWFpzcjA1aE5JSmMydkJXNkZ6anc1OTVDK0hLYThMam9GeDlhMjIwMjB1eDRGUG93Z0I0UHpKV1NvdjhESG9XdU5FRzNQV3loKzJ5aTI0RkhvYXMyMGUzQTkxdWdqMnlqazhJSGdVL2dtL3F0ekJrNktYemV4NTJHME1ldTBKRHNJREhsUDAvODU0U2tNM2xueUZkSms1S3VFOVExUzRKZmUrNTM5aEo0NWpkT09sMGJPVEMrMkgrVU5CTDRmQ2Z2bEw0dTZlYWYraGtaMCt1SnZLU3FQT3l0dkNYaERCdE1rbzUzUkxyMkppdUR1MDRHZDUwTTdqb1ozSFc2RnY0RDFLRFJuUEZ1UWZvQUFBQUFTVVZPUks1Q1lJST1cIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASuSURBVGiB7ZlbbFRVFIb/oRLLzVGx9kVKoaKpRgMm+tCIiIQaRSFGvMQYTRCr9faoJpiqIWgTjaKh6oMmJioJRtECyoNWm0AiQeMNwaBGBA1qaanhUim1/XxYaztnTmeGmel0DEn/ZOfMWWuftf+z9t5rrX0mAehkxLj/m0CxGCNebowRLzfGiJcbp4yCzYmSLpR0saQqSb2S9knqlPR3qQYpFfFbJN0kI1unzDPZJ+kjSe2SNkjqGcmAiRFmztmSXpQ01+8HJe2S9IPMyxMkJSXVe9+Aw5JWSGqTNFTUyEAx7SzgFWAQQx+wBqjN8cw5QDPwMSlsB2YXw6EY0tOA333gXmAVcHaBNq4HfnUb/wC3jTbxScDXPuDuIghH2xSgzW0dB64ZLeIJYL0PtA+oydBnBrAMeB5bEt8B7wBLgQlZ7K5ym0eBhtEgHgboAs6P6SYDrUA/2XEYeBOYk8H2S96nB9s/JSPeEBn8kpjuCuA31w+5h5uAG4ErgeXAZmw5BBtXxWyMAza5fnUpib/nRp+KyWe6lwA2AhflsHEGsNb7HgMWx/SzgAFs1maUgvhMLOwdJX0aJwM7nMh691o+9lb4zAwAi2K6sGTeKgXxZje2NiYPa/4zhm+8Ciw+Z9rAAlr82W+xTR/k1cAhLC+MmHiY3qaYPHh7bkx+J3CQFHYBD8f6VAI/uz7u9YYMsqKI/+gD1EdktS77k/QlcnOEcBdwIHLfErN7g8u35MFhWMunrE36tT8ia/Trxlit0erXpyXVSDpX0t2SWiQdkjQ10rdd0hFJl8tqmcKQx9v1uWeiNUWTy56LyCqw9H0ESLqHQwgMOA58SSr6dLp8QaEeL6SsnRL5fcCv1VEfSPpAVhkukvSkpPclrZN0mqQzJS2XNEdSh6QFkrZLmqf0mSiZx79yr0Q3TEhI32R5phMrosZHZPdjYbADi9VdwHxgJ3DvaKzx7/06PSLbJukn2cHh6gzPDEnqljTg9w9KWiPpDUkLZYeOpKS3JT0gaX+hDs/n7W517+6Iye9x+efAxJjuVSw7LgTqsLr7NdIj0GL3fDeZ65cRh8MKYI+TbIzIT8ViNMA20rPqVOALLONuAR4HrsVq+ajtQP4g8CxwHXlm4Hzf8CEnuDkmr8ZKV4A/sPq60V82ZNxe0vEXsBV4GSvCAvmATzO8YNHEJ2HF1BBwaUxXBXzoOrA6vMq9uM49OB2rFp8A3sWS2iC2fKKeD9jrThkxcQEr3Wg3w0tbYWv5GeAC4HXssJHMYW987H4J6WgvFfFKbL2CTf9lWfrVuPfvK8B2glRlGDDE8APLf62QL1nHJC2RtFvS6bJvJPMz9KuUlJB0Xp52E7LPFM2y0qBVFkYTsoSVGQV4JRoxOiKe2YQlpGg06HSPLSvA049G5CEEZ63LiyEuLGqsxOqSgB5s460Gbgd+OQH5bKSDbj+wodTEQ6vCDsl7SUc/dtbMRj4X6dA+Ib2IKynxaKsD7gDuwg4TS7FjXyAf6pFpTgrgkRz22rCENOrEs7VaUpl3D7a8dgLzTvBcfS79SD965oukpMckzZK0VdILShVgRaFcxEuOk/YfiTHi5cYY8XLjX516Jj06SbNcAAAAAElFTkSuQmCC");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3Rvb2wtY29sb3Jzd2FwLnBuZz85MDFhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDNEFBQUF1Q0FZQUFBQlh1U3MzQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFHN0FBQUJ1d0JIblU0TlFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBU3VTVVJCVkdpQjdabGJiRlJWRkliL29STEx6Vkd4OWtWS29hS3BSZ01tK3RDSWlJUWFSU0ZHdk1RWVRSQ3I5ZmFvSnBpcUlXZ1RqYUtoNm9NbUppb0pSdEVDeW9OV20wQWlRZU1Od2FCR0JBMXFhYW5oVWltMS9YeFlhenRuVG1lR21lbDBERW4vWk9mTVdXdWZ0Zit6OXQ1cnJYMG1BZWhreExqL20wQ3hHQ05lYm93Ukx6ZkdpSmNicDR5Q3pZbVNMcFIwc2FRcVNiMlM5a25xbFBSM3FRWXBGZkZiSk4wa0kxdW56RFBaSitralNlMlNOa2pxR2NtQWlSRm16dG1TWHBRMDErOEhKZTJTOUlQTXl4TWtKU1hWZTkrQXc1SldTR3FUTkZUVXlFQXg3U3pnRldBUVF4K3dCcWpOOGN3NVFEUHdNU2xzQjJZWHc2RVkwdE9BMzMzZ1htQVZjSGFCTnE0SGZuVWIvd0MzalRieFNjRFhQdUR1SWdoSDJ4U2d6VzBkQjY0WkxlSUpZTDBQdEErb3lkQm5CckFNZUI1YkV0OEI3d0JMZ1FsWjdLNXltMGVCaHRFZ0hnYm9BczZQNlNZRHJVQS8yWEVZZUJPWWs4SDJTOTZuQjlzL0pTUGVFQm44a3BqdUN1QTMxdys1aDV1QUc0RXJnZVhBWm13NUJCdFh4V3lNQXphNWZuVXBpYi9uUnArS3lXZTZsd0EyQWhmbHNIRUdzTmI3SGdNV3gvU3pnQUZzMW1hVWd2aE1MT3dkSlgwYUp3TTduTWg2OTFvKzlsYjR6QXdBaTJLNnNHVGVLZ1h4WmplMk5pWVBhLzR6aG0rOENpdytaOXJBQWxyODJXK3hUUi9rMWNBaExDK01tSGlZM3FhWVBIaDdia3grSjNDUUZIWUJEOGY2VkFJL3V6N3U5WVlNc3FLSS8rZ0QxRWRrdFM3N2svUWxjbk9FY0Jkd0lITGZFck43Zzh1MzVNRmhXTXVuckUzNnRUOGlhL1RyeGxpdDBlclhweVhWU0RwWDB0MlNXaVFka2pRMTByZGQwaEZKbDh0cW1jS1F4OXYxdVdlaU5VV1R5NTZMeUNxdzlIMEVTTHFIUXdnTU9BNThTU3I2ZExwOFFhRWVMNlNzblJMNWZjQ3YxVkVmU1BwQVZoa3VrdlNrcFBjbHJaTjBtcVF6SlMyWE5FZFNoNlFGa3JaTG1xZjBtU2laeDc5eXIwUTNURWhJMzJSNXBoTXJvc1pIWlBkalliQURpOVZkd0h4Z0ozRHZhS3p4Ny8wNlBTTGJKdWtuMmNIaDZnelBERW5xbGpUZzl3OUtXaVBwRFVrTFpZZU9wS1MzSlQwZ2FYK2hEcy9uN1c1MTcrNkl5ZTl4K2VmQXhKanVWU3c3TGdUcXNMcjdOZElqMEdMM2ZEZVo2NWNSaDhNS1lJK1RiSXpJVDhWaU5NQTIwclBxVk9BTExPTnVBUjRIcnNWcSthanRRUDRnOEN4d0hYbG00SHpmOENFbnVEa21yOFpLVjRBL3NQcTYwVjgyWk54ZTB2RVhzQlY0R1N2Q0F2bUFUek84WU5IRUoySEYxQkJ3YVV4WEJYem9PckE2dk1xOXVNNDlPQjJyRnA4QTNzV1MyaUMyZktLZUQ5anJUaGt4Y1FFcjNXZzN3MHRiWVd2NUdlQUM0SFhzc0pITVlXOTg3SDRKNldndkZmRktiTDJDVGY5bFdmclZ1UGZ2SzhCMmdsUmxHRERFOEFQTGY2MlFMMW5ISkMyUnRGdlM2Ykp2SlBNejlLdVVsSkIwWHA1MkU3TFBGTTJ5MHFCVkZrWVRzb1NWR1FWNEpSb3hPaUtlMllRbHBHZzA2SFNQTFN2QTA0OUc1Q0VFWjYzTGl5RXVMR3FzeE9xU2dCNXM0NjBHYmdkK09RSDViS1NEYmord29kVEVRNnZDRHNsN1NVYy9kdGJNUmo0WDZkQStJYjJJS3lueGFLc0Q3Z0R1d2c0VFM3RmpYeUFmNnBGcFRncmdrUnoyMnJDRU5PckVzN1ZhVXBsM0Q3YThkZ0x6VHZCY2ZTNzlTRDk2NW91a3BNY2t6WkswVmRJTFNoVmdSYUZjeEV1T2svWWZpVEhpNWNZWThYTGpYNTE2SmowNlNiTmNBQUFBQUVsRlRrU3VRbUNDXCIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJiSURBVGiB7Zg9aBRBFMf/G+/kDCoiCZJKQW0U0oSksFEETScJiIWNkEZJZ2FjIdY2goWlTVAxJBrFQsUmnB9Y2BgLrUTSHLERJOQL87PYd9xw7q17c7cjB/uHx37Me29+O/tmmN0IUC+q738D+KoAD60CPLQK8NAqwEOrZ8FLHcQOSropaUTSUUnrkmqSliV9lvRSUrVDvtYCfGwEWCFdW8B5z/z/NN/AJwb3EBgC9gGHgTFgPgS8T9AQ8Bv4ZcBu2xSwDawCi3nC+wQdMKCvKdCngTKwkBe8T1AErAObQH8L6LpvbvC+gc8N5hMwCgwD14BTCb5lGnOia/AReH0B7ZK0IOmsXa9IWpT0UdKS2bLjX5b0SNKkpG3zq0p6YOftq4OnniJdP4EqcBe4YCM/3+SzBVwH+trt3xd6FFgjrumTwBHgEnAbeA3UEh7kOFBKgId4WY3yBt8BfLMOL6f4DRDX/DRw0RnVEjCXAH8jb/BJ6+iZR2zddgM/msDXgMGsOXw2WWfseM9rUkkVSXOSBhLuT2dN4gMe2XHMI7aieDUal/RB0glJj532K5kzebzmcXu1m8C5NuIqwAuLfQ/stfsRcN8pmXJeNS6no42M8C70Owe6bgdtIAD25wm+E3iaEd6FfgvsaeG3ZD6ZJqgveFb4fgf6TQq0LNf3rP13Ap4EP+G0jQBfrK1KvASm5boFzIQCb4aHeDc4Q6NmZ2nsItNsAjgUErwOf4f4A6OuGnC1S/n/Mt/dYSsNSzomaVXSK0kb3UzuqtvgwdSz/1UK8NAqwEOrAA+tAjy0CvDQ6lnwPy+a0sePrkNaAAAAAElFTkSuQmCC");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3Rvb2wtcGFpbnQtYnVja2V0LnBuZz8xMjFhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDNEFBQUF1Q0FZQUFBQlh1U3MzQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFHN0FBQUJ1d0JIblU0TlFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBSmlTVVJCVkdpQjdaZzlhQlJCRk1mL0crL2tEQ29pQ1pKS1FXMFUwb1Nrc0ZFRVRTY0ppSVdOa0VaSloyRmpJZFkyZ29XbFRWQXhKQnJGUXNVbW5COVkyQmdMclVUU0hMRVJKT1FMODdQWWQ5eHc3cTE3YzdjakIvdUh4MzdNZTI5K08vdG1tTjBJVUMrcTczOEQrS29BRDYwQ1BMUUs4TkFxd0VPclo4RkxIY1FPU3JvcGFVVFNVVW5ya21xU2xpVjlsdlJTVXJWRHZ0WUNmR3dFV0NGZFc4QjV6L3ovTk4vQUp3YjNFQmdDOWdHSGdURmdQZ1M4VDlBUThCdjRaY0J1MnhTd0Rhd0NpM25DK3dRZE1LQ3ZLZENuZ1RLd2tCZThUMUFFckFPYlFIOEw2THB2YnZDK2djOE41aE13Q2d3RDE0QlRDYjVsR25PaWEvQVJlSDBCN1pLMElPbXNYYTlJV3BUMFVkS1MyYkxqWDViMFNOS2twRzN6cTBwNllPZnRxNE9ubmlKZFA0RXFjQmU0WUNNLzMrU3pCVndIK3RydDN4ZDZGRmdqcnVtVHdCSGdFbkFiZUEzVUVoN2tPRkJLZ0lkNFdZM3lCdDhCZkxNT0w2ZjREUkRYL0RSdzBSblZFakNYQUg4amIvQko2K2laUjJ6ZGRnTS9tc0RYZ01Hc09YdzJXV2ZzZU05clVra1ZTWE9TQmhMdVQyZE40Z01lMlhITUk3YWllRFVhbC9SQjBnbEpqNTMySzVremViem1jWHUxbThDNU51SXF3QXVMZlEvc3Rmc1JjTjhwbVhKZU5TNm5vNDJNOEM3ME93ZTZiZ2R0SUFEMjV3bStFM2lhRWQ2RmZndnNhZUczWkQ2WkpxZ3ZlRmI0ZmdmNlRRcTBMTmYzclAxM0FwNEVQK0cwalFCZnJLMUt2QVNtNWJvRnpJUUNiNGFIZURjNFE2Tm1aMm5zSXROc0FqZ1VFcndPZjRmNEE2T3VHbkMxUy9uL010L2RZU3NOU3pvbWFWWFNLMGtiM1V6dXF0dmd3ZFN6LzFVSzhOQXF3RU9yQUErdEFqeTBDdkRRNmxud1B5K2Ewc2VQcmtOYUFBQUFBRWxGVGtTdVFtQ0NcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAG64AABuuAYxdc/gAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAAPJJREFUSEvtj4EOgkAMQ/lG/9qvOtdmMKy3O2YIxuhLjNKurSyttY98Luc/fBnfN2yhHne3p9jtqcNssq/pH8Cpn9fASI+dNxw3/73hPVZwwxLw55V03Lz5MCv6bMX2m+P+OAWn03MUZrjPP2Df25vv6L616acMg3QcugI5sQKmE8TvjkNTICdWwHSCn7zgNnHpCciJFTB9nPWtN1giQE6sgOkCmmGJADmxAqYLaIYlAuTECpguoBmWCJATK2C6gGZYIkBOrIDpApphiQA5sQKmC3hsCM6mp2wr4LEhOJuesq2Ax4bg7ODpufyHL+NXh9vyAEkaVmBp4cmSAAAAAElFTkSuQmCC");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2ZyYW1lLWR1cGxpY2F0ZS5wbmc/ZTU3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQjRBQUFBZUNBWUFBQUE3TUs2aUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFHNjRBQUJ1dUFZeGRjL2dBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXdNUFJ5b1FBQUFQSkpSRUZVU0V2dGo0RU9na0FNUS9sRy85cXZPdGRtTUt5M08yWUl4dWhMak5LdXJTeXR0WTk4THVjL2ZCbmZOMnloSG5lM3A5anRxY05zc3EvcEg4Q3BuOWZBU0krZE54dzMvNzNoUFZad3d4THc1NVYwM0x6NU1DdjZiTVgybStQK09BV24wM01VWnJqUFAyRGYyNXZ2Nkw2MTZhY01nM1FjdWdJNXNRS21FOFR2amtOVElDZFd3SFNDbjd6Z05uSHBDY2lKRlRCOW5QV3ROMWdpUUU2c2dPa0NtbUdKQURteEFxWUxhSVlsQXVURUNwZ3VvQm1XQ0pBVEsyQzZnR1pZSWtCT3JJRHBBcHBoaVFBNXNRS21DM2hzQ002bXAyd3I0TEVoT0p1ZXNxMkF4NGJnN09EcHVmeUhMK05YaDl2eUFFa2FWbUJwNGNtU0FBQUFBRWxGVGtTdVFtQ0NcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAC8SURBVEiJ7ZUxDsIwDEVfEBKdYGGFgUNwA07Zo6BegEMwwNquXc1iLwyJI1pSRCxZseIfPyVRnCAilLBVEWoF/wV4naE9ARf1M7DX+R64AVf1u6uaiKR8IyKt+K3VNdG6HnCXATXrUnXD0hvICIjTxynBvVPn1uaCGyBoHN7iZg7woOM2orHcENFkg20XHvAsR/11sB3fLqKxXLEd1zv+CDz5c/L26gPw8AiBI/BMiYq1zMX/ThVcwb8DfgGTfwBUHn3GmgAAAABJRU5ErkJggg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2ZyYW1lLXJlY3ljbGViaW4ucG5nP2Y2NTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQUc3QUFBQnV3QkhuVTROUUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFDOFNVUkJWRWlKN1pVeERzSXdERVZmRUJLZFlHR0ZnVU53QTA3Wm82QmVnRU13d05xdVhjMWlMd3lKSTFwU1JDeFpzZUlmUHlWUm5DQWlsTEJWRVdvRi93VjRuYUU5QVJmMU03RFgrUjY0QVZmMXU2dWFpS1I4SXlLdCtLM1ZOZEc2SG5DWEFUWHJVblhEMGh2SUNJalR4eW5CdlZQbjF1YUNHeUJvSE43aVpnN3dvT00yb3JIY0VORmtnMjBYSHZBc1IvMTFzQjNmTHFLeFhMRWQxenYrQ0R6NWMvTDI2Z1B3OEFpQkkvQk1pWXExek1YL1RoVmN3YjhEZmdHVGZ3QlVIbjNHbWdBQUFBQkpSVTVFcmtKZ2dnPT1cIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAVCAYAAAAuJkyQAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAG7AAABuwBHnU4NQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADRSURBVEiJ7daxTcNQEIfx3znJFKHG7JDCGzAAW6RhCDdsQZfGG1B4hoTUsARWchRYSJACEIrtIl/3Tq/43t1feheZyXOspDVusTAsHRrhQZlt5M5KesJsYJHvHIRq3ndmhkeFe9f5OqjGPpaOatxJ68itNywUrgaX+Sr1gi5yK8FNBthFfl4coVb862VnYHJCpyMbi6mObH5SGSvUPZPr0OSELqH+ib+H+rdcQn0mJvfbF2jAUW0fy5Fk6v7UTG5jLJTZChU2PvbboemwESpltu8XJn5SDsVyvQAAAABJRU5ErkJggg==");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2NvbW1vbi1rZXlib2FyZC1nb2xkLnBuZz9jOTFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFWQ0FZQUFBQXVKa3lRQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFHN0FBQUJ1d0JIblU0TlFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBRFJTVVJCVkVpSjdkYXhUY05RRUlmeDN6bkpGS0hHN0pEQ0d6QUFXNlJoQ0Rkc1FaZkdHMUI0aG9UVXNBUldjaFJZU0pBQ0VJcnRJbC8zVHEvNDN0MWZlaGVaeVhPc3BEVnVzVEFzSFJyaFFabHQ1TTVLZXNKc1lKSHZISVJxM25kbWhrZUZlOWY1T3FqR1BwYU9hdHhKNjhpdE55d1VyZ2FYK1NyMWdpNXlLOEZOQnRoRmZsNGNvVmI4NjJWbllISkNweU1iaTZtT2JINVNHU3ZVUFpQcjBPU0VMcUgraWIrSCtyZGNRbjBtSnZmYkYyakFVVzBmeTVGazZ2N1VURzVqTEpUWkNoVTJQdmJib2Vtd0VTcGx0dThYSm41U0RzVnl2UUFBQUFCSlJVNUVya0pnZ2c9PVwiIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/@shopify/draggable/lib/draggable.bundle.js\nvar draggable_bundle = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./src/screens/index.css\nvar screens = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/gifshot/dist/gifshot.js\nvar gifshot = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/modules/gif-export.js\n\n\nfunction makeGifExportLink(images, delay, callback) {\n  const options = {\n    images,\n    interval: 1,\n  };\n\n  if (delay !== 0) {\n    options.interval = 1 / delay;\n  }\n\n  Object(gifshot[\"createGIF\"])(options, (result) => {\n    const { error, image } = result;\n\n    if (!error) {\n      callback(image);\n    }\n  });\n}\n\n// CONCATENATED MODULE: ./src/libs/canvas2apng.js\n/* ====================================================================\nMIT License\n\nCanvas2APNG\nEncoder for animated APNG file from a series of Html5 canvas drawings.\nCopyright (c) aug 2017, Arthur Kalverboer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================     */\n\nfunction APNGencoder(iCanvas) {\n   // Generate APNG byte array from a series of canvas images.\n   // See: https://en.wikipedia.org/wiki/APNG\n\n   // To hide this-variables, put them in an object (e.g. variable state)\n   // and replace this and self by state.\n   var self = this;  // !!! copy this to context of object\n   this.whoami = \"apng png animation encoder canvas\";  // keywords to identify\n   this.canvas = iCanvas;  // Canvas element\n   this.repeat = 0;      // number of repeats; 0 indefinitely\n   this.frame = -1;      // frame number (0 is first frame)\n   this.seqNumber = -1;  // Sequence number for fcTL and fdAT chunks\n   this.delay_num = 1;   // Frame delay fraction numerator   (int16, 2 bytes)\n   this.delay_den = 1;   // Frame delay fraction denominator (int16, 2 bytes) 0 == 1/100 sec\n   this.dispose = 0;     // Type of frame area disposal; values 0, 1, 2\n   this.blend = 1;       // Type of frame area rendering: values 0, 1\n\n   this.apngBytes;       // APNG output stream (ByteArray)\n   this.frameBytes;      // Byte stream of current frame image (ByteArray)\n\n   // Flags\n  this.started = false;     // ready to output frames\n  this.closeStream = false; // close stream when finished\n\n  this.start = function() {\n          // Creates APNG output stream on which images are written.\n          this.started = true;\n          this.closeStream = false;\n          this.apngBytes = new ByteArray(0);\n          this.frameBytes = new ByteArray(0);\n          this.frame = -1;\n          this.seqNumber = -1;\n          return 0;\n       }   // start\n\n  this.setDelay = function(d100) {\n       // Sets the delay time between each frame.\n       // Applies to the last frame added and for subsequent frames.\n       // Parameter: d100 int delay time in 1/100 sec.\n       this.delay_num = parseInt(d100);\n       this.delay_den = 100;\n       return 0;\n  }   // setDelay\n\n  this.setRepeat = function(iter) {\n       // Sets the number of times the set of APNG frames should be played.\n       // Default is 1; 0 means play indefinitely.\n       // Must be invoked before the first image is added.\n       // Parameter: int number of iterations.\n     if (iter >= 0) this.repeat = parseInt(iter);\n       return 0;\n  }   // setRepeat\n\n  this.setDispose = function(d) {\n       // 0: APNG_DISPOSE_OP_NONE: no disposal is done on this frame before rendering the next;\n       //    the contents of the output buffer are left as is.\n       // 1: APNG_DISPOSE_OP_BACKGROUND: the frame's region of the output buffer is to be cleared\n       //    to fully transparent black before rendering the next frame.\n       // 2: APNG_DISPOSE_OP_PREVIOUS: the frame's region of the output buffer is to be reverted\n       //    to the previous contents before rendering the next frame.\n       if (d < 0 || d > 2) return 0;  // not valid\n       this.dispose = parseInt(d);\n       return 0;\n   }   // setDispose\n\n  this.setBlend = function(b) {\n       // 0: APNG_BLEND_OP_SOURCE all color components of the frame, including alpha, overwrite\n       //    the current contents of the frame's output buffer region.\n       // 1: APNG_BLEND_OP_OVER the frame should be composited onto the output buffer based\n       //    on its alpha, using a simple OVER operation.\n       if (b < 0 || b > 1) return 0;  // not valid\n       this.blend = parseInt(b);\n       return 0;\n   }   // setBlend\n\n  this.addFrame = function() {\n       // The addFrame method takes a canvas element to create each frame.\n     if ((this.canvas === null) || !this.started || this.apngBytes === null) {\n        throw new Error(\"Please call start method before calling addFrame\");\n     }\n\n       this.frame += 1;  // frame number: used to derive seq number fcTL/fdAT chunks\n\n       var dataURL = this.canvas.toDataURL('image/png');\n       var base64_png = dataURL.replace(/^data:image\\/png;base64,/, \"\");\n\n       this.frameBytes.bin = base64ToBytes(base64_png);  // current byteArray of canvas\n\n       if (this.frame == 0) {\n          // Add signature (first eight bytes of a PNG datastream)\n          var signature = [0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A];\n          this.apngBytes.bin = this.apngBytes.bin.concat(signature);\n\n          // Copy Image Header Chunk (IHDR)\n          var chunk = this.frameBytes.findChunk(\"IHDR\");\n          var chunkSlice = this.frameBytes.bin.slice(chunk.idx, chunk.idx + 12 + chunk.len);\n          this.apngBytes.bin = this.apngBytes.bin.concat(chunkSlice);\n\n          // acTL chunk   (animation control)\n          var acTL = new Array(0);\n          acTL = acTL.concat([0,0,0,8]);  // fixed length (8 data bytes)\n          acTL = acTL.concat( str4ToBytes4(\"acTL\") );  // chunk type;\n          acTL = acTL.concat([0,0,0,1]);    // number of frames: must be updated at end\n          acTL = acTL.concat( int32ToBytes4(this.repeat) );      // push nr of times to loop\n          var crcVal = crc32b(acTL.slice(4, 4+4+8));\n          acTL = acTL.concat( int32ToBytes4(crcVal) );           // push CRC 4 bytes\n          this.apngBytes.bin = this.apngBytes.bin.concat(acTL);  // push to main stream\n\n          // Add (copy) Data Chunks (fcTL and IDAT)  (first frame)\n          var chunkArray = this.frameBytes.findChunkAll(\"IDAT\");\n          for (var i = 0; i < chunkArray.length; i++) { \n             if (i == 0) {\n                // fcTL chunk (frame control)\n                this.seqNumber +=1;  // Sequence number for fcTL and fdAT chunks\n                var fcTL = new Array(0);\n                fcTL = fcTL.concat( int32ToBytes4(26) );  // fixed length data 8 bytes\n                fcTL = fcTL.concat( str4ToBytes4(\"fcTL\") );  // chunk type;\n                fcTL = fcTL.concat( int32ToBytes4(this.seqNumber) );     // sequence number 0\n                fcTL = fcTL.concat( int32ToBytes4(this.canvas.width) );  // width\n                fcTL = fcTL.concat( int32ToBytes4(this.canvas.height) ); // height\n                fcTL = fcTL.concat( int32ToBytes4(0) );                  // x-offset\n                fcTL = fcTL.concat( int32ToBytes4(0) );                  // y-offset\n                fcTL = fcTL.concat( int16ToBytes2(this.delay_num) );     // Delay num\n                fcTL = fcTL.concat( int16ToBytes2(this.delay_den) );     // Delay den\n                fcTL = fcTL.concat( [this.dispose] );  // dispose mode; values [0,1,2] (1 byte)\n                fcTL = fcTL.concat( [this.blend] );    // blend mode values [0,1] (1 byte)\n\n                var crcVal = crc32b(fcTL.slice(4, 4+4+26));\n                fcTL = fcTL.concat( int32ToBytes4(crcVal) );           // push CRC 4 bytes\n                this.apngBytes.bin = this.apngBytes.bin.concat(fcTL);  // push to main stream\n             }\n\n             chunk = chunkArray[i];  // copy complete IDAT chunk\n             var chunkSlice = this.frameBytes.bin.slice(chunk.idx, chunk.idx + 12 + chunk.len);\n             this.apngBytes.bin = this.apngBytes.bin.concat(chunkSlice);  // push to main stream\n          }  // for\n\n       }  // first frame\n\n       if (this.frame > 0) {\n          // Not first frame\n          // Add Data Chunks fcTL/fdAT\n          var chunkArray = this.frameBytes.findChunkAll(\"IDAT\");\n          for (var i = 0; i < chunkArray.length; i++) { \n             if (i == 0) {\n                // fcTL chunk (frame control)\n                this.seqNumber +=1;  // Sequence number for fcTL and fdAT chunks\n                var fcTL = new Array(0);\n                fcTL = fcTL.concat( int32ToBytes4(26) );          // fixed length data 8 bytes\n                fcTL = fcTL.concat( str4ToBytes4(\"fcTL\") );       // chunk type;\n                fcTL = fcTL.concat( int32ToBytes4(this.seqNumber) );      // sequence number\n                fcTL = fcTL.concat( int32ToBytes4(this.canvas.width) );   // width\n                fcTL = fcTL.concat( int32ToBytes4(this.canvas.height) );  // height\n                fcTL = fcTL.concat( int32ToBytes4(0) );                   // x-offset\n                fcTL = fcTL.concat( int32ToBytes4(0) );                   // y-offset\n                fcTL = fcTL.concat( int16ToBytes2(this.delay_num) );      // Delay num\n                fcTL = fcTL.concat( int16ToBytes2(this.delay_den) );      // Delay den\n                fcTL = fcTL.concat( [this.dispose] );  // dispose mode; values [0,1,2] (1 byte)\n                fcTL = fcTL.concat( [this.blend] );    // blend mode values [0,1] (1 byte)\n\n                var crcVal = crc32b(fcTL.slice(4, 4+4+26));\n                fcTL = fcTL.concat( int32ToBytes4(crcVal) );  // push CRC 4 bytes\n                this.apngBytes.bin = this.apngBytes.bin.concat(fcTL);  // push to main stream\n             }\n\n             // ============================================================================\n             // fdAT chunk (frame data)\n             chunk = chunkArray[i];  // get IDAT chunk object\n             var chunk_IDAT_data = this.frameBytes.bin.slice(chunk.idx + 8, chunk.idx + 8 + chunk.len);\n             var len_fdAT = chunk.len + 4;                  // increase data with seq number\n\n             this.seqNumber +=1;  // Sequence number for fcTL and fdAT chunks\n             var fdAT = new Array(0);\n             fdAT = fdAT.concat( int32ToBytes4(len_fdAT) );    // append length bytes\n             fdAT = fdAT.concat( str4ToBytes4(\"fdAT\") );       // chunk type bytes\n             fdAT = fdAT.concat( int32ToBytes4(this.seqNumber) );  // add sequence number bytes\n             fdAT = fdAT.concat( chunk_IDAT_data );            // append original IDAT data\n             var crcVal = crc32b(fdAT.slice(4, 4+4+len_fdAT));\n             fdAT = fdAT.concat( int32ToBytes4(crcVal) );      // push CRC 4 bytes\n\n             this.apngBytes.bin = this.apngBytes.bin.concat(fdAT);  // push to main stream\n          }  // for\n\n       }  // not first frame\n\n     return 0;\n  }   // addFrame\n  \n  this.finish = function() {\n       // Adds final chunk to the APNG stream.\n       // If you don't call the finish method the APNG stream will not be valid.\n     if (!this.started) return false;\n\n       // Add Image End Chunk (IEND)\n       var chunkArray = [0x00,0x00,0x00,0x00, 0x49,0x45,0x4E,0x44, 0xAE,0x42,0x60,0x82];  // fixed\n       this.apngBytes.bin = this.apngBytes.bin.concat(chunkArray);\n\n       // Update acTL chunk with number of frames\n       var chunk = this.apngBytes.findChunk(\"acTL\");\n       var nFrames = int32ToBytes4(this.frame + 1);\n       this.apngBytes.bin[chunk.idx+8] = nFrames[0];\n       this.apngBytes.bin[chunk.idx+8+1] = nFrames[1];\n       this.apngBytes.bin[chunk.idx+8+2] = nFrames[2];\n       this.apngBytes.bin[chunk.idx+8+3] = nFrames[3];\n\n       // Update CRC of acTL\n       var acTLslice = this.apngBytes.bin.slice(chunk.idx+4, chunk.idx+4+4+8);\n       var crcVal = crc32b( acTLslice );\n       var crcBytes = int32ToBytes4(crcVal);\n       this.apngBytes.bin[chunk.idx+4+4+8] = crcBytes[0];\n       this.apngBytes.bin[chunk.idx+4+4+8+1] = crcBytes[1];\n       this.apngBytes.bin[chunk.idx+4+4+8+2] = crcBytes[2];\n       this.apngBytes.bin[chunk.idx+4+4+8+3] = crcBytes[3];\n\n       this.started = false;\n       this.closeStream = true;\n\n     return true;\n  }   // finish\n\n  this.stream = function() {\n       // Retrieves the APNG stream.\n     return self.apngBytes;\n  };\n\n  return this;\n};  // APNGencoder\n// ===============================================================================\n\n// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nfunction ByteArray(len) {\n  // Object special designed to store a PNG image.\n  // Used to generate an animated PNG image and process chunks.\n\n  this.bin = new Array(len);  // To store the byte array\n\n  // A chunk in a PNG file consists of four parts:\n  // - Length of data (4 bytes)\n  // - Chunk type (4 bytes)\n  // - Chunk data (length bytes)\n  // - CRC (Cyclic Redundancy Code / Checksum, 4 bytes)\n  // There are about 20 different chunk types, but for a minimal PNG, only 3 are required:\n  // - the IHDR (image header) chunk\n  // - one or more IDAT (image data) chunks\n  // - the IEND (image end) chunk\n  function Chunk(idx, len, type) {\n     // Object Chunk\n     this.idx = idx;   // Starting index of chunk in context of byte array\n     this.len = len;   // Length of data: total length of chunk is (4 + 4 + len + 4)\n     this.type = type; // IHDR, IEND, IDAT, acTL, fcTL, fdAT, etc.\n  }  // Chunk\n\n  this.findChunk =\n     function(iType) {\n        // Find first chunk matching iType; null if not found\n        var offset = 8;    // start search\n        var chunk = null;  // default output \n        while (offset < this.bin.length) {\n           var chunk1 = this.bin.slice(offset, offset + 4);     // length chunk data\n           var chunk2 = this.bin.slice(offset + 4, offset + 8); // type of chunk\n\n           var chunkLength = bytes4ToInt32(chunk1);\n           var chunkType = bytes4ToStr4(chunk2);\n           if (chunkType === iType) {\n             chunk = new Chunk(offset, chunkLength, chunkType);\n             // chunk_arr = this.bin.slice(offset, offset + 4 + 4 + chunkLength + 4);\n             return chunk;  // STOP\n           }\n\n           offset += 4 + 4 + chunkLength + 4;\n        }\n\n        return chunk;\n     }  // findChunk\n\n  this.findChunkAll =\n     function(iType) {\n        // Find all chunks matching iType. Output array of chunk objects.\n        var offset = 8;    // start search\n        var chunkArray = [];  // default output \n        while (offset < this.bin.length) {\n           var chunk1 = this.bin.slice(offset, offset + 4);     // length chunk data\n           var chunk2 = this.bin.slice(offset + 4, offset + 8); // type of chunk\n\n           var chunkLength = bytes4ToInt32(chunk1);\n           var chunkType = bytes4ToStr4(chunk2);\n           if (chunkType === iType) {\n             var chunk = new Chunk(offset, chunkLength, chunkType);\n             chunkArray.push(chunk);  // array of chunk objects\n             // chunk_arr = this.bin.slice(offset, offset + 4 + 4 + chunkLength + 4);\n           }\n\n           offset += 4 + 4 + chunkLength + 4;\n        }\n\n        return chunkArray;\n     }  // findChunkAll\n\n  this.toStrHex =\n     function() {\n        return bytesToStrHex(this.bin);\n     }  // toStrHex\n\n  this.toStrBase64 =\n     function() {\n        return bytesToBase64(this.bin);\n     }  // toStrBase64\n\n  this.toStrAscii =\n     function() {\n        return bytesToStrAscii(this.bin);\n     }  // toStrAscii\n\n  this.toStrDec =\n     function() {\n        return bytesToStrDec(this.bin);\n     }  // toStrDec\n\n  return this;\n}  // ByteArray\n\n// ===============================================================================\n\nfunction bytesToStrHex(bytes) {\n  // Convert byte array to string of hexa-decimals.\n  var str = \"\";\n  for (var i=0; i < bytes.length; i++) {\n     str += decimalToHex(bytes[i], 2) + \" \";\n  }\n  return str;\n}  // bytesToStrHex\n\nfunction bytesToStrDec(bytes) {\n  // Convert byte array to string of decimals.\n  var str = \"\";\n  for (var i = 0; i < bytes.length; i++) {\n     str += ('000' + bytes[i]).slice(-3);  // padding 3 char\n     str += \" \";\n  }\n  return str;\n}  // bytesToStrDec\n\nfunction bytesToStrAscii(bytes) {\n  // Conversion byte array of Unicode (UTF-8) values into characters.\n  var str = \"\";\n  for (var i = 0; i < bytes.length; i++) {\n     if (bytes[i] > 32 && bytes[i] < 127) {  // printable\n        str += String.fromCharCode(bytes[i]);\n     }\n     else\n        str += \".\";\n  }\n  return str;\n}  // bytesToStrAscii\n\nfunction multiLine(str, lineWidth) {\n  // Split long string into lines with fixed width\n  var patt = new RegExp(\"(.{\" + lineWidth + \"})\", \"g\");  // e.g. regex /(.{75})/\n  return str.split(patt).join(\"\\n\").replace(/\\n+/g, \"\\n\").trim();\n}  // multiLine\n\n// ===============================================================================\nfunction decimalToHex(decimal, chars) {\n  // This converts a number to a string hex AND pads leading zeros\n  return (decimal + Math.pow(16, chars)).toString(16).slice(-chars).toUpperCase();\n}  // decimalToHex\n\nfunction bytesToBase64(bytes) {\n  // Convert byte array to base64 string.\n  var str = \"\";\n  for (var i = 0; i < bytes.length; i++)\n     str += String.fromCharCode(bytes[i]);\n  return btoa(str);\n}  // bytesToBase64\n\nfunction base64ToBytes(str) {\n  // Convert base64 string to byte array.\n  var decoded = atob(str);\n\n  var len = decoded.length;\n  var arr = new Array(len);\n\n  for (var i = 0; i < len; ++i) {\n    arr[i] = decoded.charCodeAt(i);\n  }\n\n  return arr;\n}  // base64ToBytes\n\n// ===============================================================================\nfunction str4ToBytes4(iString) {\n  var cc = new Array(4);\n  cc[0] = iString.charCodeAt(0);\n  cc[1] = iString.charCodeAt(1);\n   cc[2] = iString.charCodeAt(2);\n   cc[3] = iString.charCodeAt(3);\n   return cc;\n}  // strToBytes4\n\nfunction bytes4ToStr4(iBytes) {\n  var cc = \n    String.fromCharCode(iBytes[0]) +\n    String.fromCharCode(iBytes[1]) +\n    String.fromCharCode(iBytes[2]) +\n    String.fromCharCode(iBytes[3]);\n  return cc;\n}  // bytes4ToStr4\n\nfunction int32ToBytes4(iNum) {\n  var int32 = iNum;\n  var arr = [0, 0, 0, 0];\n  for ( var idx = 0; idx < arr.length; idx ++ ) {\n     var byte = int32 & 0xff;\n     arr[idx] = byte;\n     int32 = (int32 - byte) / 256 ;\n  }\n  return arr.reverse();\n}  // int32ToBytes4\n\nfunction bytes4ToInt32(iBytes) {\n  var num = (iBytes[0] << 24) + (iBytes[1] << 12) + (iBytes[2] << 8) + iBytes[3];\n  return num;\n}  // bytes4ToInt32\n\nfunction int16ToBytes2(iNum) {\n  var int16 = iNum;\n  var arr = [0, 0];\n  for ( var idx = 0; idx < arr.length; idx ++ ) {\n     var byte = int16 & 0xff;\n     arr[idx] = byte;\n     int16 = (int16 - byte) / 256 ;\n  }\n  return arr.reverse();\n}  // int16ToBytes2\n\n\n// ===============================================================================\n\n\n\n// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n/*\nImplementation of CRC32b calculation.\nCalculation function: var res = crc32b(iVar)\n- iVar is string or array of unsigned integer\n- res is unsigned integer (4 bytes)\nFormat function for output CRC32 calculation: formatCRC32(iVal, iType)\n\nTestcases:\nIN: [0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x08,0x02,0x00,0x00,0x00];\nOUT:  \"907753DE\"   or [144,119,83,222]   (IHDR chunk)\nIN: [0x49,0x45,0x4E,0x44] or [73,69,78,68]\nOUT: \"AE426082\"  or  [174,66,96,130]  (IEND chunk)\nIN: \"SheetJS\"\nOUT: \"9DD03922\" or  [157,208,57,34]\n*/\n\n// ===============================================================================\n\nvar a_table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n\nvar b_table = a_table.split(' ').map(function(s){ return parseInt(s,16) });\n\nfunction crc32b(iVar) {\n  // Calculate CRC32b value of iVar (string or array of integers (bytes))\n  if (typeof iVar == \"string\" || iVar instanceof String) {\n     // Convert string to integer array\n     var arr = new Array(iVar.length);\n     for (var i=0; i < iVar.length; i++) { arr[i] = iVar.charCodeAt(i); }\n  } \n  else if (Array.isArray(iVar)) {\n     var arr = iVar;\n  }\n  else {\n     alert(\"Bad input for CRC32 calculation: \" + iVar);\n     return 0;\n  }\n\n  var crc = -1;\n  for (var i=0, iTop = arr.length; i < iTop; i++) {\n     crc = ( crc >>> 8 ) ^ b_table[( crc ^ arr[i] ) & 0xFF];\n  }\n  return (crc ^ (-1)) >>> 0;\n}  // crc32b\n\n\nfunction formatCRC32(iVal, iType) {\n  // iVal: result of CRC32.str or CRC32.buf (from crc32.js)\n  // Format types: uint, hexs, hexb\n\n  function lpad(s, len, chr){\n     var L = len - s.length, C = chr || \" \";\n     if(L <= 0) return s;\n     return new Array(L+1).join(C) + s;\n  }  // lpad\n\n  var res;\n  switch(iType) {\n     case \"uint\":  // unsigned integer\n         res = iVal;\n         break;\n     case \"hexs\":  // hexadec string\n         res = lpad(iVal.toString(16),8,'0').toUpperCase();\n         break;\n     case \"hexb\":  // byte array (first index is high)\n         res = new Array(4);\n         var hexs = lpad(iVal.toString(16),8,'0');\n         res[0] = parseInt(hexs.substring(0, 2),16);\n         res[1] = parseInt(hexs.substring(2, 4),16);\n         res[2] = parseInt(hexs.substring(4, 6),16);\n         res[3] = parseInt(hexs.substring(6, 8),16);\n         break;\n     default:\n         res = iVal;\n  }\n  return res;\n}  // formatCRC32\n\n// ===============================================================================\n\n// CONCATENATED MODULE: ./src/modules/apng-export.js\n\n\nfunction makeApngExportLink(images, delay, canvasSize, callback) {\n  const canvas = document.createElement('canvas');\n  canvas.setAttribute('width', canvasSize);\n  canvas.setAttribute('height', canvasSize);\n  const context = canvas.getContext('2d');\n\n  const image = new Image();\n\n  const interval = delay && 1 / delay;\n  const encoder = new APNGencoder(canvas);\n  encoder.setDelay(interval);\n  encoder.setRepeat(0);\n\n  encoder.start();\n\n  let curImg = 0;\n  const lastImg = images.length - 1;\n\n  function addImg() {\n    if (curImg === lastImg) {\n      encoder.finish();\n      callback(encoder.stream().toStrBase64());\n      return;\n    }\n\n    curImg += 1;\n    context.drawImage(image, 0, 0);\n    encoder.addFrame();\n\n    image.src = images[curImg];\n  }\n\n  image.onload = addImg;\n  image.src = images[curImg];\n}\n\n// CONCATENATED MODULE: ./src/app.js\n\n\n\n\n\nconst main = document.getElementById('main');\n\nfunction addElement(element, elementClass, elementId, parent) {\n  const elem = document.createElement(element);\n  elem.id = elementId;\n  elem.className = elementClass;\n  parent.appendChild(elem);\n  return elem;\n}\n\nfunction add(element, elementClass, elementId, elemX, isAfter) {\n  const elem = document.createElement(element);\n  elem.id = elementId;\n  elem.className = elementClass;\n  if (isAfter) {\n    elemX.after(elem);\n  } else {\n    elemX.before(elem);\n  }\n  return elem;\n}\n\nlet sizeInSquares = localStorage.getItem('squares') || 32;\nconst app_canvasSize = 512;\nlet scale = app_canvasSize / sizeInSquares;\nconst gallery = JSON.parse(localStorage.getItem('gallery')) || {};\nconst galleryKeys = Object.keys(gallery);\n\nconst toolsContainer = addElement('section', 'tools-container', 'toolsContainer', main);\nconst resizeSet = addElement('div', 'resize-set', 'resizeSet', toolsContainer);\n\nconst numberOfSizes = 4;\nfor (let i = 1; i <= numberOfSizes; i += 1) {\n  const elem = addElement('div', `size x${i}`, `size${i}`, resizeSet);\n  elem.innerHTML = `x${i}`;\n}\n\nlet mouseSize = localStorage.getItem('mouseSize') || 1;\n\nconst toolsSet = addElement('div', 'tools-set', 'toolsSet', toolsContainer);\nconst numberOfInstruments = 6;\nconst toolsList = ['pen', 'eraser', 'stroke', 'bucket', 'onecolor', 'picker'];\nfor (let i = 1; i <= numberOfInstruments; i += 1) {\n  addElement('div', `tool ${toolsList[i - 1]}`, toolsList[i - 1], toolsSet);\n}\n\nconst pageSizeContainer = addElement('div', 'page-sizes', 'pageSizes', toolsContainer);\nconst pageSize32 = addElement('div', 'page-s size32', 'size32', pageSizeContainer);\npageSize32.innerHTML = '32';\nconst pageSize64 = addElement('div', 'page-s size64', 'size64', pageSizeContainer);\npageSize64.innerHTML = '64';\nconst pageSize128 = addElement('div', 'page-s size128', 'size128', pageSizeContainer);\npageSize128.innerHTML = '128';\n\nconst defaultColor = '#ffffff';\n\nconst colorsButton = addElement('input', 'colors-button', 'colorsButton', toolsContainer);\ncolorsButton.setAttribute('type', 'color');\ncolorsButton.setAttribute('value', localStorage.getItem('color') || defaultColor);\n\nlet currentColor = colorsButton.value;\n\nconst shortcutsButton = addElement('div', 'shortcuts', 'shortcuts', toolsContainer);\n\nconst framesContainer = addElement('div', 'frames-container', 'framesContainer', main);\n\nlet frameNumber = 0;\nlet activeFrameNumber = 1;\nlet frameToAction = 1;\n\nconst addFrameButton = addElement('div', 'add-frame', 'addFrame', framesContainer);\naddFrameButton.innerHTML = 'Add new frame';\n\nfunction fillImage(color) {\n  const currentImage = [];\n  for (let i = 0; i < sizeInSquares; i += 1) {\n    currentImage.push([]);\n    for (let j = 0; j < sizeInSquares; j += 1) {\n      currentImage[i][j] = color;\n    }\n  }\n  return currentImage;\n}\n\nlet app_image = fillImage(defaultColor);\n\nfunction createFrame(val, elem, frame) {\n  if (frame > frameNumber) {\n    frameNumber = frame;\n  } else {\n    frameNumber += 1;\n  }\n\n  const frameToInteract = frame || frameNumber;\n\n  add('div', 'frame', `frame${frameToInteract}`, elem, val);\n\n  addElement('div', 'frame-pic', `framePic${frameToInteract}`, document.getElementById(`frame${frameToInteract}`));\n  document.getElementById(`framePic${frameToInteract}`).setAttribute('data-frame', `${frameToInteract}`);\n  document.getElementById(`framePic${frameToInteract}`).setAttribute('data-action', 'img');\n  const elemFramePic = elem.querySelector('[data-action=\"img\"]');\n  const prevFrame = elemFramePic && elemFramePic.dataset.frame;\n\n  if (val && document.getElementById(`img${prevFrame}`)) {\n    const copyImg = document.getElementById(`img${prevFrame}`).cloneNode(false);\n    copyImg.setAttribute('id', `img${frameToInteract}`);\n    document.getElementById(`framePic${frameToInteract}`).appendChild(copyImg);\n  }\n  if (document.getElementById(`img${frameToInteract}`)) {\n    gallery[`img${frameToInteract}`] = app_image.map((line) => [...line]);\n  } else {\n    gallery[`img${frameToInteract}`] = gallery[`img${frameToInteract}`] || fillImage(defaultColor);\n  }\n  addElement('div', 'frame-but-container', `frameButContainer${frameToInteract}`, document.getElementById(`frame${frameToInteract}`));\n  addElement('div', 'frame-number', `frame${frameToInteract}Number`, document.getElementById(`frameButContainer${frameToInteract}`));\n  document.getElementById(`frame${frameToInteract}Number`).innerHTML = `${frameToInteract}`;\n  document.getElementById(`frame${frameToInteract}Number`).setAttribute('data-action', 'number');\n  document.getElementById(`frame${frameToInteract}Number`).setAttribute('data-frame', `${frameToInteract}`);\n  addElement('div', 'copy-frame', `copyFrame${frameToInteract}`, document.getElementById(`frameButContainer${frameToInteract}`));\n  document.getElementById(`copyFrame${frameToInteract}`).setAttribute('data-action', 'copy');\n  document.getElementById(`copyFrame${frameToInteract}`).setAttribute('data-frame', `${frameToInteract}`);\n  addElement('div', 'delete-frame', `deleteFrame${frameToInteract}`, document.getElementById(`frameButContainer${frameToInteract}`));\n  document.getElementById(`deleteFrame${frameToInteract}`).setAttribute('data-action', 'delete');\n  document.getElementById(`deleteFrame${frameToInteract}`).setAttribute('data-frame', `${frameToInteract}`);\n  for (let i = 0; i < document.querySelectorAll('.frame-number').length; i += 1) {\n    if (document.querySelectorAll('.frame-number')[i]) {\n      document.querySelectorAll('.frame-number')[i].innerHTML = `${i + 1}`;\n    }\n  }\n}\n\nconst canvasContainer = addElement('section', 'canvas-container', 'canvasContainer', main);\nconst app_canvas = addElement('canvas', 'canvas', 'canvas', canvasContainer);\napp_canvas.setAttribute('width', app_canvasSize);\napp_canvas.setAttribute('height', app_canvasSize);\n\nconst previewBlock = addElement('div', 'preview-block', 'previewBlock', main);\naddElement('div', 'preview-image', 'previewImage', previewBlock);\nconst fpsBlock = addElement('div', 'fps-block', 'fpsBlock', previewBlock);\nconst minusFps = addElement('div', 'fps-button minus-fps', 'minusFps', fpsBlock);\nminusFps.innerHTML = '-';\nconst fpsValue = addElement('div', 'fps-button fps', 'fps', fpsBlock);\nlet fps = 0;\nfpsValue.innerHTML = fps;\n\nconst plusFps = addElement('div', 'fps-button plus-fps', 'plusFps', fpsBlock);\nplusFps.innerHTML = '+';\n\nconst ctx = app_canvas.getContext('2d');\n\nfunction drawImage(img, frame) {\n  const frameToInteract = frame || activeFrameNumber;\n  for (let i = 0; i < sizeInSquares; i += 1) {\n    for (let j = 0; j < sizeInSquares; j += 1) {\n      ctx.fillStyle = img[i][j];\n      ctx.fillRect(j * scale, i * scale, scale, scale);\n    }\n  }\n\n  const imageMini = document.getElementById(`img${frameToInteract}`) || new Image();\n  imageMini.height = '110';\n  imageMini.width = '110';\n  imageMini.src = app_canvas.toDataURL('image/png');\n  if (!imageMini.hasAttribute('id')) {\n    imageMini.setAttribute('id', `img${frameToInteract}`);\n  }\n  if (document.getElementById(`img${frameToInteract}`)) {\n    document.getElementById(`img${frameToInteract}`).remove();\n  }\n  document.getElementById(`framePic${frameToInteract}`).appendChild(imageMini);\n  imageMini.setAttribute('id', `img${frameToInteract}`);\n  gallery[`img${frameToInteract}`] = img.map((line) => [...line]);\n  localStorage.setItem('gallery', JSON.stringify(gallery));\n}\n\n\nif (galleryKeys.length) {\n  galleryKeys.forEach((frameName) => {\n    const currentFrame = parseInt(frameName.replace(/\\D/g, ''), 10);\n\n    activeFrameNumber = currentFrame;\n    app_image = gallery[frameName];\n    createFrame(false, addFrameButton, currentFrame);\n    drawImage(gallery[frameName], currentFrame);\n  });\n} else {\n  createFrame(false, addFrameButton);\n  drawImage(app_image);\n}\n\nconst pencill = document.getElementById('pen');\nconst eraser = document.getElementById('eraser');\nconst stroke = document.getElementById('stroke');\nconst fillBucket = document.getElementById('bucket');\nconst colorPicker = document.getElementById('picker');\nconst oneColor = document.getElementById('onecolor');\nlet currentTool = localStorage.getItem('currentTool') || 'pencill';\n\ntoolsSet.addEventListener('click', (e) => {\n  if (e.target === eraser) {\n    currentTool = 'eraser';\n    localStorage.setItem('currentTool', 'eraser');\n    currentColor = defaultColor;\n  }\n  if (e.target === pencill) {\n    currentTool = 'pencill';\n    localStorage.setItem('currentTool', 'pencill');\n    currentColor = colorsButton.value;\n    localStorage.setItem('color', currentColor);\n  }\n  if (e.target === stroke) {\n    currentTool = 'stroke';\n    localStorage.setItem('currentTool', 'stroke');\n    currentColor = colorsButton.value;\n    localStorage.setItem('color', currentColor);\n  }\n  if (e.target === fillBucket) {\n    currentTool = 'bucket';\n    localStorage.setItem('currentTool', 'bucket');\n    currentColor = colorsButton.value;\n    localStorage.setItem('color', currentColor);\n  }\n  if (e.target === colorPicker) {\n    currentTool = 'picker';\n    localStorage.setItem('currentTool', 'picker');\n    currentColor = colorsButton.value;\n    localStorage.setItem('color', currentColor);\n  }\n  if (e.target === oneColor) {\n    currentTool = 'onecolor';\n    localStorage.setItem('currentTool', 'onecolor');\n    currentColor = colorsButton.value;\n    localStorage.setItem('color', currentColor);\n  }\n});\n\nlet xPosition = 0;\nlet yPosition = 0;\nlet imageStorage = [];\n\nfunction mousePosition(element) {\n  xPosition = Math.floor(element.offsetX / scale);\n  yPosition = Math.floor(element.offsetY / scale);\n}\n\n\nfunction mouse(x, y, color) {\n  for (let i = 0; i < mouseSize; i += 1) {\n    for (let j = 0; j < mouseSize; j += 1) {\n      if (app_image[y + i] && app_image[y + i][x + j]) {\n        app_image[y + i][x + j] = color;\n      }\n    }\n  }\n}\n\nconst doLine = function line(x0, y0, x1, y1, col) {\n  const dx = Math.abs(x1 - x0);\n  const dy = Math.abs(y1 - y0);\n  const sx = (x0 < x1) ? 1 : -1;\n  const sy = (y0 < y1) ? 1 : -1;\n  let err = dx - dy;\n  let newX0 = x0;\n  let newY0 = y0;\n  while (!((newX0 === x1) && (newY0 === y1))) {\n    mouse(newX0, newY0, col);\n    const e2 = 2 * err;\n    if (e2 > -dy) {\n      err -= dy;\n      newX0 += sx;\n    }\n    if (e2 < dx) {\n      err += dx;\n      newY0 += sy;\n    }\n  }\n};\n\n\nlet xx0 = 0;\nlet yy0 = 0;\n\napp_canvas.addEventListener('mousemove', (e) => {\n  if ((e.which === 1) && (currentTool === 'pencill')) {\n    mousePosition(e);\n    mouse(xPosition, yPosition, currentColor);\n    drawImage(app_image);\n  }\n  if ((e.which === 1) && (currentTool === 'eraser')) {\n    mousePosition(e);\n    mouse(xPosition, yPosition, currentColor);\n    drawImage(app_image);\n  }\n  if ((e.which === 1) && (currentTool === 'stroke')) {\n    app_image = imageStorage.map((line) => [...line]);\n    mousePosition(e);\n    doLine(xx0, yy0, xPosition, yPosition, currentColor);\n    drawImage(app_image);\n  }\n});\n\nfunction fill(color, initColor, [y, x], imageFill) {\n  const currentColorForFill = imageFill[y] && imageFill[y][x];\n  if (currentColorForFill === undefined) {\n    return;\n  }\n  if (color === initColor) {\n    return;\n  }\n  if (currentColorForFill !== initColor) {\n    return;\n  }\n  app_image[y][x] = color;\n\n  fill(color, initColor, [y + 1, x], app_image);\n  fill(color, initColor, [y, x + 1], app_image);\n  fill(color, initColor, [y - 1, x], app_image);\n  fill(color, initColor, [y, x - 1], app_image);\n}\n\nfunction colorDifference(mainColor, oldColor) {\n  app_image.forEach((elem) => {\n    const element = elem;\n    for (let i = 0; i < sizeInSquares; i += 1) {\n      if (element[i] === oldColor) {\n        element[i] = mainColor;\n      }\n    }\n  });\n}\n\napp_canvas.addEventListener('mousedown', (e) => {\n  if ((e.which === 1) && (currentTool === 'pencill')) {\n    mousePosition(e);\n    mouse(xPosition, yPosition, currentColor);\n    drawImage(app_image);\n  }\n  if ((e.which === 1) && (currentTool === 'eraser')) {\n    mousePosition(e);\n    mouse(xPosition, yPosition, currentColor);\n    drawImage(app_image);\n  }\n  if ((e.which === 1) && (currentTool === 'stroke')) {\n    imageStorage = app_image.map((line) => [...line]);\n    mousePosition(e);\n    xx0 = xPosition;\n    yy0 = yPosition;\n  }\n  if ((e.which === 1) && (currentTool === 'bucket')) {\n    mousePosition(e);\n    const initColor = app_image[yPosition][xPosition];\n    const initPoint = [yPosition, xPosition];\n    fill(currentColor, initColor, initPoint, app_image);\n    drawImage(app_image);\n  }\n  if ((e.which === 1) && (currentTool === 'picker')) {\n    mousePosition(e);\n    colorsButton.value = app_image[yPosition][xPosition];\n  }\n  if ((e.which === 1) && (currentTool === 'onecolor')) {\n    mousePosition(e);\n    colorDifference(currentColor, app_image[yPosition][xPosition]);\n    drawImage(app_image);\n  }\n});\n\nresizeSet.addEventListener('click', (e) => {\n  if (e.target === document.getElementById('size1')) {\n    mouseSize = 1;\n    localStorage.setItem('mouseSize', 1);\n  } else if (e.target === document.getElementById('size2')) {\n    mouseSize = 2;\n    localStorage.setItem('mouseSize', 2);\n  } else if (e.target === document.getElementById('size3')) {\n    mouseSize = 3;\n    localStorage.setItem('mouseSize', 3);\n  } else {\n    mouseSize = 4;\n    localStorage.setItem('mouseSize', 4);\n  }\n});\n\npageSizeContainer.addEventListener('click', (e) => {\n  if (e.target === pageSize32) {\n    sizeInSquares = 32;\n    localStorage.setItem('squares', 32);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  } else if (e.target === pageSize64) {\n    sizeInSquares = 64;\n    localStorage.setItem('squares', 64);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  } else {\n    sizeInSquares = 128;\n    localStorage.setItem('squares', 128);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  }\n});\n\ncolorsButton.addEventListener('change', () => {\n  currentColor = colorsButton.value;\n  localStorage.setItem('color', currentColor);\n});\n\naddFrameButton.addEventListener('click', () => {\n  createFrame(false, addFrameButton);\n});\n\nframesContainer.addEventListener('click', (e) => {\n  if (e.target.dataset.action === 'img' || e.target.parentNode.dataset.action === 'img') {\n    activeFrameNumber = e.target.dataset.frame || e.target.parentNode.dataset.frame;\n    app_image = gallery[`img${activeFrameNumber}`];\n    drawImage(app_image);\n  }\n  if (e.target.dataset.action === 'copy') {\n    frameToAction = Number(e.target.dataset.frame);\n    createFrame(true, document.getElementById(`frame${frameToAction}`));\n  }\n  if (e.target.dataset.action === 'delete') {\n    if (document.querySelectorAll('.frame-number').length > 1) {\n      const deleteFrame = Number(e.target.dataset.frame);\n      if (e.target.dataset.frame === activeFrameNumber) {\n        activeFrameNumber = document.querySelectorAll('.frame-number')[0].dataset.frame;\n        app_image = gallery[`img${activeFrameNumber}`];\n        drawImage(app_image);\n      }\n      document.getElementById(`frame${deleteFrame}`).remove();\n      for (let i = 0; i < document.querySelectorAll('.frame-number').length; i += 1) {\n        if (document.querySelectorAll('.frame-number')[i]) {\n          document.querySelectorAll('.frame-number')[i].innerHTML = `${i + 1}`;\n        }\n      }\n    }\n  }\n});\n\nfunction SortedPreviews(containerSelector, itemSelector) {\n  const containers = document.querySelectorAll(containerSelector);\n  const sortable = new draggable_bundle[\"Sortable\"](containers, {\n    draggable: itemSelector,\n  });\n  return sortable;\n}\n\nconst app_sortable = SortedPreviews('#framesContainer', '.frame');\n\napp_sortable.on('sortable:start');\napp_sortable.on('sortable:sort');\napp_sortable.on('sortable:sorted');\napp_sortable.on('sortable:stop', () => {\n  requestAnimationFrame(() => {\n    for (let i = 0; i < document.querySelectorAll('.frame-number').length; i += 1) {\n      if (document.querySelectorAll('.frame-number')[i]) {\n        document.querySelectorAll('.frame-number')[i].innerHTML = `${i + 1}`;\n      }\n    }\n  });\n});\n\nconst previewImage = document.getElementById('previewImage');\n\nlet picNumber = document.querySelectorAll('.frame-pic img').length;\n\nlet app_interval;\n\nfpsBlock.addEventListener('click', (e) => {\n  if (e.target === minusFps) {\n    if (fps > 0) {\n      fps -= 1;\n      fpsValue.innerHTML = fps;\n    }\n  }\n  if (e.target === plusFps) {\n    if (fps < 24) {\n      fps += 1;\n      fpsValue.innerHTML = fps;\n    }\n  }\n  if (fps === 0) {\n    if (app_interval) {\n      clearInterval(app_interval);\n    }\n  }\n\n  if (fps > 0) {\n    if (previewImage.hasChildNodes()) {\n      previewImage.removeChild(document.getElementById(`pic${picNumber - 1}`));\n    }\n    picNumber = document.querySelectorAll('.frame-pic img').length;\n\n    const pictures = document.querySelectorAll('.frame-pic img');\n\n    if (app_interval) {\n      clearInterval(app_interval);\n    }\n    app_interval = setInterval(() => {\n      if (previewImage.hasChildNodes()) {\n        previewImage.removeChild(document.getElementById(`pic${picNumber - 1}`));\n      }\n      if (picNumber > pictures.length) {\n        picNumber = 1;\n      }\n      const newNew = pictures[picNumber - 1].cloneNode();\n      previewImage.appendChild(newNew);\n      newNew.id = `pic${picNumber}`;\n      picNumber += 1;\n    }, 1000 / fps);\n  }\n});\n\nconst shortcuts = JSON.parse(localStorage.getItem('shortcuts')) || {\n  pen: [68, 'P', 'Pencill'],\n  bucket: [66, 'B', 'Fill Bucket'],\n  onecolor: [65, 'A', 'Paint all pixels of the same color'],\n  eraser: [69, 'E', 'Eraser'],\n  picker: [79, 'O', 'Color Picker'],\n  stroke: [76, 'L', 'Stroke'],\n  frame: [78, 'N', 'Add new frame'],\n  x1: [49, '1', 'Pen size 1'],\n  x2: [50, '2', 'Pen size 2'],\n  x3: [51, '3', 'Pen size 3'],\n  x4: [52, '4', 'Pen size 4'],\n  size32: [56, '8', 'Canvas size 32x32'],\n  size64: [57, '9', 'Canvas size 64x64'],\n  size128: [58, '0', 'Canvas size 128x128'],\n  fpsPlus: [81, 'Q', 'FPS +'],\n  fpsMinus: [87, 'W', 'FPS -'],\n};\n\ndocument.addEventListener('keydown', (event) => {\n  if (event.which === shortcuts.pen[0]) {\n    currentTool = 'pencill';\n    currentColor = colorsButton.value;\n    localStorage.setItem('currentTool', 'pencill');\n    localStorage.setItem('color', currentColor);\n  }\n  if (event.which === shortcuts.bucket[0]) {\n    currentTool = 'bucket';\n    currentColor = colorsButton.value;\n    localStorage.setItem('currentTool', 'bucket');\n    localStorage.setItem('color', currentColor);\n  }\n  if (event.which === shortcuts.onecolor[0]) {\n    currentTool = 'onecolor';\n    currentColor = colorsButton.value;\n    localStorage.setItem('currentTool', 'onecolor');\n    localStorage.setItem('color', currentColor);\n  }\n  if (event.which === shortcuts.eraser[0]) {\n    currentTool = 'eraser';\n    localStorage.setItem('currentTool', 'eraser');\n    currentColor = defaultColor;\n  }\n  if (event.which === shortcuts.picker[0]) {\n    currentTool = 'picker';\n    currentColor = colorsButton.value;\n    localStorage.setItem('currentTool', 'picker');\n    localStorage.setItem('color', currentColor);\n  }\n  if (event.which === shortcuts.stroke[0]) {\n    currentTool = 'stroke';\n    currentColor = colorsButton.value;\n    localStorage.setItem('currentTool', 'stroke');\n    localStorage.setItem('color', currentColor);\n  }\n  if (event.which === shortcuts.frame[0]) {\n    createFrame(false, addFrameButton);\n  }\n  if (event.which === shortcuts.x1[0]) {\n    mouseSize = 1;\n    localStorage.setItem('mouseSize', 1);\n  }\n  if (event.which === shortcuts.x2[0]) {\n    mouseSize = 2;\n    localStorage.setItem('mouseSize', 2);\n  }\n  if (event.which === shortcuts.x3[0]) {\n    mouseSize = 3;\n    localStorage.setItem('mouseSize', 3);\n  }\n  if (event.which === shortcuts.x4[0]) {\n    mouseSize = 4;\n    localStorage.setItem('mouseSize', 4);\n  }\n  if (event.which === shortcuts.size32[0]) {\n    sizeInSquares = 32;\n    localStorage.setItem('squares', 32);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  }\n  if (event.which === shortcuts.size64[0]) {\n    sizeInSquares = 64;\n    localStorage.setItem('squares', 64);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  }\n  if (event.which === shortcuts.size128[0]) {\n    sizeInSquares = 128;\n    localStorage.setItem('squares', 128);\n    scale = app_canvasSize / sizeInSquares;\n    app_image = fillImage(defaultColor);\n    drawImage(app_image);\n  }\n  if (event.which === shortcuts.fpsPlus[0]) {\n    if (fps < 24) {\n      fps += 1;\n      fpsValue.innerHTML = fps;\n    }\n  }\n  if (event.which === shortcuts.fpsMinus[0]) {\n    if (fps > 0) {\n      fps -= 1;\n      fpsValue.innerHTML = fps;\n    }\n  }\n});\n\nconst shortcutArr = ['pen', 'bucket', 'onecolor', 'eraser', 'picker', 'stroke', 'frame', 'x1', 'x2', 'x3', 'x4', 'size32', 'size64', 'size128', 'fpsPlus', 'fpsMinus'];\n\nconst keysInstructions = addElement('section', 'keys-instructions', 'keysInstructions', document.body);\nconst keysBox = addElement('div', 'keys-box', 'keysBox', keysInstructions);\n\nfor (let i = 0; i < shortcutArr.length; i += 1) {\n  addElement('div', 'shortcut-line', `shortCutLine${i}`, document.getElementById('keysBox'));\n  addElement('div', 'shortcut-button', `shortcutButton${i}`, document.getElementById(`shortCutLine${i}`));\n  addElement('div', 'shortcut-description', `shortcutDescription${i}`, document.getElementById(`shortCutLine${i}`));\n  [,\n    document.getElementById(`shortcutButton${i}`).innerHTML,\n    document.getElementById(`shortcutDescription${i}`).innerHTML,\n  ] = shortcuts[shortcutArr[i]];\n}\n\nshortcutsButton.addEventListener('click', () => {\n  keysInstructions.style.visibility = 'visible';\n});\n\nkeysInstructions.addEventListener('click', (e) => {\n  if (e.target === keysInstructions) {\n    keysInstructions.style.visibility = 'hidden';\n  }\n});\n\nconst changeKeyInfo = [false, '', ''];\n\nkeysBox.addEventListener('click', (e) => {\n  for (let i = 0; i < shortcutArr.length; i += 1) {\n    if (e.target.innerHTML === shortcuts[shortcutArr[i]][1]) {\n      changeKeyInfo[1] = shortcutArr[i];\n      changeKeyInfo[0] = true;\n      changeKeyInfo[2] = i;\n    }\n  }\n});\n\ndocument.addEventListener('keydown', (e) => {\n  if (changeKeyInfo[1] && changeKeyInfo[0]) {\n    for (let i = 0; i < shortcutArr.length; i += 1) {\n      if (shortcuts[shortcutArr[i]][1] === e.code.slice(-1)) {\n        shortcuts[shortcutArr[i]][0] = ' ';\n        shortcuts[shortcutArr[i]][1] = '???';\n        document.getElementById(`shortcutButton${i}`).innerHTML = '???';\n      }\n    }\n    shortcuts[changeKeyInfo[1]][0] = e.which;\n    shortcuts[changeKeyInfo[1]][1] = e.code.slice(-1);\n    [, e.target.htmlInner] = changeKeyInfo;\n\n    [, document.getElementById(`shortcutButton${changeKeyInfo[2]}`).innerHTML] = shortcuts[changeKeyInfo[1]];\n    changeKeyInfo[0] = false;\n    localStorage.setItem('shortcuts', JSON.stringify(shortcuts));\n  }\n});\n\nconst btt = addElement('div', 'btt', 'btt', previewBlock);\nbtt.innerHTML = 'Full screen';\nbtt.addEventListener('click', () => {\n  if (previewImage.requestFullScreen) {\n    previewImage.requestFullScreen();\n  } else if (previewImage.mozRequestFullScreen) {\n    previewImage.mozRequestFullScreen();\n  } else if (previewImage.webkitRequestFullScreen) {\n    previewImage.webkitRequestFullScreen();\n  }\n});\n\nconst gifButton = addElement('div', 'gif-button', 'gifButton', previewBlock);\ngifButton.innerHTML = 'GIF. export';\n\ngifButton.addEventListener('click', () => {\n  const frameImgs = document.querySelectorAll('.frame-pic img');\n  const frames = Array.prototype.map.call(frameImgs, ({ src }) => src);\n  makeGifExportLink(frames, fps, (link) => {\n    const linkA = document.createElement('a');\n    linkA.setAttribute('href', link);\n    linkA.setAttribute('download', link);\n    linkA.click();\n  });\n});\n\nconst apngButton = addElement('div', 'apng-button', 'apngButton', previewBlock);\napngButton.innerHTML = 'APNG. export';\n\napngButton.addEventListener('click', () => {\n  const frameImgs = document.querySelectorAll('.frame-pic img');\n  const frames = Array.prototype.map.call(frameImgs, ({ src }) => src);\n\n  makeApngExportLink(frames, fps, app_canvasSize, (bin) => {\n    const link = `data:image/png;base64,${bin}`;\n\n    const linkA = document.createElement('a');\n    linkA.setAttribute('href', link);\n    linkA.setAttribute('download', link);\n    linkA.click();\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9naWYtZXhwb3J0LmpzPzRiMzMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYnMvY2FudmFzMmFwbmcuanM/ZjNhNSIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hcG5nLWV4cG9ydC5qcz83Y2E3Iiwid2VicGFjazovLy8uL3NyYy9hcHAuanM/MTExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVHSUYgfSBmcm9tICdnaWZzaG90JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZUdpZkV4cG9ydExpbmsoaW1hZ2VzLCBkZWxheSwgY2FsbGJhY2spIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBpbWFnZXMsXG4gICAgaW50ZXJ2YWw6IDEsXG4gIH07XG5cbiAgaWYgKGRlbGF5ICE9PSAwKSB7XG4gICAgb3B0aW9ucy5pbnRlcnZhbCA9IDEgLyBkZWxheTtcbiAgfVxuXG4gIGNyZWF0ZUdJRihvcHRpb25zLCAocmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyBlcnJvciwgaW1hZ2UgfSA9IHJlc3VsdDtcblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGltYWdlKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbk1JVCBMaWNlbnNlXG5cbkNhbnZhczJBUE5HXG5FbmNvZGVyIGZvciBhbmltYXRlZCBBUE5HIGZpbGUgZnJvbSBhIHNlcmllcyBvZiBIdG1sNSBjYW52YXMgZHJhd2luZ3MuXG5Db3B5cmlnaHQgKGMpIGF1ZyAyMDE3LCBBcnRodXIgS2FsdmVyYm9lclxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gICAgICovXG5cbmV4cG9ydCBmdW5jdGlvbiBBUE5HZW5jb2RlcihpQ2FudmFzKSB7XG4gICAvLyBHZW5lcmF0ZSBBUE5HIGJ5dGUgYXJyYXkgZnJvbSBhIHNlcmllcyBvZiBjYW52YXMgaW1hZ2VzLlxuICAgLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BUE5HXG5cbiAgIC8vIFRvIGhpZGUgdGhpcy12YXJpYWJsZXMsIHB1dCB0aGVtIGluIGFuIG9iamVjdCAoZS5nLiB2YXJpYWJsZSBzdGF0ZSlcbiAgIC8vIGFuZCByZXBsYWNlIHRoaXMgYW5kIHNlbGYgYnkgc3RhdGUuXG4gICB2YXIgc2VsZiA9IHRoaXM7ICAvLyAhISEgY29weSB0aGlzIHRvIGNvbnRleHQgb2Ygb2JqZWN0XG4gICB0aGlzLndob2FtaSA9IFwiYXBuZyBwbmcgYW5pbWF0aW9uIGVuY29kZXIgY2FudmFzXCI7ICAvLyBrZXl3b3JkcyB0byBpZGVudGlmeVxuICAgdGhpcy5jYW52YXMgPSBpQ2FudmFzOyAgLy8gQ2FudmFzIGVsZW1lbnRcbiAgIHRoaXMucmVwZWF0ID0gMDsgICAgICAvLyBudW1iZXIgb2YgcmVwZWF0czsgMCBpbmRlZmluaXRlbHlcbiAgIHRoaXMuZnJhbWUgPSAtMTsgICAgICAvLyBmcmFtZSBudW1iZXIgKDAgaXMgZmlyc3QgZnJhbWUpXG4gICB0aGlzLnNlcU51bWJlciA9IC0xOyAgLy8gU2VxdWVuY2UgbnVtYmVyIGZvciBmY1RMIGFuZCBmZEFUIGNodW5rc1xuICAgdGhpcy5kZWxheV9udW0gPSAxOyAgIC8vIEZyYW1lIGRlbGF5IGZyYWN0aW9uIG51bWVyYXRvciAgIChpbnQxNiwgMiBieXRlcylcbiAgIHRoaXMuZGVsYXlfZGVuID0gMTsgICAvLyBGcmFtZSBkZWxheSBmcmFjdGlvbiBkZW5vbWluYXRvciAoaW50MTYsIDIgYnl0ZXMpIDAgPT0gMS8xMDAgc2VjXG4gICB0aGlzLmRpc3Bvc2UgPSAwOyAgICAgLy8gVHlwZSBvZiBmcmFtZSBhcmVhIGRpc3Bvc2FsOyB2YWx1ZXMgMCwgMSwgMlxuICAgdGhpcy5ibGVuZCA9IDE7ICAgICAgIC8vIFR5cGUgb2YgZnJhbWUgYXJlYSByZW5kZXJpbmc6IHZhbHVlcyAwLCAxXG5cbiAgIHRoaXMuYXBuZ0J5dGVzOyAgICAgICAvLyBBUE5HIG91dHB1dCBzdHJlYW0gKEJ5dGVBcnJheSlcbiAgIHRoaXMuZnJhbWVCeXRlczsgICAgICAvLyBCeXRlIHN0cmVhbSBvZiBjdXJyZW50IGZyYW1lIGltYWdlIChCeXRlQXJyYXkpXG5cbiAgIC8vIEZsYWdzXG4gIHRoaXMuc3RhcnRlZCA9IGZhbHNlOyAgICAgLy8gcmVhZHkgdG8gb3V0cHV0IGZyYW1lc1xuICB0aGlzLmNsb3NlU3RyZWFtID0gZmFsc2U7IC8vIGNsb3NlIHN0cmVhbSB3aGVuIGZpbmlzaGVkXG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIENyZWF0ZXMgQVBORyBvdXRwdXQgc3RyZWFtIG9uIHdoaWNoIGltYWdlcyBhcmUgd3JpdHRlbi5cbiAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY2xvc2VTdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmFwbmdCeXRlcyA9IG5ldyBCeXRlQXJyYXkoMCk7XG4gICAgICAgICAgdGhpcy5mcmFtZUJ5dGVzID0gbmV3IEJ5dGVBcnJheSgwKTtcbiAgICAgICAgICB0aGlzLmZyYW1lID0gLTE7XG4gICAgICAgICAgdGhpcy5zZXFOdW1iZXIgPSAtMTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICB9ICAgLy8gc3RhcnRcblxuICB0aGlzLnNldERlbGF5ID0gZnVuY3Rpb24oZDEwMCkge1xuICAgICAgIC8vIFNldHMgdGhlIGRlbGF5IHRpbWUgYmV0d2VlbiBlYWNoIGZyYW1lLlxuICAgICAgIC8vIEFwcGxpZXMgdG8gdGhlIGxhc3QgZnJhbWUgYWRkZWQgYW5kIGZvciBzdWJzZXF1ZW50IGZyYW1lcy5cbiAgICAgICAvLyBQYXJhbWV0ZXI6IGQxMDAgaW50IGRlbGF5IHRpbWUgaW4gMS8xMDAgc2VjLlxuICAgICAgIHRoaXMuZGVsYXlfbnVtID0gcGFyc2VJbnQoZDEwMCk7XG4gICAgICAgdGhpcy5kZWxheV9kZW4gPSAxMDA7XG4gICAgICAgcmV0dXJuIDA7XG4gIH0gICAvLyBzZXREZWxheVxuXG4gIHRoaXMuc2V0UmVwZWF0ID0gZnVuY3Rpb24oaXRlcikge1xuICAgICAgIC8vIFNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc2V0IG9mIEFQTkcgZnJhbWVzIHNob3VsZCBiZSBwbGF5ZWQuXG4gICAgICAgLy8gRGVmYXVsdCBpcyAxOyAwIG1lYW5zIHBsYXkgaW5kZWZpbml0ZWx5LlxuICAgICAgIC8vIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgdGhlIGZpcnN0IGltYWdlIGlzIGFkZGVkLlxuICAgICAgIC8vIFBhcmFtZXRlcjogaW50IG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgICBpZiAoaXRlciA+PSAwKSB0aGlzLnJlcGVhdCA9IHBhcnNlSW50KGl0ZXIpO1xuICAgICAgIHJldHVybiAwO1xuICB9ICAgLy8gc2V0UmVwZWF0XG5cbiAgdGhpcy5zZXREaXNwb3NlID0gZnVuY3Rpb24oZCkge1xuICAgICAgIC8vIDA6IEFQTkdfRElTUE9TRV9PUF9OT05FOiBubyBkaXNwb3NhbCBpcyBkb25lIG9uIHRoaXMgZnJhbWUgYmVmb3JlIHJlbmRlcmluZyB0aGUgbmV4dDtcbiAgICAgICAvLyAgICB0aGUgY29udGVudHMgb2YgdGhlIG91dHB1dCBidWZmZXIgYXJlIGxlZnQgYXMgaXMuXG4gICAgICAgLy8gMTogQVBOR19ESVNQT1NFX09QX0JBQ0tHUk9VTkQ6IHRoZSBmcmFtZSdzIHJlZ2lvbiBvZiB0aGUgb3V0cHV0IGJ1ZmZlciBpcyB0byBiZSBjbGVhcmVkXG4gICAgICAgLy8gICAgdG8gZnVsbHkgdHJhbnNwYXJlbnQgYmxhY2sgYmVmb3JlIHJlbmRlcmluZyB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAvLyAyOiBBUE5HX0RJU1BPU0VfT1BfUFJFVklPVVM6IHRoZSBmcmFtZSdzIHJlZ2lvbiBvZiB0aGUgb3V0cHV0IGJ1ZmZlciBpcyB0byBiZSByZXZlcnRlZFxuICAgICAgIC8vICAgIHRvIHRoZSBwcmV2aW91cyBjb250ZW50cyBiZWZvcmUgcmVuZGVyaW5nIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgIGlmIChkIDwgMCB8fCBkID4gMikgcmV0dXJuIDA7ICAvLyBub3QgdmFsaWRcbiAgICAgICB0aGlzLmRpc3Bvc2UgPSBwYXJzZUludChkKTtcbiAgICAgICByZXR1cm4gMDtcbiAgIH0gICAvLyBzZXREaXNwb3NlXG5cbiAgdGhpcy5zZXRCbGVuZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAvLyAwOiBBUE5HX0JMRU5EX09QX1NPVVJDRSBhbGwgY29sb3IgY29tcG9uZW50cyBvZiB0aGUgZnJhbWUsIGluY2x1ZGluZyBhbHBoYSwgb3ZlcndyaXRlXG4gICAgICAgLy8gICAgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGZyYW1lJ3Mgb3V0cHV0IGJ1ZmZlciByZWdpb24uXG4gICAgICAgLy8gMTogQVBOR19CTEVORF9PUF9PVkVSIHRoZSBmcmFtZSBzaG91bGQgYmUgY29tcG9zaXRlZCBvbnRvIHRoZSBvdXRwdXQgYnVmZmVyIGJhc2VkXG4gICAgICAgLy8gICAgb24gaXRzIGFscGhhLCB1c2luZyBhIHNpbXBsZSBPVkVSIG9wZXJhdGlvbi5cbiAgICAgICBpZiAoYiA8IDAgfHwgYiA+IDEpIHJldHVybiAwOyAgLy8gbm90IHZhbGlkXG4gICAgICAgdGhpcy5ibGVuZCA9IHBhcnNlSW50KGIpO1xuICAgICAgIHJldHVybiAwO1xuICAgfSAgIC8vIHNldEJsZW5kXG5cbiAgdGhpcy5hZGRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgIC8vIFRoZSBhZGRGcmFtZSBtZXRob2QgdGFrZXMgYSBjYW52YXMgZWxlbWVudCB0byBjcmVhdGUgZWFjaCBmcmFtZS5cbiAgICAgaWYgKCh0aGlzLmNhbnZhcyA9PT0gbnVsbCkgfHwgIXRoaXMuc3RhcnRlZCB8fCB0aGlzLmFwbmdCeXRlcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgY2FsbCBzdGFydCBtZXRob2QgYmVmb3JlIGNhbGxpbmcgYWRkRnJhbWVcIik7XG4gICAgIH1cblxuICAgICAgIHRoaXMuZnJhbWUgKz0gMTsgIC8vIGZyYW1lIG51bWJlcjogdXNlZCB0byBkZXJpdmUgc2VxIG51bWJlciBmY1RML2ZkQVQgY2h1bmtzXG5cbiAgICAgICB2YXIgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgdmFyIGJhc2U2NF9wbmcgPSBkYXRhVVJMLnJlcGxhY2UoL15kYXRhOmltYWdlXFwvcG5nO2Jhc2U2NCwvLCBcIlwiKTtcblxuICAgICAgIHRoaXMuZnJhbWVCeXRlcy5iaW4gPSBiYXNlNjRUb0J5dGVzKGJhc2U2NF9wbmcpOyAgLy8gY3VycmVudCBieXRlQXJyYXkgb2YgY2FudmFzXG5cbiAgICAgICBpZiAodGhpcy5mcmFtZSA9PSAwKSB7XG4gICAgICAgICAgLy8gQWRkIHNpZ25hdHVyZSAoZmlyc3QgZWlnaHQgYnl0ZXMgb2YgYSBQTkcgZGF0YXN0cmVhbSlcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gWzB4ODksMHg1MCwweDRFLDB4NDcsMHgwRCwweDBBLDB4MUEsMHgwQV07XG4gICAgICAgICAgdGhpcy5hcG5nQnl0ZXMuYmluID0gdGhpcy5hcG5nQnl0ZXMuYmluLmNvbmNhdChzaWduYXR1cmUpO1xuXG4gICAgICAgICAgLy8gQ29weSBJbWFnZSBIZWFkZXIgQ2h1bmsgKElIRFIpXG4gICAgICAgICAgdmFyIGNodW5rID0gdGhpcy5mcmFtZUJ5dGVzLmZpbmRDaHVuayhcIklIRFJcIik7XG4gICAgICAgICAgdmFyIGNodW5rU2xpY2UgPSB0aGlzLmZyYW1lQnl0ZXMuYmluLnNsaWNlKGNodW5rLmlkeCwgY2h1bmsuaWR4ICsgMTIgKyBjaHVuay5sZW4pO1xuICAgICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbiA9IHRoaXMuYXBuZ0J5dGVzLmJpbi5jb25jYXQoY2h1bmtTbGljZSk7XG5cbiAgICAgICAgICAvLyBhY1RMIGNodW5rICAgKGFuaW1hdGlvbiBjb250cm9sKVxuICAgICAgICAgIHZhciBhY1RMID0gbmV3IEFycmF5KDApO1xuICAgICAgICAgIGFjVEwgPSBhY1RMLmNvbmNhdChbMCwwLDAsOF0pOyAgLy8gZml4ZWQgbGVuZ3RoICg4IGRhdGEgYnl0ZXMpXG4gICAgICAgICAgYWNUTCA9IGFjVEwuY29uY2F0KCBzdHI0VG9CeXRlczQoXCJhY1RMXCIpICk7ICAvLyBjaHVuayB0eXBlO1xuICAgICAgICAgIGFjVEwgPSBhY1RMLmNvbmNhdChbMCwwLDAsMV0pOyAgICAvLyBudW1iZXIgb2YgZnJhbWVzOiBtdXN0IGJlIHVwZGF0ZWQgYXQgZW5kXG4gICAgICAgICAgYWNUTCA9IGFjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KHRoaXMucmVwZWF0KSApOyAgICAgIC8vIHB1c2ggbnIgb2YgdGltZXMgdG8gbG9vcFxuICAgICAgICAgIHZhciBjcmNWYWwgPSBjcmMzMmIoYWNUTC5zbGljZSg0LCA0KzQrOCkpO1xuICAgICAgICAgIGFjVEwgPSBhY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNChjcmNWYWwpICk7ICAgICAgICAgICAvLyBwdXNoIENSQyA0IGJ5dGVzXG4gICAgICAgICAgdGhpcy5hcG5nQnl0ZXMuYmluID0gdGhpcy5hcG5nQnl0ZXMuYmluLmNvbmNhdChhY1RMKTsgIC8vIHB1c2ggdG8gbWFpbiBzdHJlYW1cblxuICAgICAgICAgIC8vIEFkZCAoY29weSkgRGF0YSBDaHVua3MgKGZjVEwgYW5kIElEQVQpICAoZmlyc3QgZnJhbWUpXG4gICAgICAgICAgdmFyIGNodW5rQXJyYXkgPSB0aGlzLmZyYW1lQnl0ZXMuZmluZENodW5rQWxsKFwiSURBVFwiKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rQXJyYXkubGVuZ3RoOyBpKyspIHsgXG4gICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZjVEwgY2h1bmsgKGZyYW1lIGNvbnRyb2wpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXFOdW1iZXIgKz0xOyAgLy8gU2VxdWVuY2UgbnVtYmVyIGZvciBmY1RMIGFuZCBmZEFUIGNodW5rc1xuICAgICAgICAgICAgICAgIHZhciBmY1RMID0gbmV3IEFycmF5KDApO1xuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNCgyNikgKTsgIC8vIGZpeGVkIGxlbmd0aCBkYXRhIDggYnl0ZXNcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIHN0cjRUb0J5dGVzNChcImZjVExcIikgKTsgIC8vIGNodW5rIHR5cGU7XG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KHRoaXMuc2VxTnVtYmVyKSApOyAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIDBcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDMyVG9CeXRlczQodGhpcy5jYW52YXMud2lkdGgpICk7ICAvLyB3aWR0aFxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNCh0aGlzLmNhbnZhcy5oZWlnaHQpICk7IC8vIGhlaWdodFxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNCgwKSApOyAgICAgICAgICAgICAgICAgIC8vIHgtb2Zmc2V0XG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KDApICk7ICAgICAgICAgICAgICAgICAgLy8geS1vZmZzZXRcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDE2VG9CeXRlczIodGhpcy5kZWxheV9udW0pICk7ICAgICAvLyBEZWxheSBudW1cbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDE2VG9CeXRlczIodGhpcy5kZWxheV9kZW4pICk7ICAgICAvLyBEZWxheSBkZW5cbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIFt0aGlzLmRpc3Bvc2VdICk7ICAvLyBkaXNwb3NlIG1vZGU7IHZhbHVlcyBbMCwxLDJdICgxIGJ5dGUpXG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBbdGhpcy5ibGVuZF0gKTsgICAgLy8gYmxlbmQgbW9kZSB2YWx1ZXMgWzAsMV0gKDEgYnl0ZSlcblxuICAgICAgICAgICAgICAgIHZhciBjcmNWYWwgPSBjcmMzMmIoZmNUTC5zbGljZSg0LCA0KzQrMjYpKTtcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDMyVG9CeXRlczQoY3JjVmFsKSApOyAgICAgICAgICAgLy8gcHVzaCBDUkMgNCBieXRlc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbiA9IHRoaXMuYXBuZ0J5dGVzLmJpbi5jb25jYXQoZmNUTCk7ICAvLyBwdXNoIHRvIG1haW4gc3RyZWFtXG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgY2h1bmsgPSBjaHVua0FycmF5W2ldOyAgLy8gY29weSBjb21wbGV0ZSBJREFUIGNodW5rXG4gICAgICAgICAgICAgdmFyIGNodW5rU2xpY2UgPSB0aGlzLmZyYW1lQnl0ZXMuYmluLnNsaWNlKGNodW5rLmlkeCwgY2h1bmsuaWR4ICsgMTIgKyBjaHVuay5sZW4pO1xuICAgICAgICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbiA9IHRoaXMuYXBuZ0J5dGVzLmJpbi5jb25jYXQoY2h1bmtTbGljZSk7ICAvLyBwdXNoIHRvIG1haW4gc3RyZWFtXG4gICAgICAgICAgfSAgLy8gZm9yXG5cbiAgICAgICB9ICAvLyBmaXJzdCBmcmFtZVxuXG4gICAgICAgaWYgKHRoaXMuZnJhbWUgPiAwKSB7XG4gICAgICAgICAgLy8gTm90IGZpcnN0IGZyYW1lXG4gICAgICAgICAgLy8gQWRkIERhdGEgQ2h1bmtzIGZjVEwvZmRBVFxuICAgICAgICAgIHZhciBjaHVua0FycmF5ID0gdGhpcy5mcmFtZUJ5dGVzLmZpbmRDaHVua0FsbChcIklEQVRcIik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua0FycmF5Lmxlbmd0aDsgaSsrKSB7IFxuICAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmY1RMIGNodW5rIChmcmFtZSBjb250cm9sKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VxTnVtYmVyICs9MTsgIC8vIFNlcXVlbmNlIG51bWJlciBmb3IgZmNUTCBhbmQgZmRBVCBjaHVua3NcbiAgICAgICAgICAgICAgICB2YXIgZmNUTCA9IG5ldyBBcnJheSgwKTtcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDMyVG9CeXRlczQoMjYpICk7ICAgICAgICAgIC8vIGZpeGVkIGxlbmd0aCBkYXRhIDggYnl0ZXNcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIHN0cjRUb0J5dGVzNChcImZjVExcIikgKTsgICAgICAgLy8gY2h1bmsgdHlwZTtcbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDMyVG9CeXRlczQodGhpcy5zZXFOdW1iZXIpICk7ICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyXG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KHRoaXMuY2FudmFzLndpZHRoKSApOyAgIC8vIHdpZHRoXG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KHRoaXMuY2FudmFzLmhlaWdodCkgKTsgIC8vIGhlaWdodFxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNCgwKSApOyAgICAgICAgICAgICAgICAgICAvLyB4LW9mZnNldFxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MzJUb0J5dGVzNCgwKSApOyAgICAgICAgICAgICAgICAgICAvLyB5LW9mZnNldFxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggaW50MTZUb0J5dGVzMih0aGlzLmRlbGF5X251bSkgKTsgICAgICAvLyBEZWxheSBudW1cbiAgICAgICAgICAgICAgICBmY1RMID0gZmNUTC5jb25jYXQoIGludDE2VG9CeXRlczIodGhpcy5kZWxheV9kZW4pICk7ICAgICAgLy8gRGVsYXkgZGVuXG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBbdGhpcy5kaXNwb3NlXSApOyAgLy8gZGlzcG9zZSBtb2RlOyB2YWx1ZXMgWzAsMSwyXSAoMSBieXRlKVxuICAgICAgICAgICAgICAgIGZjVEwgPSBmY1RMLmNvbmNhdCggW3RoaXMuYmxlbmRdICk7ICAgIC8vIGJsZW5kIG1vZGUgdmFsdWVzIFswLDFdICgxIGJ5dGUpXG5cbiAgICAgICAgICAgICAgICB2YXIgY3JjVmFsID0gY3JjMzJiKGZjVEwuc2xpY2UoNCwgNCs0KzI2KSk7XG4gICAgICAgICAgICAgICAgZmNUTCA9IGZjVEwuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KGNyY1ZhbCkgKTsgIC8vIHB1c2ggQ1JDIDQgYnl0ZXNcbiAgICAgICAgICAgICAgICB0aGlzLmFwbmdCeXRlcy5iaW4gPSB0aGlzLmFwbmdCeXRlcy5iaW4uY29uY2F0KGZjVEwpOyAgLy8gcHVzaCB0byBtYWluIHN0cmVhbVxuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAvLyBmZEFUIGNodW5rIChmcmFtZSBkYXRhKVxuICAgICAgICAgICAgIGNodW5rID0gY2h1bmtBcnJheVtpXTsgIC8vIGdldCBJREFUIGNodW5rIG9iamVjdFxuICAgICAgICAgICAgIHZhciBjaHVua19JREFUX2RhdGEgPSB0aGlzLmZyYW1lQnl0ZXMuYmluLnNsaWNlKGNodW5rLmlkeCArIDgsIGNodW5rLmlkeCArIDggKyBjaHVuay5sZW4pO1xuICAgICAgICAgICAgIHZhciBsZW5fZmRBVCA9IGNodW5rLmxlbiArIDQ7ICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgZGF0YSB3aXRoIHNlcSBudW1iZXJcblxuICAgICAgICAgICAgIHRoaXMuc2VxTnVtYmVyICs9MTsgIC8vIFNlcXVlbmNlIG51bWJlciBmb3IgZmNUTCBhbmQgZmRBVCBjaHVua3NcbiAgICAgICAgICAgICB2YXIgZmRBVCA9IG5ldyBBcnJheSgwKTtcbiAgICAgICAgICAgICBmZEFUID0gZmRBVC5jb25jYXQoIGludDMyVG9CeXRlczQobGVuX2ZkQVQpICk7ICAgIC8vIGFwcGVuZCBsZW5ndGggYnl0ZXNcbiAgICAgICAgICAgICBmZEFUID0gZmRBVC5jb25jYXQoIHN0cjRUb0J5dGVzNChcImZkQVRcIikgKTsgICAgICAgLy8gY2h1bmsgdHlwZSBieXRlc1xuICAgICAgICAgICAgIGZkQVQgPSBmZEFULmNvbmNhdCggaW50MzJUb0J5dGVzNCh0aGlzLnNlcU51bWJlcikgKTsgIC8vIGFkZCBzZXF1ZW5jZSBudW1iZXIgYnl0ZXNcbiAgICAgICAgICAgICBmZEFUID0gZmRBVC5jb25jYXQoIGNodW5rX0lEQVRfZGF0YSApOyAgICAgICAgICAgIC8vIGFwcGVuZCBvcmlnaW5hbCBJREFUIGRhdGFcbiAgICAgICAgICAgICB2YXIgY3JjVmFsID0gY3JjMzJiKGZkQVQuc2xpY2UoNCwgNCs0K2xlbl9mZEFUKSk7XG4gICAgICAgICAgICAgZmRBVCA9IGZkQVQuY29uY2F0KCBpbnQzMlRvQnl0ZXM0KGNyY1ZhbCkgKTsgICAgICAvLyBwdXNoIENSQyA0IGJ5dGVzXG5cbiAgICAgICAgICAgICB0aGlzLmFwbmdCeXRlcy5iaW4gPSB0aGlzLmFwbmdCeXRlcy5iaW4uY29uY2F0KGZkQVQpOyAgLy8gcHVzaCB0byBtYWluIHN0cmVhbVxuICAgICAgICAgIH0gIC8vIGZvclxuXG4gICAgICAgfSAgLy8gbm90IGZpcnN0IGZyYW1lXG5cbiAgICAgcmV0dXJuIDA7XG4gIH0gICAvLyBhZGRGcmFtZVxuICBcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAvLyBBZGRzIGZpbmFsIGNodW5rIHRvIHRoZSBBUE5HIHN0cmVhbS5cbiAgICAgICAvLyBJZiB5b3UgZG9uJ3QgY2FsbCB0aGUgZmluaXNoIG1ldGhvZCB0aGUgQVBORyBzdHJlYW0gd2lsbCBub3QgYmUgdmFsaWQuXG4gICAgIGlmICghdGhpcy5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAvLyBBZGQgSW1hZ2UgRW5kIENodW5rIChJRU5EKVxuICAgICAgIHZhciBjaHVua0FycmF5ID0gWzB4MDAsMHgwMCwweDAwLDB4MDAsIDB4NDksMHg0NSwweDRFLDB4NDQsIDB4QUUsMHg0MiwweDYwLDB4ODJdOyAgLy8gZml4ZWRcbiAgICAgICB0aGlzLmFwbmdCeXRlcy5iaW4gPSB0aGlzLmFwbmdCeXRlcy5iaW4uY29uY2F0KGNodW5rQXJyYXkpO1xuXG4gICAgICAgLy8gVXBkYXRlIGFjVEwgY2h1bmsgd2l0aCBudW1iZXIgb2YgZnJhbWVzXG4gICAgICAgdmFyIGNodW5rID0gdGhpcy5hcG5nQnl0ZXMuZmluZENodW5rKFwiYWNUTFwiKTtcbiAgICAgICB2YXIgbkZyYW1lcyA9IGludDMyVG9CeXRlczQodGhpcy5mcmFtZSArIDEpO1xuICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbltjaHVuay5pZHgrOF0gPSBuRnJhbWVzWzBdO1xuICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbltjaHVuay5pZHgrOCsxXSA9IG5GcmFtZXNbMV07XG4gICAgICAgdGhpcy5hcG5nQnl0ZXMuYmluW2NodW5rLmlkeCs4KzJdID0gbkZyYW1lc1syXTtcbiAgICAgICB0aGlzLmFwbmdCeXRlcy5iaW5bY2h1bmsuaWR4KzgrM10gPSBuRnJhbWVzWzNdO1xuXG4gICAgICAgLy8gVXBkYXRlIENSQyBvZiBhY1RMXG4gICAgICAgdmFyIGFjVExzbGljZSA9IHRoaXMuYXBuZ0J5dGVzLmJpbi5zbGljZShjaHVuay5pZHgrNCwgY2h1bmsuaWR4KzQrNCs4KTtcbiAgICAgICB2YXIgY3JjVmFsID0gY3JjMzJiKCBhY1RMc2xpY2UgKTtcbiAgICAgICB2YXIgY3JjQnl0ZXMgPSBpbnQzMlRvQnl0ZXM0KGNyY1ZhbCk7XG4gICAgICAgdGhpcy5hcG5nQnl0ZXMuYmluW2NodW5rLmlkeCs0KzQrOF0gPSBjcmNCeXRlc1swXTtcbiAgICAgICB0aGlzLmFwbmdCeXRlcy5iaW5bY2h1bmsuaWR4KzQrNCs4KzFdID0gY3JjQnl0ZXNbMV07XG4gICAgICAgdGhpcy5hcG5nQnl0ZXMuYmluW2NodW5rLmlkeCs0KzQrOCsyXSA9IGNyY0J5dGVzWzJdO1xuICAgICAgIHRoaXMuYXBuZ0J5dGVzLmJpbltjaHVuay5pZHgrNCs0KzgrM10gPSBjcmNCeXRlc1szXTtcblxuICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgIHRoaXMuY2xvc2VTdHJlYW0gPSB0cnVlO1xuXG4gICAgIHJldHVybiB0cnVlO1xuICB9ICAgLy8gZmluaXNoXG5cbiAgdGhpcy5zdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAvLyBSZXRyaWV2ZXMgdGhlIEFQTkcgc3RyZWFtLlxuICAgICByZXR1cm4gc2VsZi5hcG5nQnl0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59OyAgLy8gQVBOR2VuY29kZXJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFxuZnVuY3Rpb24gQnl0ZUFycmF5KGxlbikge1xuICAvLyBPYmplY3Qgc3BlY2lhbCBkZXNpZ25lZCB0byBzdG9yZSBhIFBORyBpbWFnZS5cbiAgLy8gVXNlZCB0byBnZW5lcmF0ZSBhbiBhbmltYXRlZCBQTkcgaW1hZ2UgYW5kIHByb2Nlc3MgY2h1bmtzLlxuXG4gIHRoaXMuYmluID0gbmV3IEFycmF5KGxlbik7ICAvLyBUbyBzdG9yZSB0aGUgYnl0ZSBhcnJheVxuXG4gIC8vIEEgY2h1bmsgaW4gYSBQTkcgZmlsZSBjb25zaXN0cyBvZiBmb3VyIHBhcnRzOlxuICAvLyAtIExlbmd0aCBvZiBkYXRhICg0IGJ5dGVzKVxuICAvLyAtIENodW5rIHR5cGUgKDQgYnl0ZXMpXG4gIC8vIC0gQ2h1bmsgZGF0YSAobGVuZ3RoIGJ5dGVzKVxuICAvLyAtIENSQyAoQ3ljbGljIFJlZHVuZGFuY3kgQ29kZSAvIENoZWNrc3VtLCA0IGJ5dGVzKVxuICAvLyBUaGVyZSBhcmUgYWJvdXQgMjAgZGlmZmVyZW50IGNodW5rIHR5cGVzLCBidXQgZm9yIGEgbWluaW1hbCBQTkcsIG9ubHkgMyBhcmUgcmVxdWlyZWQ6XG4gIC8vIC0gdGhlIElIRFIgKGltYWdlIGhlYWRlcikgY2h1bmtcbiAgLy8gLSBvbmUgb3IgbW9yZSBJREFUIChpbWFnZSBkYXRhKSBjaHVua3NcbiAgLy8gLSB0aGUgSUVORCAoaW1hZ2UgZW5kKSBjaHVua1xuICBmdW5jdGlvbiBDaHVuayhpZHgsIGxlbiwgdHlwZSkge1xuICAgICAvLyBPYmplY3QgQ2h1bmtcbiAgICAgdGhpcy5pZHggPSBpZHg7ICAgLy8gU3RhcnRpbmcgaW5kZXggb2YgY2h1bmsgaW4gY29udGV4dCBvZiBieXRlIGFycmF5XG4gICAgIHRoaXMubGVuID0gbGVuOyAgIC8vIExlbmd0aCBvZiBkYXRhOiB0b3RhbCBsZW5ndGggb2YgY2h1bmsgaXMgKDQgKyA0ICsgbGVuICsgNClcbiAgICAgdGhpcy50eXBlID0gdHlwZTsgLy8gSUhEUiwgSUVORCwgSURBVCwgYWNUTCwgZmNUTCwgZmRBVCwgZXRjLlxuICB9ICAvLyBDaHVua1xuXG4gIHRoaXMuZmluZENodW5rID1cbiAgICAgZnVuY3Rpb24oaVR5cGUpIHtcbiAgICAgICAgLy8gRmluZCBmaXJzdCBjaHVuayBtYXRjaGluZyBpVHlwZTsgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgICAgdmFyIG9mZnNldCA9IDg7ICAgIC8vIHN0YXJ0IHNlYXJjaFxuICAgICAgICB2YXIgY2h1bmsgPSBudWxsOyAgLy8gZGVmYXVsdCBvdXRwdXQgXG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCB0aGlzLmJpbi5sZW5ndGgpIHtcbiAgICAgICAgICAgdmFyIGNodW5rMSA9IHRoaXMuYmluLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNCk7ICAgICAvLyBsZW5ndGggY2h1bmsgZGF0YVxuICAgICAgICAgICB2YXIgY2h1bmsyID0gdGhpcy5iaW4uc2xpY2Uob2Zmc2V0ICsgNCwgb2Zmc2V0ICsgOCk7IC8vIHR5cGUgb2YgY2h1bmtcblxuICAgICAgICAgICB2YXIgY2h1bmtMZW5ndGggPSBieXRlczRUb0ludDMyKGNodW5rMSk7XG4gICAgICAgICAgIHZhciBjaHVua1R5cGUgPSBieXRlczRUb1N0cjQoY2h1bmsyKTtcbiAgICAgICAgICAgaWYgKGNodW5rVHlwZSA9PT0gaVR5cGUpIHtcbiAgICAgICAgICAgICBjaHVuayA9IG5ldyBDaHVuayhvZmZzZXQsIGNodW5rTGVuZ3RoLCBjaHVua1R5cGUpO1xuICAgICAgICAgICAgIC8vIGNodW5rX2FyciA9IHRoaXMuYmluLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNCArIDQgKyBjaHVua0xlbmd0aCArIDQpO1xuICAgICAgICAgICAgIHJldHVybiBjaHVuazsgIC8vIFNUT1BcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIG9mZnNldCArPSA0ICsgNCArIGNodW5rTGVuZ3RoICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgfSAgLy8gZmluZENodW5rXG5cbiAgdGhpcy5maW5kQ2h1bmtBbGwgPVxuICAgICBmdW5jdGlvbihpVHlwZSkge1xuICAgICAgICAvLyBGaW5kIGFsbCBjaHVua3MgbWF0Y2hpbmcgaVR5cGUuIE91dHB1dCBhcnJheSBvZiBjaHVuayBvYmplY3RzLlxuICAgICAgICB2YXIgb2Zmc2V0ID0gODsgICAgLy8gc3RhcnQgc2VhcmNoXG4gICAgICAgIHZhciBjaHVua0FycmF5ID0gW107ICAvLyBkZWZhdWx0IG91dHB1dCBcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IHRoaXMuYmluLmxlbmd0aCkge1xuICAgICAgICAgICB2YXIgY2h1bmsxID0gdGhpcy5iaW4uc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0KTsgICAgIC8vIGxlbmd0aCBjaHVuayBkYXRhXG4gICAgICAgICAgIHZhciBjaHVuazIgPSB0aGlzLmJpbi5zbGljZShvZmZzZXQgKyA0LCBvZmZzZXQgKyA4KTsgLy8gdHlwZSBvZiBjaHVua1xuXG4gICAgICAgICAgIHZhciBjaHVua0xlbmd0aCA9IGJ5dGVzNFRvSW50MzIoY2h1bmsxKTtcbiAgICAgICAgICAgdmFyIGNodW5rVHlwZSA9IGJ5dGVzNFRvU3RyNChjaHVuazIpO1xuICAgICAgICAgICBpZiAoY2h1bmtUeXBlID09PSBpVHlwZSkge1xuICAgICAgICAgICAgIHZhciBjaHVuayA9IG5ldyBDaHVuayhvZmZzZXQsIGNodW5rTGVuZ3RoLCBjaHVua1R5cGUpO1xuICAgICAgICAgICAgIGNodW5rQXJyYXkucHVzaChjaHVuayk7ICAvLyBhcnJheSBvZiBjaHVuayBvYmplY3RzXG4gICAgICAgICAgICAgLy8gY2h1bmtfYXJyID0gdGhpcy5iaW4uc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA0ICsgNCArIGNodW5rTGVuZ3RoICsgNCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBvZmZzZXQgKz0gNCArIDQgKyBjaHVua0xlbmd0aCArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2h1bmtBcnJheTtcbiAgICAgfSAgLy8gZmluZENodW5rQWxsXG5cbiAgdGhpcy50b1N0ckhleCA9XG4gICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb1N0ckhleCh0aGlzLmJpbik7XG4gICAgIH0gIC8vIHRvU3RySGV4XG5cbiAgdGhpcy50b1N0ckJhc2U2NCA9XG4gICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0Jhc2U2NCh0aGlzLmJpbik7XG4gICAgIH0gIC8vIHRvU3RyQmFzZTY0XG5cbiAgdGhpcy50b1N0ckFzY2lpID1cbiAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvU3RyQXNjaWkodGhpcy5iaW4pO1xuICAgICB9ICAvLyB0b1N0ckFzY2lpXG5cbiAgdGhpcy50b1N0ckRlYyA9XG4gICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb1N0ckRlYyh0aGlzLmJpbik7XG4gICAgIH0gIC8vIHRvU3RyRGVjXG5cbiAgcmV0dXJuIHRoaXM7XG59ICAvLyBCeXRlQXJyYXlcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBieXRlc1RvU3RySGV4KGJ5dGVzKSB7XG4gIC8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBzdHJpbmcgb2YgaGV4YS1kZWNpbWFscy5cbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvciAodmFyIGk9MDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgIHN0ciArPSBkZWNpbWFsVG9IZXgoYnl0ZXNbaV0sIDIpICsgXCIgXCI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn0gIC8vIGJ5dGVzVG9TdHJIZXhcblxuZnVuY3Rpb24gYnl0ZXNUb1N0ckRlYyhieXRlcykge1xuICAvLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gc3RyaW5nIG9mIGRlY2ltYWxzLlxuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICBzdHIgKz0gKCcwMDAnICsgYnl0ZXNbaV0pLnNsaWNlKC0zKTsgIC8vIHBhZGRpbmcgMyBjaGFyXG4gICAgIHN0ciArPSBcIiBcIjtcbiAgfVxuICByZXR1cm4gc3RyO1xufSAgLy8gYnl0ZXNUb1N0ckRlY1xuXG5mdW5jdGlvbiBieXRlc1RvU3RyQXNjaWkoYnl0ZXMpIHtcbiAgLy8gQ29udmVyc2lvbiBieXRlIGFycmF5IG9mIFVuaWNvZGUgKFVURi04KSB2YWx1ZXMgaW50byBjaGFyYWN0ZXJzLlxuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICBpZiAoYnl0ZXNbaV0gPiAzMiAmJiBieXRlc1tpXSA8IDEyNykgeyAgLy8gcHJpbnRhYmxlXG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICAgfVxuICAgICBlbHNlXG4gICAgICAgIHN0ciArPSBcIi5cIjtcbiAgfVxuICByZXR1cm4gc3RyO1xufSAgLy8gYnl0ZXNUb1N0ckFzY2lpXG5cbmZ1bmN0aW9uIG11bHRpTGluZShzdHIsIGxpbmVXaWR0aCkge1xuICAvLyBTcGxpdCBsb25nIHN0cmluZyBpbnRvIGxpbmVzIHdpdGggZml4ZWQgd2lkdGhcbiAgdmFyIHBhdHQgPSBuZXcgUmVnRXhwKFwiKC57XCIgKyBsaW5lV2lkdGggKyBcIn0pXCIsIFwiZ1wiKTsgIC8vIGUuZy4gcmVnZXggLyguezc1fSkvXG4gIHJldHVybiBzdHIuc3BsaXQocGF0dCkuam9pbihcIlxcblwiKS5yZXBsYWNlKC9cXG4rL2csIFwiXFxuXCIpLnRyaW0oKTtcbn0gIC8vIG11bHRpTGluZVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiBkZWNpbWFsVG9IZXgoZGVjaW1hbCwgY2hhcnMpIHtcbiAgLy8gVGhpcyBjb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZyBoZXggQU5EIHBhZHMgbGVhZGluZyB6ZXJvc1xuICByZXR1cm4gKGRlY2ltYWwgKyBNYXRoLnBvdygxNiwgY2hhcnMpKS50b1N0cmluZygxNikuc2xpY2UoLWNoYXJzKS50b1VwcGVyQ2FzZSgpO1xufSAgLy8gZGVjaW1hbFRvSGV4XG5cbmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQoYnl0ZXMpIHtcbiAgLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJhc2U2NCBzdHJpbmcuXG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiBidG9hKHN0cik7XG59ICAvLyBieXRlc1RvQmFzZTY0XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIC8vIENvbnZlcnQgYmFzZTY0IHN0cmluZyB0byBieXRlIGFycmF5LlxuICB2YXIgZGVjb2RlZCA9IGF0b2Ioc3RyKTtcblxuICB2YXIgbGVuID0gZGVjb2RlZC5sZW5ndGg7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJyW2ldID0gZGVjb2RlZC5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn0gIC8vIGJhc2U2NFRvQnl0ZXNcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gc3RyNFRvQnl0ZXM0KGlTdHJpbmcpIHtcbiAgdmFyIGNjID0gbmV3IEFycmF5KDQpO1xuICBjY1swXSA9IGlTdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgY2NbMV0gPSBpU3RyaW5nLmNoYXJDb2RlQXQoMSk7XG4gICBjY1syXSA9IGlTdHJpbmcuY2hhckNvZGVBdCgyKTtcbiAgIGNjWzNdID0gaVN0cmluZy5jaGFyQ29kZUF0KDMpO1xuICAgcmV0dXJuIGNjO1xufSAgLy8gc3RyVG9CeXRlczRcblxuZnVuY3Rpb24gYnl0ZXM0VG9TdHI0KGlCeXRlcykge1xuICB2YXIgY2MgPSBcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGlCeXRlc1swXSkgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaUJ5dGVzWzFdKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpQnl0ZXNbMl0pICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGlCeXRlc1szXSk7XG4gIHJldHVybiBjYztcbn0gIC8vIGJ5dGVzNFRvU3RyNFxuXG5mdW5jdGlvbiBpbnQzMlRvQnl0ZXM0KGlOdW0pIHtcbiAgdmFyIGludDMyID0gaU51bTtcbiAgdmFyIGFyciA9IFswLCAwLCAwLCAwXTtcbiAgZm9yICggdmFyIGlkeCA9IDA7IGlkeCA8IGFyci5sZW5ndGg7IGlkeCArKyApIHtcbiAgICAgdmFyIGJ5dGUgPSBpbnQzMiAmIDB4ZmY7XG4gICAgIGFycltpZHhdID0gYnl0ZTtcbiAgICAgaW50MzIgPSAoaW50MzIgLSBieXRlKSAvIDI1NiA7XG4gIH1cbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG59ICAvLyBpbnQzMlRvQnl0ZXM0XG5cbmZ1bmN0aW9uIGJ5dGVzNFRvSW50MzIoaUJ5dGVzKSB7XG4gIHZhciBudW0gPSAoaUJ5dGVzWzBdIDw8IDI0KSArIChpQnl0ZXNbMV0gPDwgMTIpICsgKGlCeXRlc1syXSA8PCA4KSArIGlCeXRlc1szXTtcbiAgcmV0dXJuIG51bTtcbn0gIC8vIGJ5dGVzNFRvSW50MzJcblxuZnVuY3Rpb24gaW50MTZUb0J5dGVzMihpTnVtKSB7XG4gIHZhciBpbnQxNiA9IGlOdW07XG4gIHZhciBhcnIgPSBbMCwgMF07XG4gIGZvciAoIHZhciBpZHggPSAwOyBpZHggPCBhcnIubGVuZ3RoOyBpZHggKysgKSB7XG4gICAgIHZhciBieXRlID0gaW50MTYgJiAweGZmO1xuICAgICBhcnJbaWR4XSA9IGJ5dGU7XG4gICAgIGludDE2ID0gKGludDE2IC0gYnl0ZSkgLyAyNTYgO1xuICB9XG4gIHJldHVybiBhcnIucmV2ZXJzZSgpO1xufSAgLy8gaW50MTZUb0J5dGVzMlxuXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG5cbi8vIFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhcbi8qXG5JbXBsZW1lbnRhdGlvbiBvZiBDUkMzMmIgY2FsY3VsYXRpb24uXG5DYWxjdWxhdGlvbiBmdW5jdGlvbjogdmFyIHJlcyA9IGNyYzMyYihpVmFyKVxuLSBpVmFyIGlzIHN0cmluZyBvciBhcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyXG4tIHJlcyBpcyB1bnNpZ25lZCBpbnRlZ2VyICg0IGJ5dGVzKVxuRm9ybWF0IGZ1bmN0aW9uIGZvciBvdXRwdXQgQ1JDMzIgY2FsY3VsYXRpb246IGZvcm1hdENSQzMyKGlWYWwsIGlUeXBlKVxuXG5UZXN0Y2FzZXM6XG5JTjogWzB4NDksMHg0OCwweDQ0LDB4NTIsMHgwMCwweDAwLDB4MDAsMHgwMSwweDAwLDB4MDAsMHgwMCwweDAxLDB4MDgsMHgwMiwweDAwLDB4MDAsMHgwMF07XG5PVVQ6ICBcIjkwNzc1M0RFXCIgICBvciBbMTQ0LDExOSw4MywyMjJdICAgKElIRFIgY2h1bmspXG5JTjogWzB4NDksMHg0NSwweDRFLDB4NDRdIG9yIFs3Myw2OSw3OCw2OF1cbk9VVDogXCJBRTQyNjA4MlwiICBvciAgWzE3NCw2Niw5NiwxMzBdICAoSUVORCBjaHVuaylcbklOOiBcIlNoZWV0SlNcIlxuT1VUOiBcIjlERDAzOTIyXCIgb3IgIFsxNTcsMjA4LDU3LDM0XVxuKi9cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgYV90YWJsZSA9IFwiMDAwMDAwMDAgNzcwNzMwOTYgRUUwRTYxMkMgOTkwOTUxQkEgMDc2REM0MTkgNzA2QUY0OEYgRTk2M0E1MzUgOUU2NDk1QTMgMEVEQjg4MzIgNzlEQ0I4QTQgRTBENUU5MUUgOTdEMkQ5ODggMDlCNjRDMkIgN0VCMTdDQkQgRTdCODJEMDcgOTBCRjFEOTEgMURCNzEwNjQgNkFCMDIwRjIgRjNCOTcxNDggODRCRTQxREUgMUFEQUQ0N0QgNkREREU0RUIgRjRENEI1NTEgODNEMzg1QzcgMTM2Qzk4NTYgNjQ2QkE4QzAgRkQ2MkY5N0EgOEE2NUM5RUMgMTQwMTVDNEYgNjMwNjZDRDkgRkEwRjNENjMgOEQwODBERjUgM0I2RTIwQzggNEM2OTEwNUUgRDU2MDQxRTQgQTI2NzcxNzIgM0MwM0U0RDEgNEIwNEQ0NDcgRDIwRDg1RkQgQTUwQUI1NkIgMzVCNUE4RkEgNDJCMjk4NkMgREJCQkM5RDYgQUNCQ0Y5NDAgMzJEODZDRTMgNDVERjVDNzUgRENENjBEQ0YgQUJEMTNENTkgMjZEOTMwQUMgNTFERTAwM0EgQzhENzUxODAgQkZEMDYxMTYgMjFCNEY0QjUgNTZCM0M0MjMgQ0ZCQTk1OTkgQjhCREE1MEYgMjgwMkI4OUUgNUYwNTg4MDggQzYwQ0Q5QjIgQjEwQkU5MjQgMkY2RjdDODcgNTg2ODRDMTEgQzE2MTFEQUIgQjY2NjJEM0QgNzZEQzQxOTAgMDFEQjcxMDYgOThEMjIwQkMgRUZENTEwMkEgNzFCMTg1ODkgMDZCNkI1MUYgOUZCRkU0QTUgRThCOEQ0MzMgNzgwN0M5QTIgMEYwMEY5MzQgOTYwOUE4OEUgRTEwRTk4MTggN0Y2QTBEQkIgMDg2RDNEMkQgOTE2NDZDOTcgRTY2MzVDMDEgNkI2QjUxRjQgMUM2QzYxNjIgODU2NTMwRDggRjI2MjAwNEUgNkMwNjk1RUQgMUIwMUE1N0IgODIwOEY0QzEgRjUwRkM0NTcgNjVCMEQ5QzYgMTJCN0U5NTAgOEJCRUI4RUEgRkNCOTg4N0MgNjJERDFEREYgMTVEQTJENDkgOENEMzdDRjMgRkJENDRDNjUgNERCMjYxNTggM0FCNTUxQ0UgQTNCQzAwNzQgRDRCQjMwRTIgNEFERkE1NDEgM0REODk1RDcgQTREMUM0NkQgRDNENkY0RkIgNDM2OUU5NkEgMzQ2RUQ5RkMgQUQ2Nzg4NDYgREE2MEI4RDAgNDQwNDJENzMgMzMwMzFERTUgQUEwQTRDNUYgREQwRDdDQzkgNTAwNTcxM0MgMjcwMjQxQUEgQkUwQjEwMTAgQzkwQzIwODYgNTc2OEI1MjUgMjA2Rjg1QjMgQjk2NkQ0MDkgQ0U2MUU0OUYgNUVERUY5MEUgMjlEOUM5OTggQjBEMDk4MjIgQzdEN0E4QjQgNTlCMzNEMTcgMkVCNDBEODEgQjdCRDVDM0IgQzBCQTZDQUQgRURCODgzMjAgOUFCRkIzQjYgMDNCNkUyMEMgNzRCMUQyOUEgRUFENTQ3MzkgOUREMjc3QUYgMDREQjI2MTUgNzNEQzE2ODMgRTM2MzBCMTIgOTQ2NDNCODQgMEQ2RDZBM0UgN0E2QTVBQTggRTQwRUNGMEIgOTMwOUZGOUQgMEEwMEFFMjcgN0QwNzlFQjEgRjAwRjkzNDQgODcwOEEzRDIgMUUwMUYyNjggNjkwNkMyRkUgRjc2MjU3NUQgODA2NTY3Q0IgMTk2QzM2NzEgNkU2QjA2RTcgRkVENDFCNzYgODlEMzJCRTAgMTBEQTdBNUEgNjdERDRBQ0MgRjlCOURGNkYgOEVCRUVGRjkgMTdCN0JFNDMgNjBCMDhFRDUgRDZENkEzRTggQTFEMTkzN0UgMzhEOEMyQzQgNEZERkYyNTIgRDFCQjY3RjEgQTZCQzU3NjcgM0ZCNTA2REQgNDhCMjM2NEIgRDgwRDJCREEgQUYwQTFCNEMgMzYwMzRBRjYgNDEwNDdBNjAgREY2MEVGQzMgQTg2N0RGNTUgMzE2RThFRUYgNDY2OUJFNzkgQ0I2MUIzOEMgQkM2NjgzMUEgMjU2RkQyQTAgNTI2OEUyMzYgQ0MwQzc3OTUgQkIwQjQ3MDMgMjIwMjE2QjkgNTUwNTI2MkYgQzVCQTNCQkUgQjJCRDBCMjggMkJCNDVBOTIgNUNCMzZBMDQgQzJEN0ZGQTcgQjVEMENGMzEgMkNEOTlFOEIgNUJERUFFMUQgOUI2NEMyQjAgRUM2M0YyMjYgNzU2QUEzOUMgMDI2RDkzMEEgOUMwOTA2QTkgRUIwRTM2M0YgNzIwNzY3ODUgMDUwMDU3MTMgOTVCRjRBODIgRTJCODdBMTQgN0JCMTJCQUUgMENCNjFCMzggOTJEMjhFOUIgRTVENUJFMEQgN0NEQ0VGQjcgMEJEQkRGMjEgODZEM0QyRDQgRjFENEUyNDIgNjhEREIzRjggMUZEQTgzNkUgODFCRTE2Q0QgRjZCOTI2NUIgNkZCMDc3RTEgMThCNzQ3NzcgODgwODVBRTYgRkYwRjZBNzAgNjYwNjNCQ0EgMTEwMTBCNUMgOEY2NTlFRkYgRjg2MkFFNjkgNjE2QkZGRDMgMTY2Q0NGNDUgQTAwQUUyNzggRDcwREQyRUUgNEUwNDgzNTQgMzkwM0IzQzIgQTc2NzI2NjEgRDA2MDE2RjcgNDk2OTQ3NEQgM0U2RTc3REIgQUVEMTZBNEEgRDlENjVBREMgNDBERjBCNjYgMzdEODNCRjAgQTlCQ0FFNTMgREVCQjlFQzUgNDdCMkNGN0YgMzBCNUZGRTkgQkRCREYyMUMgQ0FCQUMyOEEgNTNCMzkzMzAgMjRCNEEzQTYgQkFEMDM2MDUgQ0RENzA2OTMgNTRERTU3MjkgMjNEOTY3QkYgQjM2NjdBMkUgQzQ2MTRBQjggNUQ2ODFCMDIgMkE2RjJCOTQgQjQwQkJFMzcgQzMwQzhFQTEgNUEwNURGMUIgMkQwMkVGOERcIjtcblxudmFyIGJfdGFibGUgPSBhX3RhYmxlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKHMpeyByZXR1cm4gcGFyc2VJbnQocywxNikgfSk7XG5cbmZ1bmN0aW9uIGNyYzMyYihpVmFyKSB7XG4gIC8vIENhbGN1bGF0ZSBDUkMzMmIgdmFsdWUgb2YgaVZhciAoc3RyaW5nIG9yIGFycmF5IG9mIGludGVnZXJzIChieXRlcykpXG4gIGlmICh0eXBlb2YgaVZhciA9PSBcInN0cmluZ1wiIHx8IGlWYXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gaW50ZWdlciBhcnJheVxuICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGlWYXIubGVuZ3RoKTtcbiAgICAgZm9yICh2YXIgaT0wOyBpIDwgaVZhci5sZW5ndGg7IGkrKykgeyBhcnJbaV0gPSBpVmFyLmNoYXJDb2RlQXQoaSk7IH1cbiAgfSBcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpVmFyKSkge1xuICAgICB2YXIgYXJyID0gaVZhcjtcbiAgfVxuICBlbHNlIHtcbiAgICAgYWxlcnQoXCJCYWQgaW5wdXQgZm9yIENSQzMyIGNhbGN1bGF0aW9uOiBcIiArIGlWYXIpO1xuICAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBjcmMgPSAtMTtcbiAgZm9yICh2YXIgaT0wLCBpVG9wID0gYXJyLmxlbmd0aDsgaSA8IGlUb3A7IGkrKykge1xuICAgICBjcmMgPSAoIGNyYyA+Pj4gOCApIF4gYl90YWJsZVsoIGNyYyBeIGFycltpXSApICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbn0gIC8vIGNyYzMyYlxuXG5cbmZ1bmN0aW9uIGZvcm1hdENSQzMyKGlWYWwsIGlUeXBlKSB7XG4gIC8vIGlWYWw6IHJlc3VsdCBvZiBDUkMzMi5zdHIgb3IgQ1JDMzIuYnVmIChmcm9tIGNyYzMyLmpzKVxuICAvLyBGb3JtYXQgdHlwZXM6IHVpbnQsIGhleHMsIGhleGJcblxuICBmdW5jdGlvbiBscGFkKHMsIGxlbiwgY2hyKXtcbiAgICAgdmFyIEwgPSBsZW4gLSBzLmxlbmd0aCwgQyA9IGNociB8fCBcIiBcIjtcbiAgICAgaWYoTCA8PSAwKSByZXR1cm4gcztcbiAgICAgcmV0dXJuIG5ldyBBcnJheShMKzEpLmpvaW4oQykgKyBzO1xuICB9ICAvLyBscGFkXG5cbiAgdmFyIHJlcztcbiAgc3dpdGNoKGlUeXBlKSB7XG4gICAgIGNhc2UgXCJ1aW50XCI6ICAvLyB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICByZXMgPSBpVmFsO1xuICAgICAgICAgYnJlYWs7XG4gICAgIGNhc2UgXCJoZXhzXCI6ICAvLyBoZXhhZGVjIHN0cmluZ1xuICAgICAgICAgcmVzID0gbHBhZChpVmFsLnRvU3RyaW5nKDE2KSw4LCcwJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgIGJyZWFrO1xuICAgICBjYXNlIFwiaGV4YlwiOiAgLy8gYnl0ZSBhcnJheSAoZmlyc3QgaW5kZXggaXMgaGlnaClcbiAgICAgICAgIHJlcyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgIHZhciBoZXhzID0gbHBhZChpVmFsLnRvU3RyaW5nKDE2KSw4LCcwJyk7XG4gICAgICAgICByZXNbMF0gPSBwYXJzZUludChoZXhzLnN1YnN0cmluZygwLCAyKSwxNik7XG4gICAgICAgICByZXNbMV0gPSBwYXJzZUludChoZXhzLnN1YnN0cmluZygyLCA0KSwxNik7XG4gICAgICAgICByZXNbMl0gPSBwYXJzZUludChoZXhzLnN1YnN0cmluZyg0LCA2KSwxNik7XG4gICAgICAgICByZXNbM10gPSBwYXJzZUludChoZXhzLnN1YnN0cmluZyg2LCA4KSwxNik7XG4gICAgICAgICBicmVhaztcbiAgICAgZGVmYXVsdDpcbiAgICAgICAgIHJlcyA9IGlWYWw7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn0gIC8vIGZvcm1hdENSQzMyXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiIsImltcG9ydCB7IEFQTkdlbmNvZGVyIH0gZnJvbSAnLi4vbGlicy9jYW52YXMyYXBuZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1ha2VBcG5nRXhwb3J0TGluayhpbWFnZXMsIGRlbGF5LCBjYW52YXNTaXplLCBjYWxsYmFjaykge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjYW52YXNTaXplKTtcbiAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgY2FudmFzU2l6ZSk7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gIGNvbnN0IGludGVydmFsID0gZGVsYXkgJiYgMSAvIGRlbGF5O1xuICBjb25zdCBlbmNvZGVyID0gbmV3IEFQTkdlbmNvZGVyKGNhbnZhcyk7XG4gIGVuY29kZXIuc2V0RGVsYXkoaW50ZXJ2YWwpO1xuICBlbmNvZGVyLnNldFJlcGVhdCgwKTtcblxuICBlbmNvZGVyLnN0YXJ0KCk7XG5cbiAgbGV0IGN1ckltZyA9IDA7XG4gIGNvbnN0IGxhc3RJbWcgPSBpbWFnZXMubGVuZ3RoIC0gMTtcblxuICBmdW5jdGlvbiBhZGRJbWcoKSB7XG4gICAgaWYgKGN1ckltZyA9PT0gbGFzdEltZykge1xuICAgICAgZW5jb2Rlci5maW5pc2goKTtcbiAgICAgIGNhbGxiYWNrKGVuY29kZXIuc3RyZWFtKCkudG9TdHJCYXNlNjQoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VySW1nICs9IDE7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgIGVuY29kZXIuYWRkRnJhbWUoKTtcblxuICAgIGltYWdlLnNyYyA9IGltYWdlc1tjdXJJbWddO1xuICB9XG5cbiAgaW1hZ2Uub25sb2FkID0gYWRkSW1nO1xuICBpbWFnZS5zcmMgPSBpbWFnZXNbY3VySW1nXTtcbn1cbiIsImltcG9ydCB7IFNvcnRhYmxlIH0gZnJvbSAnQHNob3BpZnkvZHJhZ2dhYmxlJztcbmltcG9ydCAnLi9zY3JlZW5zL2luZGV4LmNzcyc7XG5pbXBvcnQgbWFrZUdpZkV4cG9ydExpbmsgZnJvbSAnLi9tb2R1bGVzL2dpZi1leHBvcnQnO1xuaW1wb3J0IG1ha2VBcG5nRXhwb3J0TGluayBmcm9tICcuL21vZHVsZXMvYXBuZy1leHBvcnQnO1xuXG5jb25zdCBtYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKTtcblxuZnVuY3Rpb24gYWRkRWxlbWVudChlbGVtZW50LCBlbGVtZW50Q2xhc3MsIGVsZW1lbnRJZCwgcGFyZW50KSB7XG4gIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtLmlkID0gZWxlbWVudElkO1xuICBlbGVtLmNsYXNzTmFtZSA9IGVsZW1lbnRDbGFzcztcbiAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICByZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gYWRkKGVsZW1lbnQsIGVsZW1lbnRDbGFzcywgZWxlbWVudElkLCBlbGVtWCwgaXNBZnRlcikge1xuICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50KTtcbiAgZWxlbS5pZCA9IGVsZW1lbnRJZDtcbiAgZWxlbS5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3M7XG4gIGlmIChpc0FmdGVyKSB7XG4gICAgZWxlbVguYWZ0ZXIoZWxlbSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbVguYmVmb3JlKGVsZW0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufVxuXG5sZXQgc2l6ZUluU3F1YXJlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzcXVhcmVzJykgfHwgMzI7XG5jb25zdCBjYW52YXNTaXplID0gNTEyO1xubGV0IHNjYWxlID0gY2FudmFzU2l6ZSAvIHNpemVJblNxdWFyZXM7XG5jb25zdCBnYWxsZXJ5ID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZ2FsbGVyeScpKSB8fCB7fTtcbmNvbnN0IGdhbGxlcnlLZXlzID0gT2JqZWN0LmtleXMoZ2FsbGVyeSk7XG5cbmNvbnN0IHRvb2xzQ29udGFpbmVyID0gYWRkRWxlbWVudCgnc2VjdGlvbicsICd0b29scy1jb250YWluZXInLCAndG9vbHNDb250YWluZXInLCBtYWluKTtcbmNvbnN0IHJlc2l6ZVNldCA9IGFkZEVsZW1lbnQoJ2RpdicsICdyZXNpemUtc2V0JywgJ3Jlc2l6ZVNldCcsIHRvb2xzQ29udGFpbmVyKTtcblxuY29uc3QgbnVtYmVyT2ZTaXplcyA9IDQ7XG5mb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZlNpemVzOyBpICs9IDEpIHtcbiAgY29uc3QgZWxlbSA9IGFkZEVsZW1lbnQoJ2RpdicsIGBzaXplIHgke2l9YCwgYHNpemUke2l9YCwgcmVzaXplU2V0KTtcbiAgZWxlbS5pbm5lckhUTUwgPSBgeCR7aX1gO1xufVxuXG5sZXQgbW91c2VTaXplID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ21vdXNlU2l6ZScpIHx8IDE7XG5cbmNvbnN0IHRvb2xzU2V0ID0gYWRkRWxlbWVudCgnZGl2JywgJ3Rvb2xzLXNldCcsICd0b29sc1NldCcsIHRvb2xzQ29udGFpbmVyKTtcbmNvbnN0IG51bWJlck9mSW5zdHJ1bWVudHMgPSA2O1xuY29uc3QgdG9vbHNMaXN0ID0gWydwZW4nLCAnZXJhc2VyJywgJ3N0cm9rZScsICdidWNrZXQnLCAnb25lY29sb3InLCAncGlja2VyJ107XG5mb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZkluc3RydW1lbnRzOyBpICs9IDEpIHtcbiAgYWRkRWxlbWVudCgnZGl2JywgYHRvb2wgJHt0b29sc0xpc3RbaSAtIDFdfWAsIHRvb2xzTGlzdFtpIC0gMV0sIHRvb2xzU2V0KTtcbn1cblxuY29uc3QgcGFnZVNpemVDb250YWluZXIgPSBhZGRFbGVtZW50KCdkaXYnLCAncGFnZS1zaXplcycsICdwYWdlU2l6ZXMnLCB0b29sc0NvbnRhaW5lcik7XG5jb25zdCBwYWdlU2l6ZTMyID0gYWRkRWxlbWVudCgnZGl2JywgJ3BhZ2UtcyBzaXplMzInLCAnc2l6ZTMyJywgcGFnZVNpemVDb250YWluZXIpO1xucGFnZVNpemUzMi5pbm5lckhUTUwgPSAnMzInO1xuY29uc3QgcGFnZVNpemU2NCA9IGFkZEVsZW1lbnQoJ2RpdicsICdwYWdlLXMgc2l6ZTY0JywgJ3NpemU2NCcsIHBhZ2VTaXplQ29udGFpbmVyKTtcbnBhZ2VTaXplNjQuaW5uZXJIVE1MID0gJzY0JztcbmNvbnN0IHBhZ2VTaXplMTI4ID0gYWRkRWxlbWVudCgnZGl2JywgJ3BhZ2UtcyBzaXplMTI4JywgJ3NpemUxMjgnLCBwYWdlU2l6ZUNvbnRhaW5lcik7XG5wYWdlU2l6ZTEyOC5pbm5lckhUTUwgPSAnMTI4JztcblxuY29uc3QgZGVmYXVsdENvbG9yID0gJyNmZmZmZmYnO1xuXG5jb25zdCBjb2xvcnNCdXR0b24gPSBhZGRFbGVtZW50KCdpbnB1dCcsICdjb2xvcnMtYnV0dG9uJywgJ2NvbG9yc0J1dHRvbicsIHRvb2xzQ29udGFpbmVyKTtcbmNvbG9yc0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY29sb3InKTtcbmNvbG9yc0J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NvbG9yJykgfHwgZGVmYXVsdENvbG9yKTtcblxubGV0IGN1cnJlbnRDb2xvciA9IGNvbG9yc0J1dHRvbi52YWx1ZTtcblxuY29uc3Qgc2hvcnRjdXRzQnV0dG9uID0gYWRkRWxlbWVudCgnZGl2JywgJ3Nob3J0Y3V0cycsICdzaG9ydGN1dHMnLCB0b29sc0NvbnRhaW5lcik7XG5cbmNvbnN0IGZyYW1lc0NvbnRhaW5lciA9IGFkZEVsZW1lbnQoJ2RpdicsICdmcmFtZXMtY29udGFpbmVyJywgJ2ZyYW1lc0NvbnRhaW5lcicsIG1haW4pO1xuXG5sZXQgZnJhbWVOdW1iZXIgPSAwO1xubGV0IGFjdGl2ZUZyYW1lTnVtYmVyID0gMTtcbmxldCBmcmFtZVRvQWN0aW9uID0gMTtcblxuY29uc3QgYWRkRnJhbWVCdXR0b24gPSBhZGRFbGVtZW50KCdkaXYnLCAnYWRkLWZyYW1lJywgJ2FkZEZyYW1lJywgZnJhbWVzQ29udGFpbmVyKTtcbmFkZEZyYW1lQnV0dG9uLmlubmVySFRNTCA9ICdBZGQgbmV3IGZyYW1lJztcblxuZnVuY3Rpb24gZmlsbEltYWdlKGNvbG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRJbWFnZSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJblNxdWFyZXM7IGkgKz0gMSkge1xuICAgIGN1cnJlbnRJbWFnZS5wdXNoKFtdKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemVJblNxdWFyZXM7IGogKz0gMSkge1xuICAgICAgY3VycmVudEltYWdlW2ldW2pdID0gY29sb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXJyZW50SW1hZ2U7XG59XG5cbmxldCBpbWFnZSA9IGZpbGxJbWFnZShkZWZhdWx0Q29sb3IpO1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFtZSh2YWwsIGVsZW0sIGZyYW1lKSB7XG4gIGlmIChmcmFtZSA+IGZyYW1lTnVtYmVyKSB7XG4gICAgZnJhbWVOdW1iZXIgPSBmcmFtZTtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZU51bWJlciArPSAxO1xuICB9XG5cbiAgY29uc3QgZnJhbWVUb0ludGVyYWN0ID0gZnJhbWUgfHwgZnJhbWVOdW1iZXI7XG5cbiAgYWRkKCdkaXYnLCAnZnJhbWUnLCBgZnJhbWUke2ZyYW1lVG9JbnRlcmFjdH1gLCBlbGVtLCB2YWwpO1xuXG4gIGFkZEVsZW1lbnQoJ2RpdicsICdmcmFtZS1waWMnLCBgZnJhbWVQaWMke2ZyYW1lVG9JbnRlcmFjdH1gLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgZnJhbWUke2ZyYW1lVG9JbnRlcmFjdH1gKSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZVBpYyR7ZnJhbWVUb0ludGVyYWN0fWApLnNldEF0dHJpYnV0ZSgnZGF0YS1mcmFtZScsIGAke2ZyYW1lVG9JbnRlcmFjdH1gKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGZyYW1lUGljJHtmcmFtZVRvSW50ZXJhY3R9YCkuc2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicsICdpbWcnKTtcbiAgY29uc3QgZWxlbUZyYW1lUGljID0gZWxlbS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY3Rpb249XCJpbWdcIl0nKTtcbiAgY29uc3QgcHJldkZyYW1lID0gZWxlbUZyYW1lUGljICYmIGVsZW1GcmFtZVBpYy5kYXRhc2V0LmZyYW1lO1xuXG4gIGlmICh2YWwgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGltZyR7cHJldkZyYW1lfWApKSB7XG4gICAgY29uc3QgY29weUltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBpbWcke3ByZXZGcmFtZX1gKS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIGNvcHlJbWcuc2V0QXR0cmlidXRlKCdpZCcsIGBpbWcke2ZyYW1lVG9JbnRlcmFjdH1gKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgZnJhbWVQaWMke2ZyYW1lVG9JbnRlcmFjdH1gKS5hcHBlbmRDaGlsZChjb3B5SW1nKTtcbiAgfVxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGltZyR7ZnJhbWVUb0ludGVyYWN0fWApKSB7XG4gICAgZ2FsbGVyeVtgaW1nJHtmcmFtZVRvSW50ZXJhY3R9YF0gPSBpbWFnZS5tYXAoKGxpbmUpID0+IFsuLi5saW5lXSk7XG4gIH0gZWxzZSB7XG4gICAgZ2FsbGVyeVtgaW1nJHtmcmFtZVRvSW50ZXJhY3R9YF0gPSBnYWxsZXJ5W2BpbWcke2ZyYW1lVG9JbnRlcmFjdH1gXSB8fCBmaWxsSW1hZ2UoZGVmYXVsdENvbG9yKTtcbiAgfVxuICBhZGRFbGVtZW50KCdkaXYnLCAnZnJhbWUtYnV0LWNvbnRhaW5lcicsIGBmcmFtZUJ1dENvbnRhaW5lciR7ZnJhbWVUb0ludGVyYWN0fWAsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZSR7ZnJhbWVUb0ludGVyYWN0fWApKTtcbiAgYWRkRWxlbWVudCgnZGl2JywgJ2ZyYW1lLW51bWJlcicsIGBmcmFtZSR7ZnJhbWVUb0ludGVyYWN0fU51bWJlcmAsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZUJ1dENvbnRhaW5lciR7ZnJhbWVUb0ludGVyYWN0fWApKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGZyYW1lJHtmcmFtZVRvSW50ZXJhY3R9TnVtYmVyYCkuaW5uZXJIVE1MID0gYCR7ZnJhbWVUb0ludGVyYWN0fWA7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZSR7ZnJhbWVUb0ludGVyYWN0fU51bWJlcmApLnNldEF0dHJpYnV0ZSgnZGF0YS1hY3Rpb24nLCAnbnVtYmVyJyk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZSR7ZnJhbWVUb0ludGVyYWN0fU51bWJlcmApLnNldEF0dHJpYnV0ZSgnZGF0YS1mcmFtZScsIGAke2ZyYW1lVG9JbnRlcmFjdH1gKTtcbiAgYWRkRWxlbWVudCgnZGl2JywgJ2NvcHktZnJhbWUnLCBgY29weUZyYW1lJHtmcmFtZVRvSW50ZXJhY3R9YCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGZyYW1lQnV0Q29udGFpbmVyJHtmcmFtZVRvSW50ZXJhY3R9YCkpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgY29weUZyYW1lJHtmcmFtZVRvSW50ZXJhY3R9YCkuc2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbicsICdjb3B5Jyk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBjb3B5RnJhbWUke2ZyYW1lVG9JbnRlcmFjdH1gKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZnJhbWUnLCBgJHtmcmFtZVRvSW50ZXJhY3R9YCk7XG4gIGFkZEVsZW1lbnQoJ2RpdicsICdkZWxldGUtZnJhbWUnLCBgZGVsZXRlRnJhbWUke2ZyYW1lVG9JbnRlcmFjdH1gLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgZnJhbWVCdXRDb250YWluZXIke2ZyYW1lVG9JbnRlcmFjdH1gKSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBkZWxldGVGcmFtZSR7ZnJhbWVUb0ludGVyYWN0fWApLnNldEF0dHJpYnV0ZSgnZGF0YS1hY3Rpb24nLCAnZGVsZXRlJyk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBkZWxldGVGcmFtZSR7ZnJhbWVUb0ludGVyYWN0fWApLnNldEF0dHJpYnV0ZSgnZGF0YS1mcmFtZScsIGAke2ZyYW1lVG9JbnRlcmFjdH1gKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtbnVtYmVyJykubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZyYW1lLW51bWJlcicpW2ldKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtbnVtYmVyJylbaV0uaW5uZXJIVE1MID0gYCR7aSArIDF9YDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgY2FudmFzQ29udGFpbmVyID0gYWRkRWxlbWVudCgnc2VjdGlvbicsICdjYW52YXMtY29udGFpbmVyJywgJ2NhbnZhc0NvbnRhaW5lcicsIG1haW4pO1xuY29uc3QgY2FudmFzID0gYWRkRWxlbWVudCgnY2FudmFzJywgJ2NhbnZhcycsICdjYW52YXMnLCBjYW52YXNDb250YWluZXIpO1xuY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjYW52YXNTaXplKTtcbmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNhbnZhc1NpemUpO1xuXG5jb25zdCBwcmV2aWV3QmxvY2sgPSBhZGRFbGVtZW50KCdkaXYnLCAncHJldmlldy1ibG9jaycsICdwcmV2aWV3QmxvY2snLCBtYWluKTtcbmFkZEVsZW1lbnQoJ2RpdicsICdwcmV2aWV3LWltYWdlJywgJ3ByZXZpZXdJbWFnZScsIHByZXZpZXdCbG9jayk7XG5jb25zdCBmcHNCbG9jayA9IGFkZEVsZW1lbnQoJ2RpdicsICdmcHMtYmxvY2snLCAnZnBzQmxvY2snLCBwcmV2aWV3QmxvY2spO1xuY29uc3QgbWludXNGcHMgPSBhZGRFbGVtZW50KCdkaXYnLCAnZnBzLWJ1dHRvbiBtaW51cy1mcHMnLCAnbWludXNGcHMnLCBmcHNCbG9jayk7XG5taW51c0Zwcy5pbm5lckhUTUwgPSAnLSc7XG5jb25zdCBmcHNWYWx1ZSA9IGFkZEVsZW1lbnQoJ2RpdicsICdmcHMtYnV0dG9uIGZwcycsICdmcHMnLCBmcHNCbG9jayk7XG5sZXQgZnBzID0gMDtcbmZwc1ZhbHVlLmlubmVySFRNTCA9IGZwcztcblxuY29uc3QgcGx1c0ZwcyA9IGFkZEVsZW1lbnQoJ2RpdicsICdmcHMtYnV0dG9uIHBsdXMtZnBzJywgJ3BsdXNGcHMnLCBmcHNCbG9jayk7XG5wbHVzRnBzLmlubmVySFRNTCA9ICcrJztcblxuY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbmZ1bmN0aW9uIGRyYXdJbWFnZShpbWcsIGZyYW1lKSB7XG4gIGNvbnN0IGZyYW1lVG9JbnRlcmFjdCA9IGZyYW1lIHx8IGFjdGl2ZUZyYW1lTnVtYmVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJblNxdWFyZXM7IGkgKz0gMSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZUluU3F1YXJlczsgaiArPSAxKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gaW1nW2ldW2pdO1xuICAgICAgY3R4LmZpbGxSZWN0KGogKiBzY2FsZSwgaSAqIHNjYWxlLCBzY2FsZSwgc2NhbGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGltYWdlTWluaSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBpbWcke2ZyYW1lVG9JbnRlcmFjdH1gKSB8fCBuZXcgSW1hZ2UoKTtcbiAgaW1hZ2VNaW5pLmhlaWdodCA9ICcxMTAnO1xuICBpbWFnZU1pbmkud2lkdGggPSAnMTEwJztcbiAgaW1hZ2VNaW5pLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICBpZiAoIWltYWdlTWluaS5oYXNBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICBpbWFnZU1pbmkuc2V0QXR0cmlidXRlKCdpZCcsIGBpbWcke2ZyYW1lVG9JbnRlcmFjdH1gKTtcbiAgfVxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGltZyR7ZnJhbWVUb0ludGVyYWN0fWApKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGltZyR7ZnJhbWVUb0ludGVyYWN0fWApLnJlbW92ZSgpO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBmcmFtZVBpYyR7ZnJhbWVUb0ludGVyYWN0fWApLmFwcGVuZENoaWxkKGltYWdlTWluaSk7XG4gIGltYWdlTWluaS5zZXRBdHRyaWJ1dGUoJ2lkJywgYGltZyR7ZnJhbWVUb0ludGVyYWN0fWApO1xuICBnYWxsZXJ5W2BpbWcke2ZyYW1lVG9JbnRlcmFjdH1gXSA9IGltZy5tYXAoKGxpbmUpID0+IFsuLi5saW5lXSk7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnYWxsZXJ5JywgSlNPTi5zdHJpbmdpZnkoZ2FsbGVyeSkpO1xufVxuXG5cbmlmIChnYWxsZXJ5S2V5cy5sZW5ndGgpIHtcbiAgZ2FsbGVyeUtleXMuZm9yRWFjaCgoZnJhbWVOYW1lKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEZyYW1lID0gcGFyc2VJbnQoZnJhbWVOYW1lLnJlcGxhY2UoL1xcRC9nLCAnJyksIDEwKTtcblxuICAgIGFjdGl2ZUZyYW1lTnVtYmVyID0gY3VycmVudEZyYW1lO1xuICAgIGltYWdlID0gZ2FsbGVyeVtmcmFtZU5hbWVdO1xuICAgIGNyZWF0ZUZyYW1lKGZhbHNlLCBhZGRGcmFtZUJ1dHRvbiwgY3VycmVudEZyYW1lKTtcbiAgICBkcmF3SW1hZ2UoZ2FsbGVyeVtmcmFtZU5hbWVdLCBjdXJyZW50RnJhbWUpO1xuICB9KTtcbn0gZWxzZSB7XG4gIGNyZWF0ZUZyYW1lKGZhbHNlLCBhZGRGcmFtZUJ1dHRvbik7XG4gIGRyYXdJbWFnZShpbWFnZSk7XG59XG5cbmNvbnN0IHBlbmNpbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGVuJyk7XG5jb25zdCBlcmFzZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJhc2VyJyk7XG5jb25zdCBzdHJva2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Ryb2tlJyk7XG5jb25zdCBmaWxsQnVja2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1Y2tldCcpO1xuY29uc3QgY29sb3JQaWNrZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGlja2VyJyk7XG5jb25zdCBvbmVDb2xvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvbmVjb2xvcicpO1xubGV0IGN1cnJlbnRUb29sID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2N1cnJlbnRUb29sJykgfHwgJ3BlbmNpbGwnO1xuXG50b29sc1NldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gIGlmIChlLnRhcmdldCA9PT0gZXJhc2VyKSB7XG4gICAgY3VycmVudFRvb2wgPSAnZXJhc2VyJztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFRvb2wnLCAnZXJhc2VyJyk7XG4gICAgY3VycmVudENvbG9yID0gZGVmYXVsdENvbG9yO1xuICB9XG4gIGlmIChlLnRhcmdldCA9PT0gcGVuY2lsbCkge1xuICAgIGN1cnJlbnRUb29sID0gJ3BlbmNpbGwnO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VG9vbCcsICdwZW5jaWxsJyk7XG4gICAgY3VycmVudENvbG9yID0gY29sb3JzQnV0dG9uLnZhbHVlO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvcicsIGN1cnJlbnRDb2xvcik7XG4gIH1cbiAgaWYgKGUudGFyZ2V0ID09PSBzdHJva2UpIHtcbiAgICBjdXJyZW50VG9vbCA9ICdzdHJva2UnO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VG9vbCcsICdzdHJva2UnKTtcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxuICBpZiAoZS50YXJnZXQgPT09IGZpbGxCdWNrZXQpIHtcbiAgICBjdXJyZW50VG9vbCA9ICdidWNrZXQnO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VG9vbCcsICdidWNrZXQnKTtcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxuICBpZiAoZS50YXJnZXQgPT09IGNvbG9yUGlja2VyKSB7XG4gICAgY3VycmVudFRvb2wgPSAncGlja2VyJztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFRvb2wnLCAncGlja2VyJyk7XG4gICAgY3VycmVudENvbG9yID0gY29sb3JzQnV0dG9uLnZhbHVlO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvcicsIGN1cnJlbnRDb2xvcik7XG4gIH1cbiAgaWYgKGUudGFyZ2V0ID09PSBvbmVDb2xvcikge1xuICAgIGN1cnJlbnRUb29sID0gJ29uZWNvbG9yJztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFRvb2wnLCAnb25lY29sb3InKTtcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxufSk7XG5cbmxldCB4UG9zaXRpb24gPSAwO1xubGV0IHlQb3NpdGlvbiA9IDA7XG5sZXQgaW1hZ2VTdG9yYWdlID0gW107XG5cbmZ1bmN0aW9uIG1vdXNlUG9zaXRpb24oZWxlbWVudCkge1xuICB4UG9zaXRpb24gPSBNYXRoLmZsb29yKGVsZW1lbnQub2Zmc2V0WCAvIHNjYWxlKTtcbiAgeVBvc2l0aW9uID0gTWF0aC5mbG9vcihlbGVtZW50Lm9mZnNldFkgLyBzY2FsZSk7XG59XG5cblxuZnVuY3Rpb24gbW91c2UoeCwgeSwgY29sb3IpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3VzZVNpemU7IGkgKz0gMSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW91c2VTaXplOyBqICs9IDEpIHtcbiAgICAgIGlmIChpbWFnZVt5ICsgaV0gJiYgaW1hZ2VbeSArIGldW3ggKyBqXSkge1xuICAgICAgICBpbWFnZVt5ICsgaV1beCArIGpdID0gY29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRvTGluZSA9IGZ1bmN0aW9uIGxpbmUoeDAsIHkwLCB4MSwgeTEsIGNvbCkge1xuICBjb25zdCBkeCA9IE1hdGguYWJzKHgxIC0geDApO1xuICBjb25zdCBkeSA9IE1hdGguYWJzKHkxIC0geTApO1xuICBjb25zdCBzeCA9ICh4MCA8IHgxKSA/IDEgOiAtMTtcbiAgY29uc3Qgc3kgPSAoeTAgPCB5MSkgPyAxIDogLTE7XG4gIGxldCBlcnIgPSBkeCAtIGR5O1xuICBsZXQgbmV3WDAgPSB4MDtcbiAgbGV0IG5ld1kwID0geTA7XG4gIHdoaWxlICghKChuZXdYMCA9PT0geDEpICYmIChuZXdZMCA9PT0geTEpKSkge1xuICAgIG1vdXNlKG5ld1gwLCBuZXdZMCwgY29sKTtcbiAgICBjb25zdCBlMiA9IDIgKiBlcnI7XG4gICAgaWYgKGUyID4gLWR5KSB7XG4gICAgICBlcnIgLT0gZHk7XG4gICAgICBuZXdYMCArPSBzeDtcbiAgICB9XG4gICAgaWYgKGUyIDwgZHgpIHtcbiAgICAgIGVyciArPSBkeDtcbiAgICAgIG5ld1kwICs9IHN5O1xuICAgIH1cbiAgfVxufTtcblxuXG5sZXQgeHgwID0gMDtcbmxldCB5eTAgPSAwO1xuXG5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgaWYgKChlLndoaWNoID09PSAxKSAmJiAoY3VycmVudFRvb2wgPT09ICdwZW5jaWxsJykpIHtcbiAgICBtb3VzZVBvc2l0aW9uKGUpO1xuICAgIG1vdXNlKHhQb3NpdGlvbiwgeVBvc2l0aW9uLCBjdXJyZW50Q29sb3IpO1xuICAgIGRyYXdJbWFnZShpbWFnZSk7XG4gIH1cbiAgaWYgKChlLndoaWNoID09PSAxKSAmJiAoY3VycmVudFRvb2wgPT09ICdlcmFzZXInKSkge1xuICAgIG1vdXNlUG9zaXRpb24oZSk7XG4gICAgbW91c2UoeFBvc2l0aW9uLCB5UG9zaXRpb24sIGN1cnJlbnRDb2xvcik7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfVxuICBpZiAoKGUud2hpY2ggPT09IDEpICYmIChjdXJyZW50VG9vbCA9PT0gJ3N0cm9rZScpKSB7XG4gICAgaW1hZ2UgPSBpbWFnZVN0b3JhZ2UubWFwKChsaW5lKSA9PiBbLi4ubGluZV0pO1xuICAgIG1vdXNlUG9zaXRpb24oZSk7XG4gICAgZG9MaW5lKHh4MCwgeXkwLCB4UG9zaXRpb24sIHlQb3NpdGlvbiwgY3VycmVudENvbG9yKTtcbiAgICBkcmF3SW1hZ2UoaW1hZ2UpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZmlsbChjb2xvciwgaW5pdENvbG9yLCBbeSwgeF0sIGltYWdlRmlsbCkge1xuICBjb25zdCBjdXJyZW50Q29sb3JGb3JGaWxsID0gaW1hZ2VGaWxsW3ldICYmIGltYWdlRmlsbFt5XVt4XTtcbiAgaWYgKGN1cnJlbnRDb2xvckZvckZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29sb3IgPT09IGluaXRDb2xvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudENvbG9yRm9yRmlsbCAhPT0gaW5pdENvbG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGltYWdlW3ldW3hdID0gY29sb3I7XG5cbiAgZmlsbChjb2xvciwgaW5pdENvbG9yLCBbeSArIDEsIHhdLCBpbWFnZSk7XG4gIGZpbGwoY29sb3IsIGluaXRDb2xvciwgW3ksIHggKyAxXSwgaW1hZ2UpO1xuICBmaWxsKGNvbG9yLCBpbml0Q29sb3IsIFt5IC0gMSwgeF0sIGltYWdlKTtcbiAgZmlsbChjb2xvciwgaW5pdENvbG9yLCBbeSwgeCAtIDFdLCBpbWFnZSk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yRGlmZmVyZW5jZShtYWluQ29sb3IsIG9sZENvbG9yKSB7XG4gIGltYWdlLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJblNxdWFyZXM7IGkgKz0gMSkge1xuICAgICAgaWYgKGVsZW1lbnRbaV0gPT09IG9sZENvbG9yKSB7XG4gICAgICAgIGVsZW1lbnRbaV0gPSBtYWluQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gIGlmICgoZS53aGljaCA9PT0gMSkgJiYgKGN1cnJlbnRUb29sID09PSAncGVuY2lsbCcpKSB7XG4gICAgbW91c2VQb3NpdGlvbihlKTtcbiAgICBtb3VzZSh4UG9zaXRpb24sIHlQb3NpdGlvbiwgY3VycmVudENvbG9yKTtcbiAgICBkcmF3SW1hZ2UoaW1hZ2UpO1xuICB9XG4gIGlmICgoZS53aGljaCA9PT0gMSkgJiYgKGN1cnJlbnRUb29sID09PSAnZXJhc2VyJykpIHtcbiAgICBtb3VzZVBvc2l0aW9uKGUpO1xuICAgIG1vdXNlKHhQb3NpdGlvbiwgeVBvc2l0aW9uLCBjdXJyZW50Q29sb3IpO1xuICAgIGRyYXdJbWFnZShpbWFnZSk7XG4gIH1cbiAgaWYgKChlLndoaWNoID09PSAxKSAmJiAoY3VycmVudFRvb2wgPT09ICdzdHJva2UnKSkge1xuICAgIGltYWdlU3RvcmFnZSA9IGltYWdlLm1hcCgobGluZSkgPT4gWy4uLmxpbmVdKTtcbiAgICBtb3VzZVBvc2l0aW9uKGUpO1xuICAgIHh4MCA9IHhQb3NpdGlvbjtcbiAgICB5eTAgPSB5UG9zaXRpb247XG4gIH1cbiAgaWYgKChlLndoaWNoID09PSAxKSAmJiAoY3VycmVudFRvb2wgPT09ICdidWNrZXQnKSkge1xuICAgIG1vdXNlUG9zaXRpb24oZSk7XG4gICAgY29uc3QgaW5pdENvbG9yID0gaW1hZ2VbeVBvc2l0aW9uXVt4UG9zaXRpb25dO1xuICAgIGNvbnN0IGluaXRQb2ludCA9IFt5UG9zaXRpb24sIHhQb3NpdGlvbl07XG4gICAgZmlsbChjdXJyZW50Q29sb3IsIGluaXRDb2xvciwgaW5pdFBvaW50LCBpbWFnZSk7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfVxuICBpZiAoKGUud2hpY2ggPT09IDEpICYmIChjdXJyZW50VG9vbCA9PT0gJ3BpY2tlcicpKSB7XG4gICAgbW91c2VQb3NpdGlvbihlKTtcbiAgICBjb2xvcnNCdXR0b24udmFsdWUgPSBpbWFnZVt5UG9zaXRpb25dW3hQb3NpdGlvbl07XG4gIH1cbiAgaWYgKChlLndoaWNoID09PSAxKSAmJiAoY3VycmVudFRvb2wgPT09ICdvbmVjb2xvcicpKSB7XG4gICAgbW91c2VQb3NpdGlvbihlKTtcbiAgICBjb2xvckRpZmZlcmVuY2UoY3VycmVudENvbG9yLCBpbWFnZVt5UG9zaXRpb25dW3hQb3NpdGlvbl0pO1xuICAgIGRyYXdJbWFnZShpbWFnZSk7XG4gIH1cbn0pO1xuXG5yZXNpemVTZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaXplMScpKSB7XG4gICAgbW91c2VTaXplID0gMTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgMSk7XG4gIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaXplMicpKSB7XG4gICAgbW91c2VTaXplID0gMjtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgMik7XG4gIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaXplMycpKSB7XG4gICAgbW91c2VTaXplID0gMztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgMyk7XG4gIH0gZWxzZSB7XG4gICAgbW91c2VTaXplID0gNDtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgNCk7XG4gIH1cbn0pO1xuXG5wYWdlU2l6ZUNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gIGlmIChlLnRhcmdldCA9PT0gcGFnZVNpemUzMikge1xuICAgIHNpemVJblNxdWFyZXMgPSAzMjtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3F1YXJlcycsIDMyKTtcbiAgICBzY2FsZSA9IGNhbnZhc1NpemUgLyBzaXplSW5TcXVhcmVzO1xuICAgIGltYWdlID0gZmlsbEltYWdlKGRlZmF1bHRDb2xvcik7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfSBlbHNlIGlmIChlLnRhcmdldCA9PT0gcGFnZVNpemU2NCkge1xuICAgIHNpemVJblNxdWFyZXMgPSA2NDtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3F1YXJlcycsIDY0KTtcbiAgICBzY2FsZSA9IGNhbnZhc1NpemUgLyBzaXplSW5TcXVhcmVzO1xuICAgIGltYWdlID0gZmlsbEltYWdlKGRlZmF1bHRDb2xvcik7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfSBlbHNlIHtcbiAgICBzaXplSW5TcXVhcmVzID0gMTI4O1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzcXVhcmVzJywgMTI4KTtcbiAgICBzY2FsZSA9IGNhbnZhc1NpemUgLyBzaXplSW5TcXVhcmVzO1xuICAgIGltYWdlID0gZmlsbEltYWdlKGRlZmF1bHRDb2xvcik7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfVxufSk7XG5cbmNvbG9yc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gIGN1cnJlbnRDb2xvciA9IGNvbG9yc0J1dHRvbi52YWx1ZTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbn0pO1xuXG5hZGRGcmFtZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY3JlYXRlRnJhbWUoZmFsc2UsIGFkZEZyYW1lQnV0dG9uKTtcbn0pO1xuXG5mcmFtZXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICBpZiAoZS50YXJnZXQuZGF0YXNldC5hY3Rpb24gPT09ICdpbWcnIHx8IGUudGFyZ2V0LnBhcmVudE5vZGUuZGF0YXNldC5hY3Rpb24gPT09ICdpbWcnKSB7XG4gICAgYWN0aXZlRnJhbWVOdW1iZXIgPSBlLnRhcmdldC5kYXRhc2V0LmZyYW1lIHx8IGUudGFyZ2V0LnBhcmVudE5vZGUuZGF0YXNldC5mcmFtZTtcbiAgICBpbWFnZSA9IGdhbGxlcnlbYGltZyR7YWN0aXZlRnJhbWVOdW1iZXJ9YF07XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfVxuICBpZiAoZS50YXJnZXQuZGF0YXNldC5hY3Rpb24gPT09ICdjb3B5Jykge1xuICAgIGZyYW1lVG9BY3Rpb24gPSBOdW1iZXIoZS50YXJnZXQuZGF0YXNldC5mcmFtZSk7XG4gICAgY3JlYXRlRnJhbWUodHJ1ZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGZyYW1lJHtmcmFtZVRvQWN0aW9ufWApKTtcbiAgfVxuICBpZiAoZS50YXJnZXQuZGF0YXNldC5hY3Rpb24gPT09ICdkZWxldGUnKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mcmFtZS1udW1iZXInKS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBkZWxldGVGcmFtZSA9IE51bWJlcihlLnRhcmdldC5kYXRhc2V0LmZyYW1lKTtcbiAgICAgIGlmIChlLnRhcmdldC5kYXRhc2V0LmZyYW1lID09PSBhY3RpdmVGcmFtZU51bWJlcikge1xuICAgICAgICBhY3RpdmVGcmFtZU51bWJlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mcmFtZS1udW1iZXInKVswXS5kYXRhc2V0LmZyYW1lO1xuICAgICAgICBpbWFnZSA9IGdhbGxlcnlbYGltZyR7YWN0aXZlRnJhbWVOdW1iZXJ9YF07XG4gICAgICAgIGRyYXdJbWFnZShpbWFnZSk7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgZnJhbWUke2RlbGV0ZUZyYW1lfWApLnJlbW92ZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtbnVtYmVyJykubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mcmFtZS1udW1iZXInKVtpXSkge1xuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mcmFtZS1udW1iZXInKVtpXS5pbm5lckhUTUwgPSBgJHtpICsgMX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gU29ydGVkUHJldmlld3MoY29udGFpbmVyU2VsZWN0b3IsIGl0ZW1TZWxlY3Rvcikge1xuICBjb25zdCBjb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb250YWluZXJTZWxlY3Rvcik7XG4gIGNvbnN0IHNvcnRhYmxlID0gbmV3IFNvcnRhYmxlKGNvbnRhaW5lcnMsIHtcbiAgICBkcmFnZ2FibGU6IGl0ZW1TZWxlY3RvcixcbiAgfSk7XG4gIHJldHVybiBzb3J0YWJsZTtcbn1cblxuY29uc3Qgc29ydGFibGUgPSBTb3J0ZWRQcmV2aWV3cygnI2ZyYW1lc0NvbnRhaW5lcicsICcuZnJhbWUnKTtcblxuc29ydGFibGUub24oJ3NvcnRhYmxlOnN0YXJ0Jyk7XG5zb3J0YWJsZS5vbignc29ydGFibGU6c29ydCcpO1xuc29ydGFibGUub24oJ3NvcnRhYmxlOnNvcnRlZCcpO1xuc29ydGFibGUub24oJ3NvcnRhYmxlOnN0b3AnLCAoKSA9PiB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtbnVtYmVyJykubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtbnVtYmVyJylbaV0pIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZyYW1lLW51bWJlcicpW2ldLmlubmVySFRNTCA9IGAke2kgKyAxfWA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG5jb25zdCBwcmV2aWV3SW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldmlld0ltYWdlJyk7XG5cbmxldCBwaWNOdW1iZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnJhbWUtcGljIGltZycpLmxlbmd0aDtcblxubGV0IGludGVydmFsO1xuXG5mcHNCbG9jay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gIGlmIChlLnRhcmdldCA9PT0gbWludXNGcHMpIHtcbiAgICBpZiAoZnBzID4gMCkge1xuICAgICAgZnBzIC09IDE7XG4gICAgICBmcHNWYWx1ZS5pbm5lckhUTUwgPSBmcHM7XG4gICAgfVxuICB9XG4gIGlmIChlLnRhcmdldCA9PT0gcGx1c0Zwcykge1xuICAgIGlmIChmcHMgPCAyNCkge1xuICAgICAgZnBzICs9IDE7XG4gICAgICBmcHNWYWx1ZS5pbm5lckhUTUwgPSBmcHM7XG4gICAgfVxuICB9XG4gIGlmIChmcHMgPT09IDApIHtcbiAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcHMgPiAwKSB7XG4gICAgaWYgKHByZXZpZXdJbWFnZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHByZXZpZXdJbWFnZS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgcGljJHtwaWNOdW1iZXIgLSAxfWApKTtcbiAgICB9XG4gICAgcGljTnVtYmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZyYW1lLXBpYyBpbWcnKS5sZW5ndGg7XG5cbiAgICBjb25zdCBwaWN0dXJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mcmFtZS1waWMgaW1nJyk7XG5cbiAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChwcmV2aWV3SW1hZ2UuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHByZXZpZXdJbWFnZS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgcGljJHtwaWNOdW1iZXIgLSAxfWApKTtcbiAgICAgIH1cbiAgICAgIGlmIChwaWNOdW1iZXIgPiBwaWN0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgcGljTnVtYmVyID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld05ldyA9IHBpY3R1cmVzW3BpY051bWJlciAtIDFdLmNsb25lTm9kZSgpO1xuICAgICAgcHJldmlld0ltYWdlLmFwcGVuZENoaWxkKG5ld05ldyk7XG4gICAgICBuZXdOZXcuaWQgPSBgcGljJHtwaWNOdW1iZXJ9YDtcbiAgICAgIHBpY051bWJlciArPSAxO1xuICAgIH0sIDEwMDAgLyBmcHMpO1xuICB9XG59KTtcblxuY29uc3Qgc2hvcnRjdXRzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2hvcnRjdXRzJykpIHx8IHtcbiAgcGVuOiBbNjgsICdQJywgJ1BlbmNpbGwnXSxcbiAgYnVja2V0OiBbNjYsICdCJywgJ0ZpbGwgQnVja2V0J10sXG4gIG9uZWNvbG9yOiBbNjUsICdBJywgJ1BhaW50IGFsbCBwaXhlbHMgb2YgdGhlIHNhbWUgY29sb3InXSxcbiAgZXJhc2VyOiBbNjksICdFJywgJ0VyYXNlciddLFxuICBwaWNrZXI6IFs3OSwgJ08nLCAnQ29sb3IgUGlja2VyJ10sXG4gIHN0cm9rZTogWzc2LCAnTCcsICdTdHJva2UnXSxcbiAgZnJhbWU6IFs3OCwgJ04nLCAnQWRkIG5ldyBmcmFtZSddLFxuICB4MTogWzQ5LCAnMScsICdQZW4gc2l6ZSAxJ10sXG4gIHgyOiBbNTAsICcyJywgJ1BlbiBzaXplIDInXSxcbiAgeDM6IFs1MSwgJzMnLCAnUGVuIHNpemUgMyddLFxuICB4NDogWzUyLCAnNCcsICdQZW4gc2l6ZSA0J10sXG4gIHNpemUzMjogWzU2LCAnOCcsICdDYW52YXMgc2l6ZSAzMngzMiddLFxuICBzaXplNjQ6IFs1NywgJzknLCAnQ2FudmFzIHNpemUgNjR4NjQnXSxcbiAgc2l6ZTEyODogWzU4LCAnMCcsICdDYW52YXMgc2l6ZSAxMjh4MTI4J10sXG4gIGZwc1BsdXM6IFs4MSwgJ1EnLCAnRlBTICsnXSxcbiAgZnBzTWludXM6IFs4NywgJ1cnLCAnRlBTIC0nXSxcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMucGVuWzBdKSB7XG4gICAgY3VycmVudFRvb2wgPSAncGVuY2lsbCc7XG4gICAgY3VycmVudENvbG9yID0gY29sb3JzQnV0dG9uLnZhbHVlO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VG9vbCcsICdwZW5jaWxsJyk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxuICBpZiAoZXZlbnQud2hpY2ggPT09IHNob3J0Y3V0cy5idWNrZXRbMF0pIHtcbiAgICBjdXJyZW50VG9vbCA9ICdidWNrZXQnO1xuICAgIGN1cnJlbnRDb2xvciA9IGNvbG9yc0J1dHRvbi52YWx1ZTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFRvb2wnLCAnYnVja2V0Jyk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxuICBpZiAoZXZlbnQud2hpY2ggPT09IHNob3J0Y3V0cy5vbmVjb2xvclswXSkge1xuICAgIGN1cnJlbnRUb29sID0gJ29uZWNvbG9yJztcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRUb29sJywgJ29uZWNvbG9yJyk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yJywgY3VycmVudENvbG9yKTtcbiAgfVxuICBpZiAoZXZlbnQud2hpY2ggPT09IHNob3J0Y3V0cy5lcmFzZXJbMF0pIHtcbiAgICBjdXJyZW50VG9vbCA9ICdlcmFzZXInO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VG9vbCcsICdlcmFzZXInKTtcbiAgICBjdXJyZW50Q29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMucGlja2VyWzBdKSB7XG4gICAgY3VycmVudFRvb2wgPSAncGlja2VyJztcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRUb29sJywgJ3BpY2tlcicpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvcicsIGN1cnJlbnRDb2xvcik7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMuc3Ryb2tlWzBdKSB7XG4gICAgY3VycmVudFRvb2wgPSAnc3Ryb2tlJztcbiAgICBjdXJyZW50Q29sb3IgPSBjb2xvcnNCdXR0b24udmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRUb29sJywgJ3N0cm9rZScpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvcicsIGN1cnJlbnRDb2xvcik7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMuZnJhbWVbMF0pIHtcbiAgICBjcmVhdGVGcmFtZShmYWxzZSwgYWRkRnJhbWVCdXR0b24pO1xuICB9XG4gIGlmIChldmVudC53aGljaCA9PT0gc2hvcnRjdXRzLngxWzBdKSB7XG4gICAgbW91c2VTaXplID0gMTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgMSk7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMueDJbMF0pIHtcbiAgICBtb3VzZVNpemUgPSAyO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdtb3VzZVNpemUnLCAyKTtcbiAgfVxuICBpZiAoZXZlbnQud2hpY2ggPT09IHNob3J0Y3V0cy54M1swXSkge1xuICAgIG1vdXNlU2l6ZSA9IDM7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ21vdXNlU2l6ZScsIDMpO1xuICB9XG4gIGlmIChldmVudC53aGljaCA9PT0gc2hvcnRjdXRzLng0WzBdKSB7XG4gICAgbW91c2VTaXplID0gNDtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbW91c2VTaXplJywgNCk7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMuc2l6ZTMyWzBdKSB7XG4gICAgc2l6ZUluU3F1YXJlcyA9IDMyO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzcXVhcmVzJywgMzIpO1xuICAgIHNjYWxlID0gY2FudmFzU2l6ZSAvIHNpemVJblNxdWFyZXM7XG4gICAgaW1hZ2UgPSBmaWxsSW1hZ2UoZGVmYXVsdENvbG9yKTtcbiAgICBkcmF3SW1hZ2UoaW1hZ2UpO1xuICB9XG4gIGlmIChldmVudC53aGljaCA9PT0gc2hvcnRjdXRzLnNpemU2NFswXSkge1xuICAgIHNpemVJblNxdWFyZXMgPSA2NDtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3F1YXJlcycsIDY0KTtcbiAgICBzY2FsZSA9IGNhbnZhc1NpemUgLyBzaXplSW5TcXVhcmVzO1xuICAgIGltYWdlID0gZmlsbEltYWdlKGRlZmF1bHRDb2xvcik7XG4gICAgZHJhd0ltYWdlKGltYWdlKTtcbiAgfVxuICBpZiAoZXZlbnQud2hpY2ggPT09IHNob3J0Y3V0cy5zaXplMTI4WzBdKSB7XG4gICAgc2l6ZUluU3F1YXJlcyA9IDEyODtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3F1YXJlcycsIDEyOCk7XG4gICAgc2NhbGUgPSBjYW52YXNTaXplIC8gc2l6ZUluU3F1YXJlcztcbiAgICBpbWFnZSA9IGZpbGxJbWFnZShkZWZhdWx0Q29sb3IpO1xuICAgIGRyYXdJbWFnZShpbWFnZSk7XG4gIH1cbiAgaWYgKGV2ZW50LndoaWNoID09PSBzaG9ydGN1dHMuZnBzUGx1c1swXSkge1xuICAgIGlmIChmcHMgPCAyNCkge1xuICAgICAgZnBzICs9IDE7XG4gICAgICBmcHNWYWx1ZS5pbm5lckhUTUwgPSBmcHM7XG4gICAgfVxuICB9XG4gIGlmIChldmVudC53aGljaCA9PT0gc2hvcnRjdXRzLmZwc01pbnVzWzBdKSB7XG4gICAgaWYgKGZwcyA+IDApIHtcbiAgICAgIGZwcyAtPSAxO1xuICAgICAgZnBzVmFsdWUuaW5uZXJIVE1MID0gZnBzO1xuICAgIH1cbiAgfVxufSk7XG5cbmNvbnN0IHNob3J0Y3V0QXJyID0gWydwZW4nLCAnYnVja2V0JywgJ29uZWNvbG9yJywgJ2VyYXNlcicsICdwaWNrZXInLCAnc3Ryb2tlJywgJ2ZyYW1lJywgJ3gxJywgJ3gyJywgJ3gzJywgJ3g0JywgJ3NpemUzMicsICdzaXplNjQnLCAnc2l6ZTEyOCcsICdmcHNQbHVzJywgJ2Zwc01pbnVzJ107XG5cbmNvbnN0IGtleXNJbnN0cnVjdGlvbnMgPSBhZGRFbGVtZW50KCdzZWN0aW9uJywgJ2tleXMtaW5zdHJ1Y3Rpb25zJywgJ2tleXNJbnN0cnVjdGlvbnMnLCBkb2N1bWVudC5ib2R5KTtcbmNvbnN0IGtleXNCb3ggPSBhZGRFbGVtZW50KCdkaXYnLCAna2V5cy1ib3gnLCAna2V5c0JveCcsIGtleXNJbnN0cnVjdGlvbnMpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IHNob3J0Y3V0QXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gIGFkZEVsZW1lbnQoJ2RpdicsICdzaG9ydGN1dC1saW5lJywgYHNob3J0Q3V0TGluZSR7aX1gLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna2V5c0JveCcpKTtcbiAgYWRkRWxlbWVudCgnZGl2JywgJ3Nob3J0Y3V0LWJ1dHRvbicsIGBzaG9ydGN1dEJ1dHRvbiR7aX1gLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgc2hvcnRDdXRMaW5lJHtpfWApKTtcbiAgYWRkRWxlbWVudCgnZGl2JywgJ3Nob3J0Y3V0LWRlc2NyaXB0aW9uJywgYHNob3J0Y3V0RGVzY3JpcHRpb24ke2l9YCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYHNob3J0Q3V0TGluZSR7aX1gKSk7XG4gIFssXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYHNob3J0Y3V0QnV0dG9uJHtpfWApLmlubmVySFRNTCxcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgc2hvcnRjdXREZXNjcmlwdGlvbiR7aX1gKS5pbm5lckhUTUwsXG4gIF0gPSBzaG9ydGN1dHNbc2hvcnRjdXRBcnJbaV1dO1xufVxuXG5zaG9ydGN1dHNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGtleXNJbnN0cnVjdGlvbnMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn0pO1xuXG5rZXlzSW5zdHJ1Y3Rpb25zLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgaWYgKGUudGFyZ2V0ID09PSBrZXlzSW5zdHJ1Y3Rpb25zKSB7XG4gICAga2V5c0luc3RydWN0aW9ucy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIH1cbn0pO1xuXG5jb25zdCBjaGFuZ2VLZXlJbmZvID0gW2ZhbHNlLCAnJywgJyddO1xuXG5rZXlzQm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGN1dEFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChlLnRhcmdldC5pbm5lckhUTUwgPT09IHNob3J0Y3V0c1tzaG9ydGN1dEFycltpXV1bMV0pIHtcbiAgICAgIGNoYW5nZUtleUluZm9bMV0gPSBzaG9ydGN1dEFycltpXTtcbiAgICAgIGNoYW5nZUtleUluZm9bMF0gPSB0cnVlO1xuICAgICAgY2hhbmdlS2V5SW5mb1syXSA9IGk7XG4gICAgfVxuICB9XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gIGlmIChjaGFuZ2VLZXlJbmZvWzFdICYmIGNoYW5nZUtleUluZm9bMF0pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0Y3V0QXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc2hvcnRjdXRzW3Nob3J0Y3V0QXJyW2ldXVsxXSA9PT0gZS5jb2RlLnNsaWNlKC0xKSkge1xuICAgICAgICBzaG9ydGN1dHNbc2hvcnRjdXRBcnJbaV1dWzBdID0gJyAnO1xuICAgICAgICBzaG9ydGN1dHNbc2hvcnRjdXRBcnJbaV1dWzFdID0gJz8/Pyc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBzaG9ydGN1dEJ1dHRvbiR7aX1gKS5pbm5lckhUTUwgPSAnPz8/JztcbiAgICAgIH1cbiAgICB9XG4gICAgc2hvcnRjdXRzW2NoYW5nZUtleUluZm9bMV1dWzBdID0gZS53aGljaDtcbiAgICBzaG9ydGN1dHNbY2hhbmdlS2V5SW5mb1sxXV1bMV0gPSBlLmNvZGUuc2xpY2UoLTEpO1xuICAgIFssIGUudGFyZ2V0Lmh0bWxJbm5lcl0gPSBjaGFuZ2VLZXlJbmZvO1xuXG4gICAgWywgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYHNob3J0Y3V0QnV0dG9uJHtjaGFuZ2VLZXlJbmZvWzJdfWApLmlubmVySFRNTF0gPSBzaG9ydGN1dHNbY2hhbmdlS2V5SW5mb1sxXV07XG4gICAgY2hhbmdlS2V5SW5mb1swXSA9IGZhbHNlO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzaG9ydGN1dHMnLCBKU09OLnN0cmluZ2lmeShzaG9ydGN1dHMpKTtcbiAgfVxufSk7XG5cbmNvbnN0IGJ0dCA9IGFkZEVsZW1lbnQoJ2RpdicsICdidHQnLCAnYnR0JywgcHJldmlld0Jsb2NrKTtcbmJ0dC5pbm5lckhUTUwgPSAnRnVsbCBzY3JlZW4nO1xuYnR0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBpZiAocHJldmlld0ltYWdlLnJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgcHJldmlld0ltYWdlLnJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAocHJldmlld0ltYWdlLm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgcHJldmlld0ltYWdlLm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAocHJldmlld0ltYWdlLndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgcHJldmlld0ltYWdlLndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gIH1cbn0pO1xuXG5jb25zdCBnaWZCdXR0b24gPSBhZGRFbGVtZW50KCdkaXYnLCAnZ2lmLWJ1dHRvbicsICdnaWZCdXR0b24nLCBwcmV2aWV3QmxvY2spO1xuZ2lmQnV0dG9uLmlubmVySFRNTCA9ICdHSUYuIGV4cG9ydCc7XG5cbmdpZkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY29uc3QgZnJhbWVJbWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZyYW1lLXBpYyBpbWcnKTtcbiAgY29uc3QgZnJhbWVzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGZyYW1lSW1ncywgKHsgc3JjIH0pID0+IHNyYyk7XG4gIG1ha2VHaWZFeHBvcnRMaW5rKGZyYW1lcywgZnBzLCAobGluaykgPT4ge1xuICAgIGNvbnN0IGxpbmtBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmtBLnNldEF0dHJpYnV0ZSgnaHJlZicsIGxpbmspO1xuICAgIGxpbmtBLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBsaW5rKTtcbiAgICBsaW5rQS5jbGljaygpO1xuICB9KTtcbn0pO1xuXG5jb25zdCBhcG5nQnV0dG9uID0gYWRkRWxlbWVudCgnZGl2JywgJ2FwbmctYnV0dG9uJywgJ2FwbmdCdXR0b24nLCBwcmV2aWV3QmxvY2spO1xuYXBuZ0J1dHRvbi5pbm5lckhUTUwgPSAnQVBORy4gZXhwb3J0JztcblxuYXBuZ0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgY29uc3QgZnJhbWVJbWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZyYW1lLXBpYyBpbWcnKTtcbiAgY29uc3QgZnJhbWVzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGZyYW1lSW1ncywgKHsgc3JjIH0pID0+IHNyYyk7XG5cbiAgbWFrZUFwbmdFeHBvcnRMaW5rKGZyYW1lcywgZnBzLCBjYW52YXNTaXplLCAoYmluKSA9PiB7XG4gICAgY29uc3QgbGluayA9IGBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtiaW59YDtcblxuICAgIGNvbnN0IGxpbmtBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmtBLnNldEF0dHJpYnV0ZSgnaHJlZicsIGxpbmspO1xuICAgIGxpbmtBLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBsaW5rKTtcbiAgICBsaW5rQS5jbGljaygpO1xuICB9KTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")}]);